[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml\group__symlink.xml]
[section:symlink_2_batch symlink (batch)]
'''<?dbhtml-include href="disqus_identifiers/symlink_2_batch.html"?>'''

'''<indexterm><primary>symlink</primary></indexterm>'''
Schedule a batch of asynchronous symlink creations and opens after a precondition. 

[heading Description]
Note that if creating and you don't specify a target, the target for the symlink is the precondition. On Windows directories are symlinked using a reparse point instead of a symlink due to the default lack of the [^`SeCreateSymbolicLinkPrivilege`] for non-Administrative users. On Windows you can open symlinks as a file and so a valid handle is output, whereas on POSIX except for Linux you cannot do this and an invalid handle is output. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``future dispatcher::symlink(const std::vector< path_req > & reqs, const std::vector< future<>> & targets = std::vector< future<>>())``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const std::vector< path_req > &] [] [reqs] [A batch of [^`path_req`] structures. ]]
[[const std::vector< future<>> &] [] [targets] [An optional batch of targets if creating symlinks.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, Windows..Link creation is race free up to the containing directory. Destination is unavoidably racy.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if symlink creation is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_symlink_4_relative async_symlink (relative)]
'''<?dbhtml-include href="disqus_identifiers/async_symlink_4_relative.html"?>'''

'''<indexterm><primary>async_symlink</primary></indexterm>'''
Asynchronous symlink creation and open after a precondition. 

[heading Description]
Note that if creating and you don't specify a target, the target for the symlink is the precondition. On Windows directories are symlinked using a reparse point instead of a symlink due to the default lack of the [^`SeCreateSymbolicLinkPrivilege`] for non-Administrative users. On Windows you can open symlinks as a file and so a valid handle is output, whereas on POSIX except for Linux you cannot do this and an invalid handle is output. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
future async_symlink(future<> _precondition, T _path, future<> _target = future<>(),
                     file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T] [] [_path] [The filing system path to use. ]]
[[future<>] [] [_target] [The item to link to if creating. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Returns]
A future<void>

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, Windows..Link creation is race free up to the containing directory. Destination is unavoidably racy.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink creation is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_symlink_3_absolute async_symlink (absolute)]
'''<?dbhtml-include href="disqus_identifiers/async_symlink_3_absolute.html"?>'''

'''<indexterm><primary>async_symlink</primary></indexterm>'''
Asynchronous symlink creation and open after a precondition. 

[heading Description]
Note that if creating and you don't specify a target, the target for the symlink is the precondition. On Windows directories are symlinked using a reparse point instead of a symlink due to the default lack of the [^`SeCreateSymbolicLinkPrivilege`] for non-Administrative users. On Windows you can open symlinks as a file and so a valid handle is output, whereas on POSIX except for Linux you cannot do this and an invalid handle is output. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T, typename>
future async_symlink(T _path, future<> _target = future<>(), file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[] [] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to use. ]]
[[future<>] [] [_target] [The item to link to if creating. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Returns]
A future<void>

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink creation is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:symlink_4_relative_throwing symlink (relative throwing)]
'''<?dbhtml-include href="disqus_identifiers/symlink_4_relative_throwing.html"?>'''

'''<indexterm><primary>symlink</primary></indexterm>'''
Synchronous symlink creation and open after a precondition.. 

[heading Description]
Note that if creating and you don't specify a target, the target for the symlink is the precondition. On Windows directories are symlinked using a reparse point instead of a symlink due to the default lack of the [^`SeCreateSymbolicLinkPrivilege`] for non-Administrative users. On Windows you can open symlinks as a file and so a valid handle is output, whereas on POSIX except for Linux you cannot do this and an invalid handle is output. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
handle_ptr symlink(future<> _precondition, T _path, future<> _target = future<>(),
                   file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T] [] [_path] [The filing system path to use. ]]
[[future<>] [] [_target] [The item to link to if creating. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Returns]
A handle to the symlink. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, Windows..Link creation is race free up to the containing directory. Destination is unavoidably racy.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink creation is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:symlink_3_absolute_throwing symlink (absolute throwing)]
'''<?dbhtml-include href="disqus_identifiers/symlink_3_absolute_throwing.html"?>'''

'''<indexterm><primary>symlink</primary></indexterm>'''
Synchronous symlink creation and open after a precondition. 

[heading Description]
Note that if creating and you don't specify a target, the target for the symlink is the precondition. On Windows directories are symlinked using a reparse point instead of a symlink due to the default lack of the [^`SeCreateSymbolicLinkPrivilege`] for non-Administrative users. On Windows you can open symlinks as a file and so a valid handle is output, whereas on POSIX except for Linux you cannot do this and an invalid handle is output. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T, typename>
handle_ptr symlink(T _path, future<> _target = future<>(), file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[] [] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to use. ]]
[[future<>] [] [_target] [The item to link to if creating. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Returns]
A handle to the symlink. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink creation is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:symlink_5_relative_non_throwing symlink (relative non throwing)]
'''<?dbhtml-include href="disqus_identifiers/symlink_5_relative_non_throwing.html"?>'''

'''<indexterm><primary>symlink</primary></indexterm>'''
Synchronous symlink creation and open after a precondition. 

[heading Description]
Note that if creating and you don't specify a target, the target for the symlink is the precondition. On Windows directories are symlinked using a reparse point instead of a symlink due to the default lack of the [^`SeCreateSymbolicLinkPrivilege`] for non-Administrative users. On Windows you can open symlinks as a file and so a valid handle is output, whereas on POSIX except for Linux you cannot do this and an invalid handle is output. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
handle_ptr symlink(error_code & _ec, future<> _precondition, T _path,
                   future<> _target = future<>(), file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[error_code &] [] [_ec] [Error code to set. ]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T] [] [_path] [The filing system path to use. ]]
[[future<>] [] [_target] [The item to link to if creating. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Returns]
A handle to the symlink. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, Windows..Link creation is race free up to the containing directory. Destination is unavoidably racy.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink creation is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:symlink_4_absolute_non_throwing symlink (absolute non throwing)]
'''<?dbhtml-include href="disqus_identifiers/symlink_4_absolute_non_throwing.html"?>'''

'''<indexterm><primary>symlink</primary></indexterm>'''
Synchronous symlink creation and open after a precondition. 

[heading Description]
Note that if creating and you don't specify a target, the target for the symlink is the precondition. On Windows directories are symlinked using a reparse point instead of a symlink due to the default lack of the [^`SeCreateSymbolicLinkPrivilege`] for non-Administrative users. On Windows you can open symlinks as a file and so a valid handle is output, whereas on POSIX except for Linux you cannot do this and an invalid handle is output. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T, typename>
handle_ptr symlink(error_code & _ec, T _path, future<> _target = future<>(),
                   file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[] [] [ - ] [Must be specified]]
[[error_code &] [] [_ec] [Error code to set. ]]
[[T] [] [_path] [The filing system path to use. ]]
[[future<>] [] [_target] [The item to link to if creating. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Returns]
A handle to the symlink. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink creation is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

