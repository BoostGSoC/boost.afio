[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml\group__enumerate.xml]
[section:enumerate_1_batch enumerate (batch)]
'''<?dbhtml-include href="disqus_identifiers/enumerate_1_batch.html"?>'''

'''<indexterm><primary>enumerate</primary></indexterm>'''
Schedule a batch of asynchronous directory enumerations after preceding operations. 

[heading Description]
By default dir() returns shared handles i.e. dir( foo) and dir( foo) will return the exact same handle, and therefore enumerating not all of the entries at once is a race condition. The solution is to either set maxitems to a value large enough to guarantee a directory will be enumerated in a single shot, or to open a separate directory handle using the file\u005fflags::unique\u005fdirectory\u005fhandle flag. Note that setting maxitems=1 will often cause a buffer space exhaustion, causing a second syscall with an enlarged buffer. This is because AFIO cannot know if the allocated buffer can hold all of the filename being retrieved, so it may have to retry. Put another way, setting maxitems=1 will give you the worst performance possible, whereas maxitems=2 will probably only return one item most of the time. Related types: [^`__afio_enumerate_req__`], [^`__afio_directory_entry__`], [^`__afio_stat_t__`]

[heading Synopsis]
``future< std::pair< std::vector< directory_entry >, bool > > dispatcher::enumerate(const std::vector< enumerate_req > & reqs)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const std::vector< enumerate_req > &] [] [reqs] [A batch of enumeration requests.]]
]


[heading Returns]
A batch of stl\u005ffuture vectors of directory entries with boolean returning false if done. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that
many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so
comparing inodes for equivalence to a direntry() won't help you.]
[raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated,
birthtim, sparse, compressed.]
 ]
[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool*M) to complete where M is the average number of entries in each directory.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][enumerate_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_enumerate_6_maxitems_first async_enumerate (maxitems first)]
'''<?dbhtml-include href="disqus_identifiers/async_enumerate_6_maxitems_first.html"?>'''

'''<indexterm><primary>async_enumerate</primary></indexterm>'''
Asynchronous directory enumeration after a preceding operation. 

[heading Description]
By default dir() returns shared handles i.e. dir( foo) and dir( foo) will return the exact same handle, and therefore enumerating not all of the entries at once is a race condition. The solution is to either set maxitems to a value large enough to guarantee a directory will be enumerated in a single shot, or to open a separate directory handle using the file\u005fflags::unique\u005fdirectory\u005fhandle flag. Note that setting maxitems=1 will often cause a buffer space exhaustion, causing a second syscall with an enlarged buffer. This is because AFIO cannot know if the allocated buffer can hold all of the filename being retrieved, so it may have to retry. Put another way, setting maxitems=1 will give you the worst performance possible, whereas maxitems=2 will probably only return one item most of the time. Related types: [^`__afio_enumerate_req__`], [^`__afio_directory_entry__`], [^`__afio_stat_t__`]

[heading Synopsis]
``future<std::pair<std::vector<directory_entry>, bool> > async_enumerate(future<> _precondition, size_t _maxitems = 2, bool _restart = true,
                                                                            path _glob = path(), metadata_flags _metadata = metadata_flags::None, enumerate_req::filter _filtering = enumerate_req::filter::fastdeleted)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[size_t] [] [_maxitems] [The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. ]]
[[bool] [] [_restart] [Restarts the enumeration for this open directory handle. ]]
[[path] [] [_glob] [An optional shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. ]]
[[metadata_flags] [] [_metadata] [The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. ]]
[[enumerate_req::filter] [] [_filtering] [Any filtering you want AFIO to do for you.]]
]


[heading Returns]
A [^`future<std::pair<std::vector<``directory_entry``>, bool>>`]

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that
many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so
comparing inodes for equivalence to a direntry() won't help you.]
[raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated,
birthtim, sparse, compressed.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][enumerate_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:enumerate_6_max_items_first_throwing enumerate (max items first throwing)]
'''<?dbhtml-include href="disqus_identifiers/enumerate_6_max_items_first_throwing.html"?>'''

'''<indexterm><primary>enumerate</primary></indexterm>'''
Synchronous directory enumeration after a preceding operation. 

[heading Description]
By default dir() returns shared handles i.e. dir( foo) and dir( foo) will return the exact same handle, and therefore enumerating not all of the entries at once is a race condition. The solution is to either set maxitems to a value large enough to guarantee a directory will be enumerated in a single shot, or to open a separate directory handle using the file\u005fflags::unique\u005fdirectory\u005fhandle flag. Note that setting maxitems=1 will often cause a buffer space exhaustion, causing a second syscall with an enlarged buffer. This is because AFIO cannot know if the allocated buffer can hold all of the filename being retrieved, so it may have to retry. Put another way, setting maxitems=1 will give you the worst performance possible, whereas maxitems=2 will probably only return one item most of the time. Related types: [^`__afio_enumerate_req__`], [^`__afio_directory_entry__`], [^`__afio_stat_t__`]

[heading Synopsis]
``std::pair<std::vector<directory_entry>, bool> enumerate(future<> _precondition, size_t _maxitems = 2, bool _restart = true,
                                                            path _glob = path(), metadata_flags _metadata = metadata_flags::None, enumerate_req::filter _filtering = enumerate_req::filter::fastdeleted)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[size_t] [] [_maxitems] [The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. ]]
[[bool] [] [_restart] [Restarts the enumeration for this open directory handle. ]]
[[path] [] [_glob] [An optional shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. ]]
[[metadata_flags] [] [_metadata] [The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. ]]
[[enumerate_req::filter] [] [_filtering] [Any filtering you want AFIO to do for you.]]
]


[heading Returns]
A vector of results and a bool indicating if there is more. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that
many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so
comparing inodes for equivalence to a direntry() won't help you.]
[raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated,
birthtim, sparse, compressed.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][enumerate_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:enumerate_7_max_items_first_non_throwing enumerate (max items first non throwing)]
'''<?dbhtml-include href="disqus_identifiers/enumerate_7_max_items_first_non_throwing.html"?>'''

'''<indexterm><primary>enumerate</primary></indexterm>'''
Synchronous directory enumeration after a preceding operation. 

[heading Description]
By default dir() returns shared handles i.e. dir( foo) and dir( foo) will return the exact same handle, and therefore enumerating not all of the entries at once is a race condition. The solution is to either set maxitems to a value large enough to guarantee a directory will be enumerated in a single shot, or to open a separate directory handle using the file\u005fflags::unique\u005fdirectory\u005fhandle flag. Note that setting maxitems=1 will often cause a buffer space exhaustion, causing a second syscall with an enlarged buffer. This is because AFIO cannot know if the allocated buffer can hold all of the filename being retrieved, so it may have to retry. Put another way, setting maxitems=1 will give you the worst performance possible, whereas maxitems=2 will probably only return one item most of the time. Related types: [^`__afio_enumerate_req__`], [^`__afio_directory_entry__`], [^`__afio_stat_t__`]

[heading Synopsis]
``std::pair<std::vector<directory_entry>, bool> enumerate(error_code & _ec, future<> _precondition, size_t _maxitems = 2,
                                                            bool _restart = true, path _glob = path(), metadata_flags _metadata = metadata_flags::None,
                                                            enumerate_req::filter _filtering = enumerate_req::filter::fastdeleted)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[error_code &] [] [_ec] [Error code to set. ]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[size_t] [] [_maxitems] [The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. ]]
[[bool] [] [_restart] [Restarts the enumeration for this open directory handle. ]]
[[path] [] [_glob] [An optional shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. ]]
[[metadata_flags] [] [_metadata] [The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. ]]
[[enumerate_req::filter] [] [_filtering] [Any filtering you want AFIO to do for you.]]
]


[heading Returns]
A vector of results and a bool indicating if there is more. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that
many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so
comparing inodes for equivalence to a direntry() won't help you.]
[raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated,
birthtim, sparse, compressed.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][enumerate_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_enumerate_6_glob_first async_enumerate (glob first)]
'''<?dbhtml-include href="disqus_identifiers/async_enumerate_6_glob_first.html"?>'''

'''<indexterm><primary>async_enumerate</primary></indexterm>'''
Asynchronous directory enumeration after a preceding operation. 

[heading Description]
By default dir() returns shared handles i.e. dir( foo) and dir( foo) will return the exact same handle, and therefore enumerating not all of the entries at once is a race condition. The solution is to either set maxitems to a value large enough to guarantee a directory will be enumerated in a single shot, or to open a separate directory handle using the file\u005fflags::unique\u005fdirectory\u005fhandle flag. Note that setting maxitems=1 will often cause a buffer space exhaustion, causing a second syscall with an enlarged buffer. This is because AFIO cannot know if the allocated buffer can hold all of the filename being retrieved, so it may have to retry. Put another way, setting maxitems=1 will give you the worst performance possible, whereas maxitems=2 will probably only return one item most of the time. Related types: [^`__afio_enumerate_req__`], [^`__afio_directory_entry__`], [^`__afio_stat_t__`]

[heading Synopsis]
``future<std::pair<std::vector<directory_entry>, bool> > async_enumerate(future<> _precondition, path _glob, size_t _maxitems = 2,
                                                                            bool _restart = true, metadata_flags _metadata = metadata_flags::None, enumerate_req::filter _filtering = enumerate_req::filter::fastdeleted)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[path] [] [_glob] [A shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. ]]
[[size_t] [] [_maxitems] [The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. ]]
[[bool] [] [_restart] [Restarts the enumeration for this open directory handle. ]]
[[metadata_flags] [] [_metadata] [The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. ]]
[[enumerate_req::filter] [] [_filtering] [Any filtering you want AFIO to do for you.]]
]


[heading Returns]
A [^`future<std::pair<std::vector<``directory_entry``>, bool>>`]

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that
many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so
comparing inodes for equivalence to a direntry() won't help you.]
[raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated,
birthtim, sparse, compressed.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][enumerate_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:enumerate_6_glob_first_throwing enumerate (glob first throwing)]
'''<?dbhtml-include href="disqus_identifiers/enumerate_6_glob_first_throwing.html"?>'''

'''<indexterm><primary>enumerate</primary></indexterm>'''
Synchronous directory enumeration after a preceding operation. 

[heading Description]
By default dir() returns shared handles i.e. dir( foo) and dir( foo) will return the exact same handle, and therefore enumerating not all of the entries at once is a race condition. The solution is to either set maxitems to a value large enough to guarantee a directory will be enumerated in a single shot, or to open a separate directory handle using the file\u005fflags::unique\u005fdirectory\u005fhandle flag. Note that setting maxitems=1 will often cause a buffer space exhaustion, causing a second syscall with an enlarged buffer. This is because AFIO cannot know if the allocated buffer can hold all of the filename being retrieved, so it may have to retry. Put another way, setting maxitems=1 will give you the worst performance possible, whereas maxitems=2 will probably only return one item most of the time. Related types: [^`__afio_enumerate_req__`], [^`__afio_directory_entry__`], [^`__afio_stat_t__`]

[heading Synopsis]
``std::pair<std::vector<directory_entry>, bool> enumerate(future<> _precondition, path _glob, size_t _maxitems = 2,
                                                            bool _restart = true, metadata_flags _metadata = metadata_flags::None, enumerate_req::filter _filtering = enumerate_req::filter::fastdeleted)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[path] [] [_glob] [A shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. ]]
[[size_t] [] [_maxitems] [The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. ]]
[[bool] [] [_restart] [Restarts the enumeration for this open directory handle. ]]
[[metadata_flags] [] [_metadata] [The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. ]]
[[enumerate_req::filter] [] [_filtering] [Any filtering you want AFIO to do for you.]]
]


[heading Returns]
A vector of results and a bool indicating if there is more. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that
many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so
comparing inodes for equivalence to a direntry() won't help you.]
[raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated,
birthtim, sparse, compressed.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][enumerate_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:enumerate_7_glob_first_non_throwing enumerate (glob first non throwing)]
'''<?dbhtml-include href="disqus_identifiers/enumerate_7_glob_first_non_throwing.html"?>'''

'''<indexterm><primary>enumerate</primary></indexterm>'''
Synchronous directory enumeration after a preceding operation. 

[heading Description]
By default dir() returns shared handles i.e. dir( foo) and dir( foo) will return the exact same handle, and therefore enumerating not all of the entries at once is a race condition. The solution is to either set maxitems to a value large enough to guarantee a directory will be enumerated in a single shot, or to open a separate directory handle using the file\u005fflags::unique\u005fdirectory\u005fhandle flag. Note that setting maxitems=1 will often cause a buffer space exhaustion, causing a second syscall with an enlarged buffer. This is because AFIO cannot know if the allocated buffer can hold all of the filename being retrieved, so it may have to retry. Put another way, setting maxitems=1 will give you the worst performance possible, whereas maxitems=2 will probably only return one item most of the time. Related types: [^`__afio_enumerate_req__`], [^`__afio_directory_entry__`], [^`__afio_stat_t__`]

[heading Synopsis]
``std::pair<std::vector<directory_entry>, bool> enumerate(error_code & _ec, future<> _precondition, path _glob,
                                                            size_t _maxitems = 2, bool _restart = true, metadata_flags _metadata = metadata_flags::None,
                                                            enumerate_req::filter _filtering = enumerate_req::filter::fastdeleted)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[error_code &] [] [_ec] [Error code to set. ]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[path] [] [_glob] [A shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. ]]
[[size_t] [] [_maxitems] [The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. ]]
[[bool] [] [_restart] [Restarts the enumeration for this open directory handle. ]]
[[metadata_flags] [] [_metadata] [The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. ]]
[[enumerate_req::filter] [] [_filtering] [Any filtering you want AFIO to do for you.]]
]


[heading Returns]
A vector of results and a bool indicating if there is more. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that
many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so
comparing inodes for equivalence to a direntry() won't help you.]
[raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated,
birthtim, sparse, compressed.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][enumerate_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_enumerate_6_metadata_first async_enumerate (metadata first)]
'''<?dbhtml-include href="disqus_identifiers/async_enumerate_6_metadata_first.html"?>'''

'''<indexterm><primary>async_enumerate</primary></indexterm>'''
Asynchronous directory enumeration after a preceding operation. 

[heading Description]
By default dir() returns shared handles i.e. dir( foo) and dir( foo) will return the exact same handle, and therefore enumerating not all of the entries at once is a race condition. The solution is to either set maxitems to a value large enough to guarantee a directory will be enumerated in a single shot, or to open a separate directory handle using the file\u005fflags::unique\u005fdirectory\u005fhandle flag. Note that setting maxitems=1 will often cause a buffer space exhaustion, causing a second syscall with an enlarged buffer. This is because AFIO cannot know if the allocated buffer can hold all of the filename being retrieved, so it may have to retry. Put another way, setting maxitems=1 will give you the worst performance possible, whereas maxitems=2 will probably only return one item most of the time. Related types: [^`__afio_enumerate_req__`], [^`__afio_directory_entry__`], [^`__afio_stat_t__`]

[heading Synopsis]
``future<std::pair<std::vector<directory_entry>, bool> > async_enumerate(future<> _precondition, metadata_flags _metadata, size_t _maxitems = 2,
                                                                            bool _restart = true, path _glob = path(), enumerate_req::filter _filtering = enumerate_req::filter::fastdeleted)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[metadata_flags] [] [_metadata] [The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. ]]
[[size_t] [] [_maxitems] [The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. ]]
[[bool] [] [_restart] [Restarts the enumeration for this open directory handle. ]]
[[path] [] [_glob] [An optional shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. ]]
[[enumerate_req::filter] [] [_filtering] [Any filtering you want AFIO to do for you.]]
]


[heading Returns]
A [^`future<std::pair<std::vector<``directory_entry``>, bool>>`]

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that
many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so
comparing inodes for equivalence to a direntry() won't help you.]
[raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated,
birthtim, sparse, compressed.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][enumerate_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:enumerate_6_metadata_first_throwing enumerate (metadata first throwing)]
'''<?dbhtml-include href="disqus_identifiers/enumerate_6_metadata_first_throwing.html"?>'''

'''<indexterm><primary>enumerate</primary></indexterm>'''
Synchronous directory enumeration after a preceding operation. 

[heading Description]
By default dir() returns shared handles i.e. dir( foo) and dir( foo) will return the exact same handle, and therefore enumerating not all of the entries at once is a race condition. The solution is to either set maxitems to a value large enough to guarantee a directory will be enumerated in a single shot, or to open a separate directory handle using the file\u005fflags::unique\u005fdirectory\u005fhandle flag. Note that setting maxitems=1 will often cause a buffer space exhaustion, causing a second syscall with an enlarged buffer. This is because AFIO cannot know if the allocated buffer can hold all of the filename being retrieved, so it may have to retry. Put another way, setting maxitems=1 will give you the worst performance possible, whereas maxitems=2 will probably only return one item most of the time. Related types: [^`__afio_enumerate_req__`], [^`__afio_directory_entry__`], [^`__afio_stat_t__`]

[heading Synopsis]
``std::pair<std::vector<directory_entry>, bool> enumerate(future<> _precondition, metadata_flags _metadata, size_t _maxitems = 2,
                                                            bool _restart = true, path _glob = path(), enumerate_req::filter _filtering = enumerate_req::filter::fastdeleted)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[metadata_flags] [] [_metadata] [The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. ]]
[[size_t] [] [_maxitems] [The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. ]]
[[bool] [] [_restart] [Restarts the enumeration for this open directory handle. ]]
[[path] [] [_glob] [An optional shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. ]]
[[enumerate_req::filter] [] [_filtering] [Any filtering you want AFIO to do for you.]]
]


[heading Returns]
A vector of results and a bool indicating if there is more. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that
many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so
comparing inodes for equivalence to a direntry() won't help you.]
[raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated,
birthtim, sparse, compressed.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][enumerate_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:enumerate_7_metadata_first_non_throwing enumerate (metadata first non throwing)]
'''<?dbhtml-include href="disqus_identifiers/enumerate_7_metadata_first_non_throwing.html"?>'''

'''<indexterm><primary>enumerate</primary></indexterm>'''
Synchronous directory enumeration after a preceding operation. 

[heading Description]
By default dir() returns shared handles i.e. dir( foo) and dir( foo) will return the exact same handle, and therefore enumerating not all of the entries at once is a race condition. The solution is to either set maxitems to a value large enough to guarantee a directory will be enumerated in a single shot, or to open a separate directory handle using the file\u005fflags::unique\u005fdirectory\u005fhandle flag. Note that setting maxitems=1 will often cause a buffer space exhaustion, causing a second syscall with an enlarged buffer. This is because AFIO cannot know if the allocated buffer can hold all of the filename being retrieved, so it may have to retry. Put another way, setting maxitems=1 will give you the worst performance possible, whereas maxitems=2 will probably only return one item most of the time. Related types: [^`__afio_enumerate_req__`], [^`__afio_directory_entry__`], [^`__afio_stat_t__`]

[heading Synopsis]
``std::pair<std::vector<directory_entry>, bool> enumerate(error_code & _ec, future<> _precondition, metadata_flags _metadata,
                                                            size_t _maxitems = 2, bool _restart = true, path _glob = path(),
                                                            enumerate_req::filter _filtering = enumerate_req::filter::fastdeleted)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[error_code &] [] [_ec] [Error code to set. ]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[metadata_flags] [] [_metadata] [The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. ]]
[[size_t] [] [_maxitems] [The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. ]]
[[bool] [] [_restart] [Restarts the enumeration for this open directory handle. ]]
[[path] [] [_glob] [An optional shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. ]]
[[enumerate_req::filter] [] [_filtering] [Any filtering you want AFIO to do for you.]]
]


[heading Returns]
A vector of results and a bool indicating if there is more. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that
many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so
comparing inodes for equivalence to a direntry() won't help you.]
[raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated,
birthtim, sparse, compressed.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][enumerate_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

