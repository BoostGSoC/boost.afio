[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml\group__write.xml]
[section:write_1_batch write (batch)]
'''<?dbhtml-include href="disqus_identifiers/write_1_batch.html"?>'''

'''<indexterm><primary>write</primary></indexterm>'''
Schedule a batch of asynchronous data writes after preceding operations, where offset and total data written must not exceed the present file size. 

[heading Description]
Related types: [^`__afio_io_req__`] Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
virtual std::vector<future<> > dispatcher::write(const std::vector< io_req< const T >> & ops)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[const std::vector< io_req< const T >> &] [] [ops] [A batch of io_req<const T> structures.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if writing data is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_write_3_length_deducing async_write (length deducing)]
'''<?dbhtml-include href="disqus_identifiers/async_write_3_length_deducing.html"?>'''

'''<indexterm><primary>async_write</primary></indexterm>'''
Asynchronous data write after a preceding operation, where offset and total data written must not exceed the present file size. 

[heading Description]
Related types: [^`__afio_io_req__`] Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
future async_write(future<> _precondition, T && v, off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Returns]
A future<void>

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if writing data is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_write_4_length_specifying async_write (length specifying)]
'''<?dbhtml-include href="disqus_identifiers/async_write_4_length_specifying.html"?>'''

'''<indexterm><primary>async_write</primary></indexterm>'''
Asynchronous data write after a preceding operation, where offset and total data written must not exceed the present file size. 

[heading Description]
Related types: [^`__afio_io_req__`] Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
future async_write(future<> _precondition, T && v, size_t _length,
                   off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[size_t] [] [_length] [The length of the item ]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Returns]
A future<void>

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if writing data is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:write_3_length_deducing_throwing write (length deducing throwing)]
'''<?dbhtml-include href="disqus_identifiers/write_3_length_deducing_throwing.html"?>'''

'''<indexterm><primary>write</primary></indexterm>'''
Synchronous data write after a preceding operation, where offset and total data written must not exceed the present file size. 

[heading Description]
Related types: [^`__afio_io_req__`] Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
void write(future<> _precondition, T && v, off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if writing data is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:write_4_length_specifying_throwing write (length specifying throwing)]
'''<?dbhtml-include href="disqus_identifiers/write_4_length_specifying_throwing.html"?>'''

'''<indexterm><primary>write</primary></indexterm>'''
Synchronous data write after a preceding operation, where offset and total data written must not exceed the present file size. 

[heading Description]
Related types: [^`__afio_io_req__`] Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
void write(future<> _precondition, T && v, size_t _length,
           off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[size_t] [] [_length] [The length of the item ]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if writing data is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:write_4_length_deducing_non_throwing write (length deducing non throwing)]
'''<?dbhtml-include href="disqus_identifiers/write_4_length_deducing_non_throwing.html"?>'''

'''<indexterm><primary>write</primary></indexterm>'''
Synchronous data write after a preceding operation, where offset and total data written must not exceed the present file size. 

[heading Description]
Related types: [^`__afio_io_req__`] Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
void write(error_code & _ec, future<> _precondition, T && v,
           off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[error_code &] [] [_ec] [Error code to set. ]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if writing data is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:write_5_length_specifying_non_throwing write (length specifying non throwing)]
'''<?dbhtml-include href="disqus_identifiers/write_5_length_specifying_non_throwing.html"?>'''

'''<indexterm><primary>write</primary></indexterm>'''
Synchronous data write after a preceding operation, where offset and total data written must not exceed the present file size. 

[heading Description]
Related types: [^`__afio_io_req__`] Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
void write(error_code & _ec, future<> _precondition, T && v,
           size_t _length, off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[error_code &] [] [_ec] [Error code to set. ]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[size_t] [] [_length] [The length of the item ]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if writing data is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

