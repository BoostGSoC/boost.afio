[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml\group__rmfile.xml]
[section:rmfile_1_batch rmfile (batch)]
'''<?dbhtml-include href="disqus_identifiers/rmfile_1_batch.html"?>'''

'''<indexterm><primary>rmfile</primary></indexterm>'''
Schedule a batch of asynchronous file deletions after optional preconditions. 

[heading Description]
Note that you can delete files before they are closed on Windows just as with POSIX if and only if all open handles to that file were opened with permission for the file to be deleted (AFIO always sets this). The actual file data will be deleted when the last handle is closed on the system. Make sure you read the docs for [^`__afio_handle__::unlink()`] for important caveats. Note that on operating systems with an unstable [^`__afio_handle__::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``future dispatcher::rmfile(const std::vector< path_req > & reqs)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const std::vector< path_req > &] [] [reqs] [A batch of [^`path_req`] structures.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if file deletion is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_rmfile_3_relative async_rmfile (relative)]
'''<?dbhtml-include href="disqus_identifiers/async_rmfile_3_relative.html"?>'''

'''<indexterm><primary>async_rmfile</primary></indexterm>'''
Asynchronous file deletion after an optional precondition. 

[heading Description]
Note that you can delete files before they are closed on Windows just as with POSIX if and only if all open handles to that file were opened with permission for the file to be deleted (AFIO always sets this). The actual file data will be deleted when the last handle is closed on the system. Make sure you read the docs for [^`__afio_handle__::unlink()`] for important caveats. Note that on operating systems with an unstable [^`__afio_handle__::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
future async_rmfile(future<> _precondition, T _path = path(), file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Returns]
A future<void>

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if file deletion is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_rmfile_2_absolute async_rmfile (absolute)]
'''<?dbhtml-include href="disqus_identifiers/async_rmfile_2_absolute.html"?>'''

'''<indexterm><primary>async_rmfile</primary></indexterm>'''
Asynchronous file deletion after an optional precondition. 

[heading Description]
Note that you can delete files before they are closed on Windows just as with POSIX if and only if all open handles to that file were opened with permission for the file to be deleted (AFIO always sets this). The actual file data will be deleted when the last handle is closed on the system. Make sure you read the docs for [^`__afio_handle__::unlink()`] for important caveats. Note that on operating systems with an unstable [^`__afio_handle__::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T, typename>
future async_rmfile(T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[] [] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Returns]
A future<void>

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if file deletion is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:rmfile_3_relative_throwing rmfile (relative throwing)]
'''<?dbhtml-include href="disqus_identifiers/rmfile_3_relative_throwing.html"?>'''

'''<indexterm><primary>rmfile</primary></indexterm>'''
Synchronous file deletion after an optional precondition. 

[heading Description]
Note that you can delete files before they are closed on Windows just as with POSIX if and only if all open handles to that file were opened with permission for the file to be deleted (AFIO always sets this). The actual file data will be deleted when the last handle is closed on the system. Make sure you read the docs for [^`__afio_handle__::unlink()`] for important caveats. Note that on operating systems with an unstable [^`__afio_handle__::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
void rmfile(future<> _precondition, T _path = path(), file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if file deletion is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:rmfile_2_absolute_throwing rmfile (absolute throwing)]
'''<?dbhtml-include href="disqus_identifiers/rmfile_2_absolute_throwing.html"?>'''

'''<indexterm><primary>rmfile</primary></indexterm>'''
Synchronous file deletion after an optional precondition. 

[heading Description]
Note that you can delete files before they are closed on Windows just as with POSIX if and only if all open handles to that file were opened with permission for the file to be deleted (AFIO always sets this). The actual file data will be deleted when the last handle is closed on the system. Make sure you read the docs for [^`__afio_handle__::unlink()`] for important caveats. Note that on operating systems with an unstable [^`__afio_handle__::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T, typename>
void rmfile(T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[] [] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if file deletion is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:rmfile_4_relative_non_throwing rmfile (relative non throwing)]
'''<?dbhtml-include href="disqus_identifiers/rmfile_4_relative_non_throwing.html"?>'''

'''<indexterm><primary>rmfile</primary></indexterm>'''
Synchronous file deletion after an optional precondition. 

[heading Description]
Note that you can delete files before they are closed on Windows just as with POSIX if and only if all open handles to that file were opened with permission for the file to be deleted (AFIO always sets this). The actual file data will be deleted when the last handle is closed on the system. Make sure you read the docs for [^`__afio_handle__::unlink()`] for important caveats. Note that on operating systems with an unstable [^`__afio_handle__::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
void rmfile(error_code & _ec, future<> _precondition, T _path = path(),
            file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[error_code &] [] [_ec] [Error code to set. ]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if file deletion is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:rmfile_3_absolute_non_throwing rmfile (absolute non throwing)]
'''<?dbhtml-include href="disqus_identifiers/rmfile_3_absolute_non_throwing.html"?>'''

'''<indexterm><primary>rmfile</primary></indexterm>'''
Synchronous file deletion after an optional precondition. 

[heading Description]
Note that you can delete files before they are closed on Windows just as with POSIX if and only if all open handles to that file were opened with permission for the file to be deleted (AFIO always sets this). The actual file data will be deleted when the last handle is closed on the system. Make sure you read the docs for [^`__afio_handle__::unlink()`] for important caveats. Note that on operating systems with an unstable [^`__afio_handle__::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T, typename>
void rmfile(error_code & _ec, T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[] [] [ - ] [Must be specified]]
[[error_code &] [] [_ec] [Error code to set. ]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if file deletion is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

