[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml\classboost_1_1afio_1_1future.xml]
[section:future future]
'''<?dbhtml-include href="disqus_identifiers/future.html"?>'''

'''<indexterm><primary>future</primary></indexterm>'''
The future status of a scheduled asynchronous operation. 

[heading Description]
Other than the fact that [^`get()`] returns a [^`T`] and [^`get_handle()`] returns a handle, the errored and excepted state for both is identical and non-consuming for both.

Finally, note that there is a freely available type slice from [^`future<T>`] to [^`future<void>`] which moves/copies only the [^`future<void>`] part of the [^`future<T>`], leaving the [^`T`] behind. This is because the AFIO engine resides behind a stable ABI layer which cannot know anything about arbitrary types, and therefore it accepts only [^`future<void>`]. Equally, this means you can supply a [^`future<T>`] as a precondition to another op safe in the knowledge that any [^`T`] part will remain untouched for later consumption. 

[heading Synopsis]
``template<class T, >
class future
{
  // ...
};
``

[heading Template parameter(s)]
[table
[[Parameter] [Default] [Description]]
[[class T] [void] []]
[[] [] [Any returned result. Note this is defaulted to [^`void`] for you, so usually you write [^`future<>`]. As of v1.4 of the AFIO engine, the legacy [^`async_io_op`] struct has been replaced with this custom future type based on the lightweight future-promise factory toolkit in forthcoming Boost.Monad. This custom future type consists of two pieces of future data each with different semantics:A [^`handle_ptr`] retrieved using [^`get_handle()`], [^`operator*`] and [^`operator->`] - this is the shared i/o handle returned by the asynchronous operation. This has non-consuming semantics i.e. you can call [^`get_handle()`] as many times as you like. Note that for legacy compatibility reasons, calling [^`get_handle()`] on an invalid instance returns a null shared pointer instead of an exception throw.If T is non-void, any type [^`T`] - this is any additional data returned by an asynchronous operation above and beyond the i/o handle (e.g. [^`enumerate()`] returns a [^`std::pair<std::vector<``directory_entry``>, bool>`]. This has ['consuming] semantics, so calling [^`get()`] returns the result exactly once.]]
]

[heading Constructor(s)]
[table
[[Function] [Description] [Parameters] ]
[[``future()``

] [] [

]]
[[``future(dispatcher * parent, size_t id, shared_future< handle_ptr > handle,
        stl_future< T > result, bool check_handle = true, bool validate = true)``

] [] [[* dispatcher *]: ['parent]:  The dispatcher this op belongs to. 

[* size_t]: ['id]:  The unique non-zero id of this op. 

[* shared_future< handle_ptr >]: ['handle]:  A shared_future to shared state between all instances of this reference. 

[* stl_future< T >]: ['result]:  A future to any result from the operation. 

[* bool]: ['check_handle]:  Whether to have validation additionally check if a handle is not null 

[* bool]: ['validate]:  Whether to check the inputs and shared state for valid (and not errored) values 



]]
[[``future(future< void > && o, stl_future< T > && result)``

] [] [[* future< void > &&]: ['o]:  The future<void>

[* stl_future< T > &&]: ['result]:  The future<T> to add 



]]
]

[heading Member Function(s)]
[table
[[Function] [Description] [Parameters]  [Returns]]
[[``bool valid(bool just_handle = false)``

] [True if this future is valid. ] [[* bool]: ['just_handle]:  



][

]
]
[[``T get()``

] [Waits for the future to become ready, returning any value or rethrowing any exception found. Throws a [^`future_errc::no_state`] if this future is invalid. ] [

][

]
]
[[``template<class U>
auto then(U && f)``

] [Schedules a callable to be invoked after this future becomes ready. If this future is null, use the current async file i/o dispatcher. ] [[* U &&]: ['f]:  



][

]
]
]

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

