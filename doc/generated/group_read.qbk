[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml\group__read.xml]
[section:read_1_batch read (batch)]
'''<?dbhtml-include href="disqus_identifiers/read_1_batch.html"?>'''

'''<indexterm><primary>read</primary></indexterm>'''
Schedule a batch of asynchronous data reads after preceding operations, where offset and total data read must not exceed the present file size. 

[heading Description]
Related types: [^`__afio_io_req__`] Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
virtual std::vector<future<> > dispatcher::read(const std::vector< io_req< T >> & ops)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[const std::vector< io_req< T >> &] [] [ops] [A batch of io_req<T> structures.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if reading data is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_read_3_length_deducing async_read (length deducing)]
'''<?dbhtml-include href="disqus_identifiers/async_read_3_length_deducing.html"?>'''

'''<indexterm><primary>async_read</primary></indexterm>'''
Asynchronous data read after a preceding operation, where offset and total data read must not exceed the present file size. 

[heading Description]
Related types: [^`__afio_io_req__`] Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
future async_read(future<> _precondition, T && v, off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Returns]
A future<void>

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_read_4_length_specifying async_read (length specifying)]
'''<?dbhtml-include href="disqus_identifiers/async_read_4_length_specifying.html"?>'''

'''<indexterm><primary>async_read</primary></indexterm>'''
Asynchronous data read after a preceding operation, where offset and total data read must not exceed the present file size. 

[heading Description]
Related types: [^`__afio_io_req__`] Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
future async_read(future<> _precondition, T && v, size_t _length,
                  off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[size_t] [] [_length] [The length of the item ]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Returns]
A future<void>

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:read_3_length_deducing_throwing read (length deducing throwing)]
'''<?dbhtml-include href="disqus_identifiers/read_3_length_deducing_throwing.html"?>'''

'''<indexterm><primary>read</primary></indexterm>'''
Synchronous data read after a preceding operation, where offset and total data read must not exceed the present file size. 

[heading Description]
Related types: [^`__afio_io_req__`] Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
void read(future<> _precondition, T && v, off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:read_4_length_specifying_throwing read (length specifying throwing)]
'''<?dbhtml-include href="disqus_identifiers/read_4_length_specifying_throwing.html"?>'''

'''<indexterm><primary>read</primary></indexterm>'''
Synchronous data read after a preceding operation, where offset and total data read must not exceed the present file size. 

[heading Description]
Related types: [^`__afio_io_req__`] Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
void read(future<> _precondition, T && v, size_t _length,
          off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[size_t] [] [_length] [The length of the item ]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:read_4_length_deducing_non_throwing read (length deducing non throwing)]
'''<?dbhtml-include href="disqus_identifiers/read_4_length_deducing_non_throwing.html"?>'''

'''<indexterm><primary>read</primary></indexterm>'''
Synchronous data read after a preceding operation, where offset and total data read must not exceed the present file size. 

[heading Description]
Related types: [^`__afio_io_req__`] Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
void read(error_code & _ec, future<> _precondition, T && v,
          off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[error_code &] [] [_ec] [Error code to set. ]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:read_5_length_specifying_non_throwing read (length specifying non throwing)]
'''<?dbhtml-include href="disqus_identifiers/read_5_length_specifying_non_throwing.html"?>'''

'''<indexterm><primary>read</primary></indexterm>'''
Synchronous data read after a preceding operation, where offset and total data read must not exceed the present file size. 

[heading Description]
Related types: [^`__afio_io_req__`] Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
void read(error_code & _ec, future<> _precondition, T && v,
          size_t _length, off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[error_code &] [] [_ec] [Error code to set. ]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[size_t] [] [_length] [The length of the item ]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

