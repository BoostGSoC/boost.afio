[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml\group__async__filedirops.xml]
[section:async_adopt async_adopt (single)]
'''<?dbhtml-include href="disqus_identifiers/async_adopt.html"?>'''

'''<indexterm><primary>async_adopt</primary></indexterm>'''
Returns a callable which when called with a future<> schedules a third party handle adoption. 

[heading Description]
This function enables you to adopt third party custom async\u005fio\u005fhandle derivatives as ops into the scheduler. Think of it as if you were calling file(), except the op returns the supplied handle and otherwise does nothing.

[heading Synopsis]
``detail::async_adopt async_adopt(std::shared_ptr< async_io_handle > h)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[std::shared_ptr< async_io_handle >] [] [h] [A handle to adopt.]]
]


[heading Returns]
A callable with the specification future<T>(future<>) 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if directory creation is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][adopt_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_dir async_dir (single)]
'''<?dbhtml-include href="disqus_identifiers/async_dir.html"?>'''

'''<indexterm><primary>async_dir</primary></indexterm>'''
Returns a callable which when called with a future<> schedules a directory creation and open after an optional precondition. 

[heading Description]
Note that if there is already a handle open to the directory requested, that will be returned instead of a new handle unless file\u005fflags::unique\u005fdirectory\u005fhandle is specified. For such handles where available\u005fto\u005fdirectory\u005fcache() is true, they cannot be explicitly closed either, you must let the reference count reach zero for that to happen.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
detail::async_dir<T> async_dir(T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Returns]
A callable with the specification future<T>(future<>) 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..Race free up to the containing directory.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if directory creation is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_rmdir async_rmdir (single)]
'''<?dbhtml-include href="disqus_identifiers/async_rmdir.html"?>'''

'''<indexterm><primary>async_rmdir</primary></indexterm>'''
Returns a callable which when called with a future<> schedules an asynchronous directory deletion after an optional precondition. 

[heading Description]
Make sure you read the docs for [^`async_io_handle::unlink()`] for important caveats.

Note that on operating systems with an unstable [^`async_io_handle::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
detail::async_rmdir<T> async_rmdir(T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to use. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Returns]
A callable with the specification future<T>(future<>) 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if directory deletion is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_file async_file (single)]
'''<?dbhtml-include href="disqus_identifiers/async_file.html"?>'''

'''<indexterm><primary>async_file</primary></indexterm>'''
Returns a callable which when called with a future<> schedules an asynchronous file creation and open after an optional precondition. 

[heading Description]
Be aware that any files created are by default sparse if supported on the local filing system. On Windows opening any file for writing converts it to sparse. Use file\u005fflags::no\u005fsparse to prevent this on those filing systems which permit it.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
detail::async_file<T> async_file(T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to use. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Returns]
A callable with the specification future<T>(future<>) 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, Windows..Race free up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if file creation is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_rmfile async_rmfile (single)]
'''<?dbhtml-include href="disqus_identifiers/async_rmfile.html"?>'''

'''<indexterm><primary>async_rmfile</primary></indexterm>'''
Returns a callable which when called with a future<> schedules an asynchronous file deletion after an optional precondition. 

[heading Description]
Note that you can delete files before they are closed on Windows just as with POSIX if and only if all open handles to that file were opened with permission for the file to be deleted (AFIO always sets this). The actual file data will be deleted when the last handle is closed on the system.

Make sure you read the docs for [^`async_io_handle::unlink()`] for important caveats.

Note that on operating systems with an unstable [^`async_io_handle::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
detail::async_rmfile<T> async_rmfile(T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Returns]
A callable with the specification future<T>(future<>) 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if file deletion is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_symlink async_symlink (single)]
'''<?dbhtml-include href="disqus_identifiers/async_symlink.html"?>'''

'''<indexterm><primary>async_symlink</primary></indexterm>'''
Returns a callable which when called with a future<> schedules an asynchronous symlink creation and open after a precondition. 

[heading Description]
Note that if creating, the target for the symlink is the precondition. On Windows directories are symlinked using a reparse point instead of a symlink due to the default lack of the [^`SeCreateSymbolicLinkPrivilege`] for non-Administrative users. On Windows you can open symlinks as a file and so a valid handle is output, whereas on POSIX except for Linux you cannot do this and an invalid handle is output.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
detail::async_symlink<T> async_symlink(T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to use. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Returns]
A callable with the specification future<T>(future<>) 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, Windows..Link creation is race free up to the containing directory. Destination is unavoidably racy.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink creation is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_rmsymlink async_rmsymlink (single)]
'''<?dbhtml-include href="disqus_identifiers/async_rmsymlink.html"?>'''

'''<indexterm><primary>async_rmsymlink</primary></indexterm>'''
Returns a callable which when called with a future<> schedules an asynchronous symlink deletion after an optional precondition. 

[heading Description]
Make sure you read the docs for [^`async_io_handle::unlink()`] for important caveats.

Note that on operating systems with an unstable [^`async_io_handle::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
detail::async_rmsymlink<T> async_rmsymlink(T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Returns]
A callable with the specification future<T>(future<>) 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink deletion is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_sync async_sync (single)]
'''<?dbhtml-include href="disqus_identifiers/async_sync.html"?>'''

'''<indexterm><primary>async_sync</primary></indexterm>'''
Returns a callable which when called with a future<> schedules an asynchronous content synchronisation with physical storage after a preceding operation. 

[heading Synopsis]
``detail::async_sync async_sync()``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
]


[heading Returns]
A callable with the specification future<T>(future<>)

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if content synchronisation is constant time (which is extremely unlikely).
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_close async_close (single)]
'''<?dbhtml-include href="disqus_identifiers/async_close.html"?>'''

'''<indexterm><primary>async_close</primary></indexterm>'''
Returns a callable which when called with a future<> schedules an asynchronous file or directory handle close after a preceding operation. 

[heading Description]
Note this is ignored for handles where available\u005fto\u005fdirectory\u005fcache() is true as those cannot be explicitly closed.

Note that failure to explicitly schedule closing a file handle using this call means it will be [*synchronously] closed on last reference count by async\u005fio\u005fhandle. This can consume considerable time, especially if SyncOnClose is enabled.

[heading Synopsis]
``detail::async_close async_close()``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
]


[heading Returns]
A callable with the specification future<T>(future<>)

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if closing handles is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_read_2_single async_read (single)]
'''<?dbhtml-include href="disqus_identifiers/async_read_2_single.html"?>'''

'''<indexterm><primary>async_read</primary></indexterm>'''
Returns a callable which when called with a future<> schedules an asynchronous data read after a preceding operation, where offset and total data read must not exceed the present file size. 

[heading Description]
Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
detail::async_read async_read(T && v, off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Returns]
A callable with the specification future<T>(future<>) 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_read_3_single async_read (single)]
'''<?dbhtml-include href="disqus_identifiers/async_read_3_single.html"?>'''

'''<indexterm><primary>async_read</primary></indexterm>'''
Returns a callable which when called with a future<> schedules an asynchronous data read after a preceding operation, where offset and total data read must not exceed the present file size. 

[heading Description]
Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
detail::async_read async_read(T && v, size_t _length, off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[size_t] [] [_length] [The length of the item ]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Returns]
A callable with the specification future<T>(future<>) 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_write_2_single async_write (single)]
'''<?dbhtml-include href="disqus_identifiers/async_write_2_single.html"?>'''

'''<indexterm><primary>async_write</primary></indexterm>'''
Returns a callable which when called with a future<> schedules an asynchronous data write after a preceding operation, where offset and total data written must not exceed the present file size. 

[heading Description]
Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
detail::async_write async_write(T && v, off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Returns]
A callable with the specification future<T>(future<>) 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if writing data is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_write_3_single async_write (single)]
'''<?dbhtml-include href="disqus_identifiers/async_write_3_single.html"?>'''

'''<indexterm><primary>async_write</primary></indexterm>'''
Returns a callable which when called with a future<> schedules an asynchronous data write after a preceding operation, where offset and total data written must not exceed the present file size. 

[heading Description]
Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
detail::async_write async_write(T && v, size_t _length, off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[size_t] [] [_length] [The length of the item ]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Returns]
A callable with the specification future<T>(future<>) 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if writing data is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_truncate async_truncate (single)]
'''<?dbhtml-include href="disqus_identifiers/async_truncate.html"?>'''

'''<indexterm><primary>async_truncate</primary></indexterm>'''
Returns a callable which when called with a future<> schedules an asynchronous file length truncation after a preceding operation. 

[heading Synopsis]
``detail::async_truncate async_truncate(off_t newsize)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[off_t] [] [newsize] [The new size for the file.]]
]


[heading Returns]
A callable with the specification future<T>(future<>) 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if truncating file lengths is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

