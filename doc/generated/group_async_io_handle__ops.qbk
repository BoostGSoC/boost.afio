[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml/group__async__io__handle____ops.xml]
[section:path path]

'''<indexterm><primary>path</primary></indexterm>'''
Returns the path of this i/o handle right now if ['refresh] is true, else last known good. May be null if the file has been deleted. 

[heading Description]
Note the refreshed path completely dereferences any symbolic links to return a truly absolute canonical path, and therefore may look quite different to before.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage. 

[heading Synopsis]
``virtual afio::path async_io_handle::path(bool refresh = false)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[bool] [] [refresh] [Whether to ask the OS for the current path of this handle. ]]
]


[heading Returns]
The path of this i/o handle right now. 

[heading Header]
`#include <boost/afio/afio.hpp>`


[endsect]

[section:target target]

'''<indexterm><primary>target</primary></indexterm>'''
Returns the target path of this handle if it is a symbolic link. 

[heading Description]
Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage. 

[heading Synopsis]
``virtual afio::path async_io_handle::target()``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
]


[heading Returns]
The path the symbolic link points to. May not exist or even be valid. 

[heading Header]
`#include <boost/afio/afio.hpp>`


[endsect]

[section:link link]

'''<indexterm><primary>link</primary></indexterm>'''
Hard links the file to a new location on the same volume. 

[heading Description]
If you wish to make a temporary file whose contents are ready appear at a location and error out if a file entry is already there, use link() and if success, unlink() on the former location. If you wish to always overwrite the destination, use atomic\u005frelink() instead.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage. 

[heading Synopsis]
``virtual void async_io_handle::link(const async_path_op_req & req)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const async_path_op_req &] [] [req] [The absolute or relative (in which case precondition specifies a directory) path to create a hard link at. ]]
]


[heading Header]
`#include <boost/afio/afio.hpp>`


[endsect]

[section:unlink unlink]

'''<indexterm><primary>unlink</primary></indexterm>'''
Unlinks the file from its present location. Other links may remain to the same file. 

[heading Description]
Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage. 

[heading Synopsis]
``virtual void async_io_handle::unlink()``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
]


[heading Header]
`#include <boost/afio/afio.hpp>`


[endsect]

[section:atomic_relink atomic_relink]

'''<indexterm><primary>atomic_relink</primary></indexterm>'''
Links the file to a new location and unlinks the file from its present location, ['atomically overwriting any file entry at the new location]. Very useful for preparing file content elsewhere and once ready, atomically making it visible at some named location to other processes. 

[heading Description]
Note that not all filing systems guarantee the atomicity of the relink itself (i.e. the file may appear at two locations in the filing system for a period of time), though all supported platforms do guarantee the atomicity of the replaced location i.e. the location you are relinking to will always refer to some valid file to all readers, and will never be deleted or missing. Some filing systems may also fail to do the unlink if power is lost close to the relinking operation.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage. 

[heading Synopsis]
``virtual void async_io_handle::atomic_relink(const async_path_op_req & req)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const async_path_op_req &] [] [req] [The absolute or relative (in which case precondition specifies a directory) path to relink to. ]]
]


[heading Header]
`#include <boost/afio/afio.hpp>`


[endsect]

