[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml\group__sync__filedirops.xml]
[section:dir_3_relative_throwing dir (relative throwing)]
'''<?dbhtml-include href="disqus_identifiers/dir_3_relative_throwing.html"?>'''

'''<indexterm><primary>dir</primary></indexterm>'''
Synchronous directory creation and open after an optional precondition. 

[heading Description]
Note that if there is already a handle open to the directory requested, that will be returned instead of a new handle unless file\u005fflags::unique\u005fdirectory\u005fhandle is specified. For such handles where available\u005fto\u005fdirectory\u005fcache() is true, they cannot be explicitly closed either, you must let the reference count reach zero for that to happen. Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> dir(future<> _precondition, T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T] [] [_path] [The filing system path to use. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Returns]
A handle to the directory. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..Race free up to the containing directory.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if directory creation is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:dir_2_absolute_throwing dir (absolute throwing)]
'''<?dbhtml-include href="disqus_identifiers/dir_2_absolute_throwing.html"?>'''

'''<indexterm><primary>dir</primary></indexterm>'''
Synchronous directory creation and open after an optional precondition. 

[heading Description]
Note that if there is already a handle open to the directory requested, that will be returned instead of a new handle unless file\u005fflags::unique\u005fdirectory\u005fhandle is specified. For such handles where available\u005fto\u005fdirectory\u005fcache() is true, they cannot be explicitly closed either, you must let the reference count reach zero for that to happen. Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> dir(T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to use. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Returns]
A handle to the directory. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if directory creation is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:dir_4_relative_non_throwing dir (relative non throwing)]
'''<?dbhtml-include href="disqus_identifiers/dir_4_relative_non_throwing.html"?>'''

'''<indexterm><primary>dir</primary></indexterm>'''
Synchronous directory creation and open after an optional precondition. 

[heading Description]
Note that if there is already a handle open to the directory requested, that will be returned instead of a new handle unless file\u005fflags::unique\u005fdirectory\u005fhandle is specified. For such handles where available\u005fto\u005fdirectory\u005fcache() is true, they cannot be explicitly closed either, you must let the reference count reach zero for that to happen. Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> dir(asio::error_code & _ec, future<> _precondition, T _path,
                                       file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[asio::error_code &] [] [_ec] [Error code to set. ]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T] [] [_path] [The filing system path to use. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Returns]
A handle to the directory. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..Race free up to the containing directory.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if directory creation is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:dir_3_absolute_non_throwing dir (absolute non throwing)]
'''<?dbhtml-include href="disqus_identifiers/dir_3_absolute_non_throwing.html"?>'''

'''<indexterm><primary>dir</primary></indexterm>'''
Synchronous directory creation and open after an optional precondition. 

[heading Description]
Note that if there is already a handle open to the directory requested, that will be returned instead of a new handle unless file\u005fflags::unique\u005fdirectory\u005fhandle is specified. For such handles where available\u005fto\u005fdirectory\u005fcache() is true, they cannot be explicitly closed either, you must let the reference count reach zero for that to happen. Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> dir(asio::error_code & _ec, T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[asio::error_code &] [] [_ec] [Error code to set. ]]
[[T] [] [_path] [The filing system path to use. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Returns]
A handle to the directory. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if directory creation is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:rmdir_3_single_relative rmdir (single relative)]
'''<?dbhtml-include href="disqus_identifiers/rmdir_3_single_relative.html"?>'''

'''<indexterm><primary>rmdir</primary></indexterm>'''
Synchronously do an asynchronous directory deletion after an optional precondition. 

[heading Description]
Make sure you read the docs for [^`async_io_handle::unlink()`] for important caveats.

Note that on operating systems with an unstable [^`async_io_handle::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> rmdir(future<> _precondition, T _path = path(), file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T] [] [_path] [The filing system path to use. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if directory deletion is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:rmdir_2_single_absolute rmdir (single absolute)]
'''<?dbhtml-include href="disqus_identifiers/rmdir_2_single_absolute.html"?>'''

'''<indexterm><primary>rmdir</primary></indexterm>'''
Synchronously do an asynchronous directory deletion after an optional precondition. 

[heading Description]
Make sure you read the docs for [^`async_io_handle::unlink()`] for important caveats.

Note that on operating systems with an unstable [^`async_io_handle::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> rmdir(T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to use. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if directory deletion is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:file_3_single_relative file (single relative)]
'''<?dbhtml-include href="disqus_identifiers/file_3_single_relative.html"?>'''

'''<indexterm><primary>file</primary></indexterm>'''
Synchronously issue a file creation and open after an optional precondition. 

[heading Description]
Be aware that any files created are by default sparse if supported on the local filing system. On Windows opening any file for writing converts it to sparse. Use file\u005fflags::no\u005fsparse to prevent this on those filing systems which permit it.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> file(future<> _precondition, T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T] [] [_path] [The filing system path to use. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, Windows..Race free up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if file creation is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:file_2_single_absolute file (single absolute)]
'''<?dbhtml-include href="disqus_identifiers/file_2_single_absolute.html"?>'''

'''<indexterm><primary>file</primary></indexterm>'''
Synchronously issue a file creation and open after an optional precondition. 

[heading Description]
Be aware that any files created are by default sparse if supported on the local filing system. On Windows opening any file for writing converts it to sparse. Use file\u005fflags::no\u005fsparse to prevent this on those filing systems which permit it.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> file(T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to use. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if file creation is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:rmfile_3_single_relative rmfile (single relative)]
'''<?dbhtml-include href="disqus_identifiers/rmfile_3_single_relative.html"?>'''

'''<indexterm><primary>rmfile</primary></indexterm>'''
Synchronously do a file deletion after an optional precondition. 

[heading Description]
Note that you can delete files before they are closed on Windows just as with POSIX if and only if all open handles to that file were opened with permission for the file to be deleted (AFIO always sets this). The actual file data will be deleted when the last handle is closed on the system.

Make sure you read the docs for [^`async_io_handle::unlink()`] for important caveats.

Note that on operating systems with an unstable [^`async_io_handle::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> rmfile(future<> _precondition, T _path = path(), file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if file deletion is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:rmfile_2_single_absolute rmfile (single absolute)]
'''<?dbhtml-include href="disqus_identifiers/rmfile_2_single_absolute.html"?>'''

'''<indexterm><primary>rmfile</primary></indexterm>'''
Synchronously do a file deletion after an optional precondition. 

[heading Description]
Note that you can delete files before they are closed on Windows just as with POSIX if and only if all open handles to that file were opened with permission for the file to be deleted (AFIO always sets this). The actual file data will be deleted when the last handle is closed on the system.

Make sure you read the docs for [^`async_io_handle::unlink()`] for important caveats.

Note that on operating systems with an unstable [^`async_io_handle::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> rmfile(T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if file deletion is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:symlink_3_single_relative symlink (single relative)]
'''<?dbhtml-include href="disqus_identifiers/symlink_3_single_relative.html"?>'''

'''<indexterm><primary>symlink</primary></indexterm>'''
Synchronously do a symlink creation and open after a precondition.. 

[heading Description]
Note that if creating, the target for the symlink is the precondition. On Windows directories are symlinked using a reparse point instead of a symlink due to the default lack of the [^`SeCreateSymbolicLinkPrivilege`] for non-Administrative users. On Windows you can open symlinks as a file and so a valid handle is output, whereas on POSIX except for Linux you cannot do this and an invalid handle is output.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> symlink(future<> _precondition, T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T] [] [_path] [The filing system path to use. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, Windows..Link creation is race free up to the containing directory. Destination is unavoidably racy.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink creation is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:symlink_2_single_absolute symlink (single absolute)]
'''<?dbhtml-include href="disqus_identifiers/symlink_2_single_absolute.html"?>'''

'''<indexterm><primary>symlink</primary></indexterm>'''
Synchronously do a symlink creation and open after a precondition. 

[heading Description]
Note that if creating, the target for the symlink is the precondition. On Windows directories are symlinked using a reparse point instead of a symlink due to the default lack of the [^`SeCreateSymbolicLinkPrivilege`] for non-Administrative users. On Windows you can open symlinks as a file and so a valid handle is output, whereas on POSIX except for Linux you cannot do this and an invalid handle is output.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> symlink(T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to use. ] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to use. ]]
[[file_flags] [] [_flags] [The flags to use.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink creation is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:rmsymlink_3_single_relative rmsymlink (single relative)]
'''<?dbhtml-include href="disqus_identifiers/rmsymlink_3_single_relative.html"?>'''

'''<indexterm><primary>rmsymlink</primary></indexterm>'''
Synchronously do a symlink deletion after an optional precondition. 

[heading Description]
Make sure you read the docs for [^`async_io_handle::unlink()`] for important caveats.

Note that on operating systems with an unstable [^`async_io_handle::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> rmsymlink(future<> _precondition, T _path = path(), file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink deletion is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:rmsymlink_2_single_absolute rmsymlink (single absolute)]
'''<?dbhtml-include href="disqus_identifiers/rmsymlink_2_single_absolute.html"?>'''

'''<indexterm><primary>rmsymlink</primary></indexterm>'''
Synchronously do a symlink deletion after an optional precondition. 

[heading Description]
Make sure you read the docs for [^`async_io_handle::unlink()`] for important caveats.

Note that on operating systems with an unstable [^`async_io_handle::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> rmsymlink(T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink deletion is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:sync sync (single)]
'''<?dbhtml-include href="disqus_identifiers/sync.html"?>'''

'''<indexterm><primary>sync</primary></indexterm>'''
Synchronously do a content synchronisation with physical storage after a preceding operation. 

[heading Synopsis]
``std::shared_ptr<async_io_handle> sync(future<> _precondition)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[future<>] [] [_precondition] [The precondition to use.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if content synchronisation is constant time (which is extremely unlikely).
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:close close (single)]
'''<?dbhtml-include href="disqus_identifiers/close.html"?>'''

'''<indexterm><primary>close</primary></indexterm>'''
Synchronously do a file or directory handle close after a preceding operation. 

[heading Description]
Note this is ignored for handles where available\u005fto\u005fdirectory\u005fcache() is true as those cannot be explicitly closed.

Note that failure to explicitly schedule closing a file handle using this call means it will be [*synchronously] closed on last reference count by async\u005fio\u005fhandle. This can consume considerable time, especially if SyncOnClose is enabled.

[heading Synopsis]
``std::shared_ptr<async_io_handle> close(future<> _precondition)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[future<>] [] [_precondition] [The precondition to use.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if closing handles is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:read_3_single read (single)]
'''<?dbhtml-include href="disqus_identifiers/read_3_single.html"?>'''

'''<indexterm><primary>read</primary></indexterm>'''
Synchronously do a data read after a preceding operation, where offset and total data read must not exceed the present file size. 

[heading Description]
Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> read(future<> _precondition, T && v, off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:read_4_single read (single)]
'''<?dbhtml-include href="disqus_identifiers/read_4_single.html"?>'''

'''<indexterm><primary>read</primary></indexterm>'''
Synchronously do a data read after a preceding operation, where offset and total data read must not exceed the present file size. 

[heading Description]
Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> read(future<> _precondition, T && v, size_t _length,
                                        off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[size_t] [] [_length] [The length of the item ]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:write_3_single write (single)]
'''<?dbhtml-include href="disqus_identifiers/write_3_single.html"?>'''

'''<indexterm><primary>write</primary></indexterm>'''
Synchronously do a data write after a preceding operation, where offset and total data written must not exceed the present file size. 

[heading Description]
Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> write(future<> _precondition, T && v, off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if writing data is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:write_4_single write (single)]
'''<?dbhtml-include href="disqus_identifiers/write_4_single.html"?>'''

'''<indexterm><primary>write</primary></indexterm>'''
Synchronously do a data write after a preceding operation, where offset and total data written must not exceed the present file size. 

[heading Description]
Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).

[heading Synopsis]
``template<class T>
std::shared_ptr<async_io_handle> write(future<> _precondition, T && v, size_t _length,
                                         off_t _where)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T &&] [] [v] [Some item understood by [^`to_asio_buffers()`]]]
[[size_t] [] [_length] [The length of the item ]]
[[off_t] [] [_where] [The file offset to do the i/o]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if writing data is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:truncate truncate (single)]
'''<?dbhtml-include href="disqus_identifiers/truncate.html"?>'''

'''<indexterm><primary>truncate</primary></indexterm>'''
Synchronously do a file length truncation after a preceding operation. 

[heading Synopsis]
``std::shared_ptr<async_io_handle> truncate(future<> _precondition, off_t newsize)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[off_t] [] [newsize] [The new size for the file.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if truncating file lengths is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

