[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml\group__async__file__io__dispatcher__base____filedirops.xml]
[section:adopt adopt (batch)]
'''<?dbhtml-include href="disqus_identifiers/adopt.html"?>'''

'''<indexterm><primary>adopt</primary></indexterm>'''
Schedule a batch of third party handle adoptions. 

[heading Description]
This function enables you to adopt third party custom async\u005fio\u005fhandle derivatives as ops into the scheduler. Think of it as if you were calling file(), except the op returns the supplied handle and otherwise does nothing.

[heading Synopsis]
``future async_file_io_dispatcher_base::adopt(const std::vector< std::shared_ptr< async_io_handle >> & hs)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const std::vector< std::shared_ptr< async_io_handle >> &] [] [hs] [A batch of handles to adopt.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][adopt_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:dir dir (batch)]
'''<?dbhtml-include href="disqus_identifiers/dir.html"?>'''

'''<indexterm><primary>dir</primary></indexterm>'''
Schedule a batch of asynchronous directory creations and opens after optional preconditions. 

[heading Description]
Note that if there is already a handle open to the directory requested, that will be returned instead of a new handle unless file\u005fflags::unique\u005fdirectory\u005fhandle is specified. For such handles where available\u005fto\u005fdirectory\u005fcache() is true, they cannot be explicitly closed either, you must let the reference count reach zero for that to happen. Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``future async_file_io_dispatcher_base::dir(const std::vector< async_path_op_req > & reqs)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const std::vector< async_path_op_req > &] [] [reqs] [A batch of [^`async_path_op_req`] structures.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, Windows..Race free up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if directory creation is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:rmdir rmdir (batch)]
'''<?dbhtml-include href="disqus_identifiers/rmdir.html"?>'''

'''<indexterm><primary>rmdir</primary></indexterm>'''
Schedule a batch of asynchronous directory deletions after optional preconditions. 

[heading Description]
Make sure you read the docs for [^`async_io_handle::unlink()`] for important caveats.

Note that on operating systems with an unstable [^`async_io_handle::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``future async_file_io_dispatcher_base::rmdir(const std::vector< async_path_op_req > & reqs)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const std::vector< async_path_op_req > &] [] [reqs] [A batch of [^`async_path_op_req`] structures.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if directory deletion is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:file file (batch)]
'''<?dbhtml-include href="disqus_identifiers/file.html"?>'''

'''<indexterm><primary>file</primary></indexterm>'''
Schedule a batch of asynchronous file creations and opens after optional preconditions. 

[heading Description]
Be aware that any files created are by default sparse if supported on the local filing system. On Windows opening any file for writing converts it to sparse. Use file\u005fflags::no\u005fsparse to prevent this on those filing systems which permit it.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``future async_file_io_dispatcher_base::file(const std::vector< async_path_op_req > & reqs)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const std::vector< async_path_op_req > &] [] [reqs] [A batch of [^`async_path_op_req`] structures.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, Windows..Race free up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if file creation is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:rmfile rmfile (batch)]
'''<?dbhtml-include href="disqus_identifiers/rmfile.html"?>'''

'''<indexterm><primary>rmfile</primary></indexterm>'''
Schedule a batch of asynchronous file deletions after optional preconditions. 

[heading Description]
Note that you can delete files before they are closed on Windows just as with POSIX if and only if all open handles to that file were opened with permission for the file to be deleted (AFIO always sets this). The actual file data will be deleted when the last handle is closed on the system.

Make sure you read the docs for [^`async_io_handle::unlink()`] for important caveats.

Note that on operating systems with an unstable [^`async_io_handle::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``future async_file_io_dispatcher_base::rmfile(const std::vector< async_path_op_req > & reqs)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const std::vector< async_path_op_req > &] [] [reqs] [A batch of [^`async_path_op_req`] structures.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if file deletion is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:symlink symlink (batch)]
'''<?dbhtml-include href="disqus_identifiers/symlink.html"?>'''

'''<indexterm><primary>symlink</primary></indexterm>'''
Schedule a batch of asynchronous symlink creations and opens after a precondition. 

[heading Description]
Note that if creating, the target for the symlink is the precondition. On Windows directories are symlinked using a reparse point instead of a symlink due to the default lack of the [^`SeCreateSymbolicLinkPrivilege`] for non-Administrative users. On Windows you can open symlinks as a file and so a valid handle is output, whereas on POSIX except for Linux you cannot do this and an invalid handle is output.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``future async_file_io_dispatcher_base::symlink(const std::vector< async_path_op_req > & reqs)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const std::vector< async_path_op_req > &] [] [reqs] [A batch of [^`async_path_op_req`] structures.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, Windows..Link creation is race free up to the containing directory. Destination is unavoidably racy.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if symlink creation is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:rmsymlink rmsymlink (batch)]
'''<?dbhtml-include href="disqus_identifiers/rmsymlink.html"?>'''

'''<indexterm><primary>rmsymlink</primary></indexterm>'''
Schedule a batch of asynchronous symlink deletions after optional preconditions. 

[heading Description]
Make sure you read the docs for [^`async_io_handle::unlink()`] for important caveats.

Note that on operating systems with an unstable [^`async_io_handle::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname.

[heading Synopsis]
``future async_file_io_dispatcher_base::rmsymlink(const std::vector< async_path_op_req > & reqs)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const std::vector< async_path_op_req > &] [] [reqs] [A batch of [^`async_path_op_req`] structures.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if symlink deletion is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:sync sync (batch)]
'''<?dbhtml-include href="disqus_identifiers/sync.html"?>'''

'''<indexterm><primary>sync</primary></indexterm>'''
Schedule a batch of asynchronous content synchronisations with physical storage after preceding operations. 

[heading Synopsis]
``future async_file_io_dispatcher_base::sync(const std::vector< future<>> & ops)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const std::vector< future<>> &] [] [ops] [A batch of op handles.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if content synchronisation is constant time (which is extremely unlikely).
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:close close (batch)]
'''<?dbhtml-include href="disqus_identifiers/close.html"?>'''

'''<indexterm><primary>close</primary></indexterm>'''
Schedule a batch of asynchronous file or directory handle closes after preceding operations. 

[heading Description]
Note this is ignored for handles where available\u005fto\u005fdirectory\u005fcache() is true as those cannot be explicitly closed.

Note that failure to explicitly schedule closing a file handle using this call means it will be [*synchronously] closed on last reference count by async\u005fio\u005fhandle. This can consume considerable time, especially if SyncOnClose is enabled.

[heading Synopsis]
``future async_file_io_dispatcher_base::close(const std::vector< future<>> & ops)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const std::vector< future<>> &] [] [ops] [A batch of op handles.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if closing handles is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:read read (batch)]
'''<?dbhtml-include href="disqus_identifiers/read.html"?>'''

'''<indexterm><primary>read</primary></indexterm>'''
Schedule a batch of asynchronous data reads after preceding operations, where offset and total data read must not exceed the present file size. 

[heading Description]
Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations). 

[heading Synopsis]
``template<class T>
virtual std::vector<future<> > async_file_io_dispatcher_base::read(const std::vector< async_data_op_req< T >> & ops)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[const std::vector< async_data_op_req< T >> &] [] [ops] [A batch of async_data_op_req<T> structures.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if reading data is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:write write (batch)]
'''<?dbhtml-include href="disqus_identifiers/write.html"?>'''

'''<indexterm><primary>write</primary></indexterm>'''
Schedule a batch of asynchronous data writes after preceding operations, where offset and total data written must not exceed the present file size. 

[heading Description]
Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations). 

[heading Synopsis]
``template<class T>
virtual std::vector<future<> > async_file_io_dispatcher_base::write(const std::vector< async_data_op_req< const T >> & ops)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [Any type. ] [ - ] [Must be specified]]
[[const std::vector< async_data_op_req< const T >> &] [] [ops] [A batch of async_data_op_req<const T> structures.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if writing data is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:truncate truncate (batch)]
'''<?dbhtml-include href="disqus_identifiers/truncate.html"?>'''

'''<indexterm><primary>truncate</primary></indexterm>'''
Schedule a batch of asynchronous file length truncations after preceding operations. 

[heading Synopsis]
``future async_file_io_dispatcher_base::truncate(const std::vector< future<>> & ops, const std::vector< off_t > & sizes)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const std::vector< future<>> &] [] [ops] [A batch of op handles. ]]
[[const std::vector< off_t > &] [] [sizes] [A batch of new lengths.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if truncating file lengths is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][readwrite_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

