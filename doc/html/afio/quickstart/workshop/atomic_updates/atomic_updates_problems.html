<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>The performance of and problems with this second generation design</title>
<link rel="stylesheet" href="../../../../../../libs/afio/doc/html/myboostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../../../../afio.html" title="Chapter&#160;1.&#160;Boost.AFIO 1.40">
<link rel="up" href="../atomic_updates.html" title="4. Second attempt at a key-value store: How to implement atomic value updates and therefore Atomicity, Consistency, Isolation and Durability">
<link rel="prev" href="../atomic_updates.html" title="4. Second attempt at a key-value store: How to implement atomic value updates and therefore Atomicity, Consistency, Isolation and Durability">
<link rel="next" href="../extents_theory.html" title="5. Third attempt at a key-value store: Thinking like a filing system">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../atomic_updates.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../atomic_updates.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../../afio.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../extents_theory.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="afio.quickstart.workshop.atomic_updates.atomic_updates_problems"></a><a class="link" href="atomic_updates_problems.html" title="The performance of and problems with this second generation design">The
          performance of and problems with this second generation design</a>
</h5></div></div></div>
<p>
            Let's see how this second generation ACI(D) design benchmarks compared
            to the first AFIO implementation where the dotted lines are the previous
            generation design:
          </p>
<p>
            <span class="aligncenter"><span class="inlinemediaobject"><img src="../../../../libs/afio/doc/src/images/a/b/../../../../../../../../../libs/afio/doc/src/images/workshop_atomic_updates_insertions.png"></span>
            <span class="inlinemediaobject"><img src="../../../../libs/afio/doc/src/images/a/b/../../../../../../../../../libs/afio/doc/src/images/workshop_atomic_updates_lookups.png"></span></span>
          </p>
<p>
            Lookups are actually not better &#8212; we are comparing the synchronous
            naive design to an asynchronous design, so the asynchronous design pulls
            ahead a bit on Microsoft Windows. Note, though, that the extra directory
            indirection costs you a noticeable amount of performance on ext4 &#8212;
            perhaps as much as 15% once you include the 10% bump from the asynchronous
            API.
          </p>
<p>
            Insertions are however diametrically slower: about four times slower
            on both NTFS and ext4. This is because atomic renames appear to not parallelise
            well &#8212; both filing systems are gating hard at about four parallel
            atomic renames (the number of cores on my test CPU), and if you throttle
            the parallelism by hand you'll find performance is really only half that
            of the first generation design which is logical as we are committing
            twice the new items to before. This is a good example of where Intel's
            Hyperthreading can really penalise overall performance sometimes: filing
            systems tend to parallelise linearly to real CPU core count only.
          </p>
<p>
            This second generation design is actually quite solid, and assuming that
            the design rationale is correct about the sequential consistency of journalling
            file systems then this key-value store design is likely production code
            useful, especially if you are storing large blobs which you might like
            to individually memory map. What you don't have though is the ability
            to update key-values as a transaction, and insertion performance is already
            heading downwards towards less than 1000 items/second which bodes poorly
            for adding transaction support.
          </p>
<p>
            Out of curiosity, how might we add transaction support to this design?
            One's first thought is a lock file of some sort, perhaps even a lock
            file for the entire store. AFIO v1.3 can push about 3000 exclusive lock
            files per second (see the mini-programs on atomicity following this section)
            so you might imagine holding a global lock file during reads and during
            a sequence of multiple atomic renames which make up committing a transaction.
          </p>
<p>
            Unfortunately, while that strategy would work well most of the time,
            it falls down spectacularly in the situation of power loss. The problem
            you have is that you have no way at all of forcing the order of key-value
            updates to reach physical storage. You might think that calling <code class="computeroutput"><span class="identifier">fsync</span><span class="special">()</span></code>
            or using <code class="computeroutput"><span class="identifier">O_SYNC</span></code> and then
            writing each item sequentially might work, but imagine if power is lost
            in the middle of that sequence: how do you know if the store you are
            now looking at was in the middle of a transaction, and if so what needs
            to be rolled back?
          </p>
<p>
            If you think this through, you realise that you need some form of write
            log from which an interrupted sequence of operations can be reconstituted
            and either completed or discarded to return a store to a consistent state.
            This write log is called a journal by journalling file systems, and is
            called various things by databases (<a href="https://www.sqlite.org/wal.html" target="_top">write
            ahead logging, rollback journal etc</a>). It has the special property
            that it is always moving forwards in time and what it records is the
            sequentially consistent history of the database.
          </p>
<p>
            You have probably guessed what the final part of this workshop tutorial
            does: and indeed it is implementing a transactional write log.
          </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013-2015 Niall Douglas
      and Paul Kirth<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../atomic_updates.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../atomic_updates.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../../afio.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../extents_theory.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
