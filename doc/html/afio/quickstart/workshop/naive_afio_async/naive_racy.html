<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>The problems with this naive design</title>
<link rel="stylesheet" href="../../../../../../libs/afio/doc/html/myboostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../../../../afio.html" title="Chapter&#160;1.&#160;Boost.AFIO 1.40">
<link rel="up" href="../naive_afio_async.html" title="3. World's simplest named blob store in AFIO (asynchronous)">
<link rel="prev" href="../naive_afio_async.html" title="3. World's simplest named blob store in AFIO (asynchronous)">
<link rel="next" href="../atomic_updates.html" title="4. Second attempt at a key-value store: How to implement atomic value updates and therefore Atomicity, Consistency, Isolation and Durability">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../naive_afio_async.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../naive_afio_async.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../../afio.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../atomic_updates.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="afio.quickstart.workshop.naive_afio_async.naive_racy"></a><a class="link" href="naive_racy.html" title="The problems with this naive design">The
          problems with this naive design</a>
</h5></div></div></div>
<p>
            You might be curious as to the performance of this naive key-value blob
            database. I was, so I performed the following benchmarks on Win8.1 NTFS
            and Linux ext4 both on SSD using the code above. Note that the test uses
            OpenMP to parallelise the operations, so the below shows AFIO in a worst
            case light as will be explained shortly:
          </p>
<p>
            <span class="aligncenter"><span class="inlinemediaobject"><img src="../../../../libs/afio/doc/src/images/a/b/../../../../../../../../../libs/afio/doc/src/images/workshop_naive_insertions.png"></span>
            <span class="inlinemediaobject"><img src="../../../../libs/afio/doc/src/images/a/b/../../../../../../../../../libs/afio/doc/src/images/workshop_naive_lookups.png"></span></span>
          </p>
<p>
            I don't know about you, but I was more than quite surprised at how good
            the performance is considering its naive simplicity. As a reference comparison,
            with durability disabled these NoSQL key-value databases achieve the
            following performance (<a href="http://www.datastax.com/wp-content/themes/datastax-2014-08/files/NoSQL_Benchmarks_EndPoint.pdf" target="_top">source</a>):
          </p>
<div class="table">
<a name="afio.quickstart.workshop.naive_afio_async.naive_racy.nosql"></a><p class="title"><b>Table&#160;1.5.&#160;Performance for various NoSQL databases with fsync disabled on
            Linux ext4:</b></p>
<div class="table-contents"><table class="table" summary="Performance for various NoSQL databases with fsync disabled on
            Linux ext4:">
<colgroup>
<col>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                  </th>
<th>
                    <p>
                      <span class="bold"><strong>Our naive design</strong></span>
                    </p>
                  </th>
<th>
                    <p>
                      Cassandra
                    </p>
                  </th>
<th>
                    <p>
                      Couchbase
                    </p>
                  </th>
<th>
                    <p>
                      HBase
                    </p>
                  </th>
<th>
                    <p>
                      MongoDB
                    </p>
                  </th>
</tr></thead>
<tbody>
<tr>
<td>
                    <p>
                      Insertion
                    </p>
                  </td>
<td>
                    <p>
                      <span class="bold"><strong>25,576</strong></span>
                    </p>
                  </td>
<td>
                    <p>
                      53,067
                    </p>
                  </td>
<td>
                    <p>
                      40,063
                    </p>
                  </td>
<td>
                    <p>
                      38,991
                    </p>
                  </td>
<td>
                    <p>
                      18,038
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      Lookup
                    </p>
                  </td>
<td>
                    <p>
                      <span class="bold"><strong>64,495</strong></span>
                    </p>
                  </td>
<td>
                    <p>
                      38,235
                    </p>
                  </td>
<td>
                    <p>
                      14,503
                    </p>
                  </td>
<td>
                    <p>
                      3,955
                    </p>
                  </td>
<td>
                    <p>
                      2,752
                    </p>
                  </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
            The naive results were calculated by excluding the highest value and
            averaging the next three highest values. Now this is not a fair comparison
            by any means &#8212; the NoSQL databases are running over a network
            stack (which particularly penalises read performance) whereas ours is
            direct to the OS API more or less, and our naive benchmark only writes
            10 bytes of value per item which is small enough to pack into the inode
            on both NTFS and ext4, so the extent allocator is never getting invoked.
            Still, one is used to thinking of the filesystem as incredibly slow and
            to be avoided with fancy database software &#8212; this simple test
            shows that <span class="emphasis"><em>recent</em></span> filesystems are competitive to
            fancy databases (and indeed even more so with a more sophisticated design
            than the one we used, as you will see later).
          </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              NTFS has such poor insertion performance because Microsoft Windows
              performs a sequentially consistent flush of the containing directory
              on file handle close, whereas Linux doesn't even flush the containing
              directory after you fsync a file and you must explicitly fsync the
              directory itself. You may find the <code class="computeroutput"><span class="identifier">afio</span><span class="special">::</span><span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">temporary_file</span></code>
              flag of use as this hints to Windows that the file is not important,
              and it may encourage Windows to not be so careful with sequentially
              flushing directory changes every single written file close.
            </p></td></tr>
</table></div>
<p>
            As is fairly obvious from the results, AFIO lags far behind iostreams
            at about one half to one third the performance. We are using AFIO's synchronous
            API for the most part, and that is simply a <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code> on the asynchronous API which introduces
            an unnecessary thread sleep (the fully asynchronous edition is about
            0-5% faster). Much more importantly, because no platform provides asynchronous
            file open nor close, AFIO emulates asynchronicity by executing the file
            opens and closes in a threadpool which is exactly what the iostreams
            does via OpenMP, however there isn't a copy of ASIO and AFIO and all
            the futures and completion handlers standing in between, so the iostreams
            implementation is far faster and will <span class="bold"><strong>always</strong></span>
            be faster than AFIO if you do a lot of file opens and closes which is
            pretty much this benchmark in a nutshell.
          </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              This peer review edition of AFIO v1.40 uses a mocked up v1.40 API based
              on the v1.3 series engine. Performance of this mockup will be considerably
              below the final v1.40 engine written using <a href="https://ned14.github.io/boost.outcome/group__future__promise.html" target="_top">Boost.Outcome</a>'s
              lightweight futures.
            </p></td></tr>
</table></div>
<p>
            A design which makes better use of AFIO is one which is asynchronous
            throughout and which avoids file opens and closes (<span class="emphasis"><em>tip:</em></span>
            always avoid file opens period if you want fast filesystem performance,
            they are always very slow due to the security checking of every single
            item in the path. File closes are also particularly slow on Microsoft
            Windows and Apple OS X).
          </p>
<p>
            Some might think that the flat store of all the keys in a single directory
            would scale poorly to item count. This certainly <span class="emphasis"><em>used</em></span>
            to be true for the previous generation of filing system, however modern
            filing systems usually have between <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="identifier">log</span> <span class="identifier">N</span><span class="special">)</span></code>
            to <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="number">1</span><span class="special">)</span></code> lookup
            complexity and between <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="identifier">N</span><span class="special">)</span></code> and <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="number">1</span><span class="special">)</span></code>
            insertion complexity &#8212; this author found excellent lookup performance
            with 10M items on ext4 and NTFS, though insertion performance was not
            great for NTFS (which does a directory flush each file close).
          </p>
<p>
            <span class="bold"><strong>Problem 1 with naive design:</strong></span> We are
            doing too many file opens and closes for really good performance.
          </p>
<p>
            <span class="bold"><strong>Problem 2 with naive design:</strong></span> <span class="emphasis"><em>Atomicity</em></span>:
            Writes do not atomically appear fully completed to other readers, so
            if one thread/process reads a value currently being written by another
            thread/process, they will see a partially written value which is a filesystem
            race.
          </p>
<p>
            <span class="bold"><strong>Problem 3 with naive design:</strong></span> <span class="emphasis"><em>Consistency</em></span>:
            If a writer process fatal exits during a write and therefore does not
            complete a write, the key value store is corrupted.
          </p>
<p>
            <span class="bold"><strong>Problem 4 with naive design:</strong></span> <span class="emphasis"><em>Isolation</em></span>:
            There is no concurrency ordering control apart from that provided by
            the operating system. AFIO exposes the strong guarantees made by operating
            systems as to the atomicity of read and write visibility to other readers
            and writers (see each API reference documentation page for the guarantees
            per API per platform), however the STL iostreams wrapper around AFIO
            ruins those guarantees (this is why AFIO does not provide iostreams wrappers).
          </p>
<p>
            <span class="bold"><strong>Problem 5 with naive design:</strong></span> <span class="emphasis"><em>Durability</em></span>:
            If power loss occurs during use of the key-value store, you are at the
            mercy of random chance as to what data in what order reached physical
            storage. On many filing systems you aren't even guaranteed that extent
            metadata matches contents, so your value may consist of portions of valid
            data intermixed with garbage.
          </p>
<p>
            <span class="bold"><strong>Problem 6 with naive design:</strong></span> Insertion
            and update complexity may be as poor as <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="identifier">N</span><span class="special">)</span></code> on some filesystems.
          </p>
<p>
            <span class="bold"><strong>Problem 7 with naive design:</strong></span> There is
            no way of atomically updating two or more key-value items in a transaction.
          </p>
<p>
            Luckily, AFIO exposes exactly the right features to make five of those
            seven problems go away with very few changes to the above code.
          </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013-2015 Niall Douglas
      and Paul Kirth<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../naive_afio_async.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../naive_afio_async.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../../afio.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../atomic_updates.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
