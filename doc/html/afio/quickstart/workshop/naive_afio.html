<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>2. World's simplest named blob store in AFIO (synchronous)</title>
<link rel="stylesheet" href="../../../../../libs/afio/doc/html/myboostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../../../afio.html" title="Chapter&#160;1.&#160;Boost.AFIO 1.40">
<link rel="up" href="../workshop.html" title="Step by step workshop building an AFIO-based key-value store">
<link rel="prev" href="naive.html" title="1. World's simplest named blob store in STL iostreams">
<link rel="next" href="naive_afio_async.html" title="3. World's simplest named blob store in AFIO (asynchronous)">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav"><form action="http://melpon.org/wandbox/permlink/nx1G8Xn7fyQdpKLz"><input type="submit" class="tryitnowbtn" value="Try AFIO now in online web compiler"/></form>

<a accesskey="p" href="naive.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../workshop.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../afio.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="naive_afio_async.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="afio.quickstart.workshop.naive_afio"></a><a class="link" href="naive_afio.html" title="2. World's simplest named blob store in AFIO (synchronous)">2. World's simplest
        named blob store in AFIO (synchronous)</a>
</h4></div></div></div>
<p>
          Let's see the same thing as in the last section, but written using AFIO.
          First, the interface is identical to before, just with different private
          member variables:
        </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">afio</span> <span class="special">=</span> <span class="identifier">BOOST_AFIO_V2_NAMESPACE</span><span class="special">;</span>
<span class="keyword">namespace</span> <span class="identifier">filesystem</span> <span class="special">=</span> <span class="identifier">BOOST_AFIO_V2_NAMESPACE</span><span class="special">::</span><span class="identifier">filesystem</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">BOOST_OUTCOME_V1_NAMESPACE</span><span class="special">::</span><span class="identifier">outcome</span><span class="special">;</span>

<span class="keyword">class</span> <span class="identifier">data_store</span>
<span class="special">{</span>
  <span class="identifier">afio</span><span class="special">::</span><span class="identifier">dispatcher_ptr</span> <span class="identifier">_dispatcher</span><span class="special">;</span>
  <span class="identifier">afio</span><span class="special">::</span><span class="identifier">handle_ptr</span> <span class="identifier">_store</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
  <span class="comment">// Type used for read streams</span>
  <span class="keyword">using</span> <span class="identifier">istream</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">istream</span><span class="special">&gt;;</span>
  <span class="comment">// Type used for write streams</span>
  <span class="keyword">using</span> <span class="identifier">ostream</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span><span class="special">&gt;;</span>
  <span class="comment">// Type used for lookup</span>
  <span class="keyword">using</span> <span class="identifier">lookup_result_type</span> <span class="special">=</span> <span class="identifier">outcome</span><span class="special">&lt;</span><span class="identifier">istream</span><span class="special">&gt;;</span>
  <span class="comment">// Type used for write</span>
  <span class="keyword">using</span> <span class="identifier">write_result_type</span> <span class="special">=</span> <span class="identifier">outcome</span><span class="special">&lt;</span><span class="identifier">ostream</span><span class="special">&gt;;</span>

  <span class="comment">// Disposition flags</span>
  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="identifier">size_t</span> <span class="identifier">writeable</span> <span class="special">=</span> <span class="special">(</span><span class="number">1</span><span class="special">&lt;&lt;</span><span class="number">0</span><span class="special">);</span>

  <span class="comment">// Open a data store at path</span>
  <span class="identifier">data_store</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="identifier">afio</span><span class="special">::</span><span class="identifier">path</span> <span class="identifier">path</span> <span class="special">=</span> <span class="string">"store"</span><span class="special">);</span>

  <span class="comment">// Look up item named name for reading, returning a std::istream for the item if it exists</span>
  <span class="identifier">outcome</span><span class="special">&lt;</span><span class="identifier">istream</span><span class="special">&gt;</span> <span class="identifier">lookup</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">name</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
  <span class="comment">// Look up item named name for writing, returning an ostream for that item</span>
  <span class="identifier">outcome</span><span class="special">&lt;</span><span class="identifier">ostream</span><span class="special">&gt;</span> <span class="identifier">write</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">name</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          We now have a <code class="computeroutput"><span class="identifier">dispatcher_ptr</span></code>
          and a <code class="computeroutput"><span class="identifier">handle_ptr</span></code> to the
          store directory which is created/opened during construction of <code class="computeroutput"><span class="identifier">data_store</span></code>. Instead of constructing to
          a filesystem path, we now construct to an AFIO path. Note that AFIO paths
          are always either absolute or relative to some open file handle, and therefore
          in this situation at the point of construction the current working directory
          will be fetched and an absolute path constructed. This differs from filesystem
          which passes through relative paths and lets the OS resolve from the current
          working directory &#8212; AFIO does it this way as the current working
          directory setting at some later point of asynchronous execution is inherently
          unpredictable. As the <code class="computeroutput"><span class="identifier">data_store</span></code>
          interface is identical, so is the use case from the previous page. The
          implementation is rather different however:
        </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">asio</span> <span class="special">=</span> <span class="identifier">BOOST_AFIO_V2_NAMESPACE</span><span class="special">::</span><span class="identifier">asio</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">BOOST_OUTCOME_V1_NAMESPACE</span><span class="special">::</span><span class="identifier">empty</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">BOOST_AFIO_V2_NAMESPACE</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">BOOST_AFIO_V2_NAMESPACE</span><span class="special">::</span><span class="identifier">generic_category</span><span class="special">;</span>

<span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_valid_name</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&amp;</span><span class="identifier">name</span><span class="special">)</span> <span class="keyword">noexcept</span>
<span class="special">{</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">banned</span><span class="special">(</span><span class="string">"&lt;&gt;:\"/\\|?*\0"</span><span class="special">,</span> <span class="number">10</span><span class="special">);</span>
  <span class="keyword">if</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">npos</span><span class="special">!=</span><span class="identifier">name</span><span class="special">.</span><span class="identifier">find_first_of</span><span class="special">(</span><span class="identifier">banned</span><span class="special">))</span>
    <span class="keyword">return</span> <span class="keyword">false</span><span class="special">;</span>
  <span class="comment">// No leading period</span>
  <span class="keyword">return</span> <span class="identifier">name</span><span class="special">[</span><span class="number">0</span><span class="special">]!=</span><span class="char">'.'</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">data_store</span><span class="special">::</span><span class="identifier">data_store</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">flags</span><span class="special">,</span> <span class="identifier">afio</span><span class="special">::</span><span class="identifier">path</span> <span class="identifier">path</span><span class="special">)</span>
<span class="special">{</span>
  <span class="comment">// Make a dispatcher for the local filesystem URI, masking out write flags on all operations if not writeable</span>
  <span class="identifier">_dispatcher</span><span class="special">=</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">make_dispatcher</span><span class="special">(</span><span class="string">"file:///"</span><span class="special">,</span> <span class="identifier">afio</span><span class="special">::</span><span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">none</span><span class="special">,</span> <span class="special">!(</span><span class="identifier">flags</span> <span class="special">&amp;</span> <span class="identifier">writeable</span><span class="special">)</span> <span class="special">?</span> <span class="identifier">afio</span><span class="special">::</span><span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">write</span> <span class="special">:</span> <span class="identifier">afio</span><span class="special">::</span><span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">none</span><span class="special">).</span><span class="identifier">get</span><span class="special">();</span>
  <span class="comment">// Set the dispatcher for this thread, and open a handle to the store directory</span>
  <span class="identifier">afio</span><span class="special">::</span><span class="identifier">current_dispatcher_guard</span> <span class="identifier">h</span><span class="special">(</span><span class="identifier">_dispatcher</span><span class="special">);</span>
  <span class="identifier">_store</span><span class="special">=</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">dir</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">path</span><span class="special">),</span> <span class="identifier">afio</span><span class="special">::</span><span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">create</span><span class="special">);</span>  <span class="comment">// throws if there was an error</span>
<span class="special">}</span>

<span class="identifier">outcome</span><span class="special">&lt;</span><span class="identifier">data_store</span><span class="special">::</span><span class="identifier">istream</span><span class="special">&gt;</span> <span class="identifier">data_store</span><span class="special">::</span><span class="identifier">lookup</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">name</span><span class="special">)</span> <span class="keyword">noexcept</span>
<span class="special">{</span>
  <span class="keyword">if</span><span class="special">(!</span><span class="identifier">is_valid_name</span><span class="special">(</span><span class="identifier">name</span><span class="special">))</span>
    <span class="keyword">return</span> <span class="identifier">error_code</span><span class="special">(</span><span class="identifier">EINVAL</span><span class="special">,</span> <span class="identifier">generic_category</span><span class="special">());</span>
  <span class="keyword">try</span>
  <span class="special">{</span>
    <span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">;</span>
    <span class="comment">// Open the file using the handle to the store directory as the base.</span>
    <span class="comment">// The store directory can be freely renamed by any third party process</span>
    <span class="comment">// and everything here will work perfectly.</span>
    <span class="identifier">afio</span><span class="special">::</span><span class="identifier">handle_ptr</span> <span class="identifier">h</span><span class="special">(</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">file</span><span class="special">(</span><span class="identifier">ec</span><span class="special">,</span> <span class="identifier">_store</span><span class="special">,</span> <span class="identifier">name</span><span class="special">,</span> <span class="identifier">afio</span><span class="special">::</span><span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">read</span><span class="special">));</span>
    <span class="keyword">if</span><span class="special">(</span><span class="identifier">ec</span><span class="special">)</span>
    <span class="special">{</span>
      <span class="comment">// If the file was not found, return empty else the error</span>
      <span class="keyword">if</span><span class="special">(</span><span class="identifier">ec</span><span class="special">==</span><span class="identifier">error_code</span><span class="special">(</span><span class="identifier">ENOENT</span><span class="special">,</span> <span class="identifier">generic_category</span><span class="special">()))</span>
        <span class="keyword">return</span> <span class="identifier">empty</span><span class="special">;</span>
      <span class="keyword">return</span> <span class="identifier">ec</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="comment">// Create an istream which directly uses the mapped file.</span>
    <span class="identifier">data_store</span><span class="special">::</span><span class="identifier">istream</span> <span class="identifier">ret</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span><span class="identifier">idirectstream</span><span class="special">&gt;(</span><span class="identifier">ec</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">h</span><span class="special">)));</span>
    <span class="keyword">if</span><span class="special">(</span><span class="identifier">ec</span><span class="special">)</span>
      <span class="keyword">return</span> <span class="identifier">ec</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">ret</span><span class="special">;</span>
  <span class="special">}</span>
  <span class="keyword">catch</span><span class="special">(...)</span>
  <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">current_exception</span><span class="special">();</span>
  <span class="special">}</span>
<span class="special">}</span>

<span class="identifier">outcome</span><span class="special">&lt;</span><span class="identifier">data_store</span><span class="special">::</span><span class="identifier">ostream</span><span class="special">&gt;</span> <span class="identifier">data_store</span><span class="special">::</span><span class="identifier">write</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">name</span><span class="special">)</span> <span class="keyword">noexcept</span>
<span class="special">{</span>
  <span class="keyword">if</span><span class="special">(!</span><span class="identifier">is_valid_name</span><span class="special">(</span><span class="identifier">name</span><span class="special">))</span>
    <span class="keyword">return</span> <span class="identifier">error_code</span><span class="special">(</span><span class="identifier">EINVAL</span><span class="special">,</span> <span class="identifier">generic_category</span><span class="special">());</span>
  <span class="keyword">try</span>
  <span class="special">{</span>
    <span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">;</span>
    <span class="comment">// Open the file using the handle to the store directory as the base.</span>
    <span class="comment">// The store directory can be freely renamed by any third party process</span>
    <span class="comment">// and everything here will work perfectly. You could enable direct</span>
    <span class="comment">// buffer writing - this sends 4Kb pages directly to the physical hardware</span>
    <span class="comment">// bypassing the kernel file page cache, however this is not optimal if reads of</span>
    <span class="comment">// the value are likely to occur soon.</span>
    <span class="identifier">afio</span><span class="special">::</span><span class="identifier">handle_ptr</span> <span class="identifier">h</span><span class="special">(</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">file</span><span class="special">(</span><span class="identifier">ec</span><span class="special">,</span> <span class="identifier">_store</span><span class="special">,</span> <span class="identifier">name</span><span class="special">,</span> <span class="identifier">afio</span><span class="special">::</span><span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">create</span> <span class="special">|</span> <span class="identifier">afio</span><span class="special">::</span><span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">write</span>
      <span class="comment">/*| afio::file_flags::os_direct*/</span><span class="special">));</span>
    <span class="keyword">if</span><span class="special">(</span><span class="identifier">ec</span><span class="special">)</span>
      <span class="keyword">return</span> <span class="identifier">ec</span><span class="special">;</span>
    <span class="comment">// Create an ostream which directly uses the mapped file.</span>
    <span class="keyword">return</span> <span class="identifier">outcome</span><span class="special">&lt;</span><span class="identifier">data_store</span><span class="special">::</span><span class="identifier">ostream</span><span class="special">&gt;(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span><span class="identifier">odirectstream</span><span class="special">&gt;(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">h</span><span class="special">)));</span>
  <span class="special">}</span>
  <span class="keyword">catch</span> <span class="special">(...)</span>
  <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">current_exception</span><span class="special">();</span>
  <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
          This is a good bit longer and looks more complex, however there is already
          a big if not obvious gain: third party processes can happily rename and
          move around the store directory once it has been opened and this implementation
          will work perfectly. This is because we open a handle to the store directory
          in the <code class="computeroutput"><span class="identifier">data_store</span></code> constructor,
          and thereafter use that open handle as a base location for all leaf path
          operations. Except on OS X which currently doesn't support the POSIX race
          free filesystem extensions, that makes all data store operations invariant
          to store path mutation on all supported platforms.
        </p>
<p>
          Another big gain is we are now using memory mapped files for the lookup
          which avoids any memory copying, and there is a hint we are also avoiding
          memory copies in the write too.
        </p>
<p>
          You will also note that in the constructor, we specify a URI to <code class="computeroutput"><span class="identifier">make_dispatcher</span><span class="special">()</span></code>.
          This lets you open different kinds of filesystem e.g. ZIP archives, HTTP
          sites etc. AFIO currently doesn't provide backends except for <code class="computeroutput"><span class="identifier">file</span><span class="special">:///</span></code>
          i.e. the local filesystem, however future versions will. Note that a dispatcher
          can force on or off <code class="computeroutput"><span class="identifier">file_flags</span></code>
          for all operations scheduled against that dispatcher &#8212; here we force
          mask out any attempt to open anything for writing if we are opening the
          store read-only.
        </p>
<p>
          Finally, you may wonder why we only use <code class="computeroutput"><span class="identifier">current_dispatcher_guard</span></code>
          once in the constructor. This is because if AFIO can deduce the dispatcher
          to use from any precondition you supply, you need not set the thread local
          dispatcher. As the opening of the store directory is done as an absolute
          path lookup and therefore takes no inputs specifying a dispatcher, you
          need to set the current dispatcher in that one situation alone.
        </p>
<p>
          The remaining magic is in the custom iostreams implementations <code class="computeroutput"><span class="identifier">idirectstream</span></code> and <code class="computeroutput"><span class="identifier">odirectstream</span></code>:
        </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">asio</span> <span class="special">=</span> <span class="identifier">BOOST_AFIO_V2_NAMESPACE</span><span class="special">::</span><span class="identifier">asio</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">BOOST_OUTCOME_V1_NAMESPACE</span><span class="special">::</span><span class="identifier">empty</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">BOOST_AFIO_V2_NAMESPACE</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">BOOST_AFIO_V2_NAMESPACE</span><span class="special">::</span><span class="identifier">generic_category</span><span class="special">;</span>

<span class="comment">// A special allocator of highly efficient file i/o memory</span>
<span class="keyword">using</span> <span class="identifier">file_buffer_type</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">,</span> <span class="identifier">afio</span><span class="special">::</span><span class="identifier">utils</span><span class="special">::</span><span class="identifier">page_allocator</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;&gt;;</span>

<span class="comment">// An iostream which reads directly from a memory mapped AFIO file</span>
<span class="keyword">struct</span> <span class="identifier">idirectstream</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">istream</span>
<span class="special">{</span>
  <span class="keyword">struct</span> <span class="identifier">directstreambuf</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">streambuf</span>
  <span class="special">{</span>
    <span class="identifier">afio</span><span class="special">::</span><span class="identifier">handle_ptr</span> <span class="identifier">h</span><span class="special">;</span>  <span class="comment">// Holds the file open and therefore mapped</span>
    <span class="identifier">file_buffer_type</span> <span class="identifier">buffer</span><span class="special">;</span>
    <span class="identifier">afio</span><span class="special">::</span><span class="identifier">handle</span><span class="special">::</span><span class="identifier">mapped_file_ptr</span> <span class="identifier">mfp</span><span class="special">;</span>
    <span class="identifier">directstreambuf</span><span class="special">(</span><span class="identifier">error_code</span> <span class="special">&amp;</span><span class="identifier">ec</span><span class="special">,</span> <span class="identifier">afio</span><span class="special">::</span><span class="identifier">handle_ptr</span> <span class="identifier">_h</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">h</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">_h</span><span class="special">))</span>
    <span class="special">{</span>
      <span class="comment">// Get the size of the file. If greater than 128Kb mmap it</span>
      <span class="identifier">size_t</span> <span class="identifier">length</span><span class="special">=(</span><span class="identifier">size_t</span><span class="special">)</span> <span class="identifier">h</span><span class="special">-&gt;</span><span class="identifier">lstat</span><span class="special">(</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">metadata_flags</span><span class="special">::</span><span class="identifier">size</span><span class="special">).</span><span class="identifier">st_size</span><span class="special">;</span>
      <span class="keyword">char</span> <span class="special">*</span><span class="identifier">p</span><span class="special">=</span><span class="keyword">nullptr</span><span class="special">;</span>
      <span class="keyword">if</span><span class="special">(</span><span class="identifier">length</span><span class="special">&gt;=</span><span class="number">128</span><span class="special">*</span><span class="number">1024</span><span class="special">)</span>
      <span class="special">{</span>
        <span class="keyword">if</span><span class="special">((</span><span class="identifier">mfp</span><span class="special">=</span><span class="identifier">h</span><span class="special">-&gt;</span><span class="identifier">map_file</span><span class="special">()))</span>
          <span class="identifier">p</span> <span class="special">=</span> <span class="special">(</span><span class="keyword">char</span> <span class="special">*)</span> <span class="identifier">mfp</span><span class="special">-&gt;</span><span class="identifier">addr</span><span class="special">;</span>
      <span class="special">}</span>
      <span class="keyword">if</span><span class="special">(!</span><span class="identifier">p</span><span class="special">)</span>
      <span class="special">{</span>
        <span class="identifier">buffer</span><span class="special">.</span><span class="identifier">resize</span><span class="special">(</span><span class="identifier">length</span><span class="special">);</span>
        <span class="identifier">afio</span><span class="special">::</span><span class="identifier">read</span><span class="special">(</span><span class="identifier">ec</span><span class="special">,</span> <span class="identifier">h</span><span class="special">,</span> <span class="identifier">buffer</span><span class="special">.</span><span class="identifier">data</span><span class="special">(),</span> <span class="identifier">length</span><span class="special">,</span> <span class="number">0</span><span class="special">);</span>
        <span class="identifier">p</span><span class="special">=</span><span class="identifier">buffer</span><span class="special">.</span><span class="identifier">data</span><span class="special">();</span>
      <span class="special">}</span>
      <span class="comment">// Set the get buffer this streambuf is to use</span>
      <span class="identifier">setg</span><span class="special">(</span><span class="identifier">p</span><span class="special">,</span> <span class="identifier">p</span><span class="special">,</span> <span class="identifier">p</span> <span class="special">+</span> <span class="identifier">length</span><span class="special">);</span>
    <span class="special">}</span>
  <span class="special">};</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">directstreambuf</span><span class="special">&gt;</span> <span class="identifier">buf</span><span class="special">;</span>
  <span class="identifier">idirectstream</span><span class="special">(</span><span class="identifier">error_code</span> <span class="special">&amp;</span><span class="identifier">ec</span><span class="special">,</span> <span class="identifier">afio</span><span class="special">::</span><span class="identifier">handle_ptr</span> <span class="identifier">h</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">istream</span><span class="special">(</span><span class="keyword">new</span> <span class="identifier">directstreambuf</span><span class="special">(</span><span class="identifier">ec</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">h</span><span class="special">))),</span> <span class="identifier">buf</span><span class="special">(</span><span class="keyword">static_cast</span><span class="special">&lt;</span><span class="identifier">directstreambuf</span> <span class="special">*&gt;(</span><span class="identifier">rdbuf</span><span class="special">()))</span>
  <span class="special">{</span>
  <span class="special">}</span>
  <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">idirectstream</span><span class="special">()</span> <span class="identifier">override</span>
  <span class="special">{</span>
    <span class="comment">// Reset the stream before deleting the buffer</span>
    <span class="identifier">rdbuf</span><span class="special">(</span><span class="keyword">nullptr</span><span class="special">);</span>
  <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// An iostream which writes to an AFIO file in 4Kb pages</span>
<span class="keyword">struct</span> <span class="identifier">odirectstream</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span>
<span class="special">{</span>
  <span class="keyword">struct</span> <span class="identifier">directstreambuf</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">streambuf</span>
  <span class="special">{</span>
    <span class="keyword">using</span> <span class="identifier">int_type</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">streambuf</span><span class="special">::</span><span class="identifier">int_type</span><span class="special">;</span>
    <span class="keyword">using</span> <span class="identifier">traits_type</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">streambuf</span><span class="special">::</span><span class="identifier">traits_type</span><span class="special">;</span>
    <span class="identifier">afio</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;&gt;</span> <span class="identifier">lastwrite</span><span class="special">;</span> <span class="comment">// the last async write performed</span>
    <span class="identifier">afio</span><span class="special">::</span><span class="identifier">off_t</span> <span class="identifier">offset</span><span class="special">;</span>       <span class="comment">// offset of next write</span>
    <span class="identifier">file_buffer_type</span> <span class="identifier">buffer</span><span class="special">;</span>  <span class="comment">// a page size on this machine</span>
    <span class="identifier">file_buffer_type</span> <span class="identifier">lastbuffer</span><span class="special">;</span>
    <span class="identifier">directstreambuf</span><span class="special">(</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">handle_ptr</span> <span class="identifier">_h</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">lastwrite</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">_h</span><span class="special">)),</span> <span class="identifier">offset</span><span class="special">(</span><span class="number">0</span><span class="special">),</span> <span class="identifier">buffer</span><span class="special">(</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">utils</span><span class="special">::</span><span class="identifier">page_sizes</span><span class="special">().</span><span class="identifier">front</span><span class="special">())</span>
    <span class="special">{</span>
      <span class="comment">// Set the put buffer this streambuf is to use</span>
      <span class="identifier">setp</span><span class="special">(</span><span class="identifier">buffer</span><span class="special">.</span><span class="identifier">data</span><span class="special">(),</span> <span class="identifier">buffer</span><span class="special">.</span><span class="identifier">data</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">buffer</span><span class="special">.</span><span class="identifier">size</span><span class="special">());</span>
    <span class="special">}</span>
    <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">directstreambuf</span><span class="special">()</span> <span class="identifier">override</span>
    <span class="special">{</span>
      <span class="keyword">try</span>
      <span class="special">{</span>
        <span class="comment">// Flush buffers and wait until last write completes</span>
        <span class="comment">// Schedule an asynchronous write of the buffer to storage</span>
        <span class="identifier">size_t</span> <span class="identifier">thisbuffer</span> <span class="special">=</span> <span class="identifier">pptr</span><span class="special">()</span> <span class="special">-</span> <span class="identifier">pbase</span><span class="special">();</span>
        <span class="keyword">if</span><span class="special">(</span><span class="identifier">thisbuffer</span><span class="special">)</span>
          <span class="identifier">lastwrite</span> <span class="special">=</span> <span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_write</span><span class="special">(</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_truncate</span><span class="special">(</span><span class="identifier">lastwrite</span><span class="special">,</span> <span class="identifier">offset</span><span class="special">+</span><span class="identifier">thisbuffer</span><span class="special">),</span> <span class="identifier">buffer</span><span class="special">.</span><span class="identifier">data</span><span class="special">(),</span> <span class="identifier">thisbuffer</span><span class="special">,</span> <span class="identifier">offset</span><span class="special">);</span>
        <span class="identifier">lastwrite</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
      <span class="special">}</span>
      <span class="keyword">catch</span><span class="special">(...)</span>
      <span class="special">{</span>
      <span class="special">}</span>
    <span class="special">}</span>
    <span class="keyword">virtual</span> <span class="identifier">int_type</span> <span class="identifier">overflow</span><span class="special">(</span><span class="identifier">int_type</span> <span class="identifier">c</span><span class="special">)</span> <span class="identifier">override</span>
    <span class="special">{</span>
      <span class="identifier">size_t</span> <span class="identifier">thisbuffer</span><span class="special">=</span><span class="identifier">pptr</span><span class="special">()-</span><span class="identifier">pbase</span><span class="special">();</span>
      <span class="keyword">if</span><span class="special">(</span><span class="identifier">thisbuffer</span><span class="special">&gt;=</span><span class="identifier">buffer</span><span class="special">.</span><span class="identifier">size</span><span class="special">())</span>
        <span class="identifier">sync</span><span class="special">();</span>
      <span class="keyword">if</span><span class="special">(</span><span class="identifier">c</span><span class="special">!=</span><span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">eof</span><span class="special">())</span>
      <span class="special">{</span>
        <span class="special">*</span><span class="identifier">pptr</span><span class="special">()=(</span><span class="keyword">char</span><span class="special">)</span><span class="identifier">c</span><span class="special">;</span>
        <span class="identifier">pbump</span><span class="special">(</span><span class="number">1</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">to_int_type</span><span class="special">(</span><span class="identifier">c</span><span class="special">);</span>
      <span class="special">}</span>
      <span class="keyword">return</span> <span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">eof</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="keyword">virtual</span> <span class="keyword">int</span> <span class="identifier">sync</span><span class="special">()</span> <span class="identifier">override</span>
    <span class="special">{</span>
      <span class="comment">// Wait for the last write to complete, propagating any exceptions</span>
      <span class="identifier">lastwrite</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
      <span class="identifier">size_t</span> <span class="identifier">thisbuffer</span><span class="special">=</span><span class="identifier">pptr</span><span class="special">()-</span><span class="identifier">pbase</span><span class="special">();</span>
      <span class="keyword">if</span><span class="special">(</span><span class="identifier">thisbuffer</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">)</span>
      <span class="special">{</span>
        <span class="comment">// Detach the current buffer and replace with a fresh one to allow the kernel to steal the page</span>
        <span class="identifier">lastbuffer</span><span class="special">=</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">buffer</span><span class="special">);</span>
        <span class="identifier">buffer</span><span class="special">.</span><span class="identifier">resize</span><span class="special">(</span><span class="identifier">lastbuffer</span><span class="special">.</span><span class="identifier">size</span><span class="special">());</span>
        <span class="identifier">setp</span><span class="special">(</span><span class="identifier">buffer</span><span class="special">.</span><span class="identifier">data</span><span class="special">(),</span> <span class="identifier">buffer</span><span class="special">.</span><span class="identifier">data</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">buffer</span><span class="special">.</span><span class="identifier">size</span><span class="special">());</span>
        <span class="comment">// Schedule an extension of physical storage by an extra page</span>
        <span class="identifier">lastwrite</span> <span class="special">=</span> <span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_truncate</span><span class="special">(</span><span class="identifier">lastwrite</span><span class="special">,</span> <span class="identifier">offset</span> <span class="special">+</span> <span class="identifier">thisbuffer</span><span class="special">);</span>
        <span class="comment">// Schedule an asynchronous write of the buffer to storage</span>
        <span class="identifier">lastwrite</span><span class="special">=</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_write</span><span class="special">(</span><span class="identifier">lastwrite</span><span class="special">,</span> <span class="identifier">lastbuffer</span><span class="special">.</span><span class="identifier">data</span><span class="special">(),</span> <span class="identifier">thisbuffer</span><span class="special">,</span> <span class="identifier">offset</span><span class="special">);</span>
        <span class="identifier">offset</span><span class="special">+=</span><span class="identifier">thisbuffer</span><span class="special">;</span>
      <span class="special">}</span>
      <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
    <span class="special">}</span>
  <span class="special">};</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">directstreambuf</span><span class="special">&gt;</span> <span class="identifier">buf</span><span class="special">;</span>
  <span class="identifier">odirectstream</span><span class="special">(</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">handle_ptr</span> <span class="identifier">h</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span><span class="special">(</span><span class="keyword">new</span> <span class="identifier">directstreambuf</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">h</span><span class="special">))),</span> <span class="identifier">buf</span><span class="special">(</span><span class="keyword">static_cast</span><span class="special">&lt;</span><span class="identifier">directstreambuf</span> <span class="special">*&gt;(</span><span class="identifier">rdbuf</span><span class="special">()))</span>
  <span class="special">{</span>
  <span class="special">}</span>
  <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">odirectstream</span><span class="special">()</span> <span class="identifier">override</span>
  <span class="special">{</span>
    <span class="comment">// Reset the stream before deleting the buffer</span>
    <span class="identifier">rdbuf</span><span class="special">(</span><span class="keyword">nullptr</span><span class="special">);</span>
  <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          These are not hugely conforming iostreams implementations in order to keep
          them brief for the purposes of this tutorial. The read stream is very straightforward,
          we simply have <code class="computeroutput"><span class="identifier">streambuf</span></code>
          directly use the memory map of the file.
        </p>
<p>
          The write stream is a bit more complicated: we fill a 4Kb page and <span class="emphasis"><em>asynchronously</em></span>
          write it out using a page stealing friendly algorithm which in the usual
          case means the kernel simply takes possession of the 4Kb page as-is with
          no memory copying at all. At some future point it will be flushed onto
          storage. The reason this works is thanks to the special STL allocator
          <code class="computeroutput"><span class="identifier">utils</span><span class="special">::</span><span class="identifier">page_allocator</span><span class="special">&lt;&gt;</span></code>
          which returns whole kernel page cache pages. Most kernels will mark whole
          pages scheduled for write with copy-on-write behaviour such that they can
          be safely DMAed by the kernel DMA engine as any subsequent write will cause
          a copy, so because we never write to the page between the write request
          and freeing the page, most kernels simply transfer ownership of the page
          from the user space process to the file page cache with no further processing.
          Hence the asynchronous write of the page tends to complete very quickly
          &#8212; indeed far faster than copying 4Kb of memory and often quicker
          than the time to fill another page, and hence we wait for any previous
          write to complete before scheduling the next write in order to report any
          errors which occurred during the write.
        </p>
<p>
          This is the first use of asynchronous i/o in this tutorial. AFIO provides
          a custom <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
          type extending the lightweight monadic futures framework in <a href="https://ned14.github.io/boost.outcome/group__future__promise.html" target="_top">Boost.Outcome</a>,
          so you get all the <a href="http://www.drdobbs.com/parallel/improving-futures-and-callbacks-in-c-to/240004255" target="_top">C++
          1z Concurrency TS extensions</a>, <a href="http://blogs.msdn.com/b/vcblog/archive/2014/11/12/resumable-functions-in-c.aspx" target="_top">C++
          1z coroutines support</a> and <a href="http://www.boost.org/doc/html/thread/synchronization.html#thread.synchronization.futures" target="_top">Boost.Thread
          future extensions</a> in the AFIO custom <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code>. There are also many additional
          extensions beyond what Boost.Thread or the Concurrency TS provides, including
          foreign future composable waits.
        </p>
<div class="table">
<a name="afio.quickstart.workshop.naive_afio.conditions"></a><p class="title"><b>Table&#160;1.4.&#160;This solution will perform reasonably well under these conditions:</b></p>
<div class="table-contents"><table class="table" summary="This solution will perform reasonably well under these conditions:">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                </th>
<th>
                  <p>
                    Condition
                  </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                  <p>
                    <span class="aligncenter"><span class="green">&#10004;</span></span>
                  </p>
                </td>
<td>
                  <p>
                    On Microsoft Windows you can place the store deep in a directory
                    hierarchy and use long key names.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <span class="aligncenter"><span class="green">&#10004;</span></span>
                  </p>
                </td>
<td>
                  <p>
                    Third party threads and processes can rename the location of
                    the store during use.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <span class="aligncenter"><span class="green">&#10004;</span></span>
                  </p>
                </td>
<td>
                  <p>
                    The size of <span class="emphasis"><em>all</em></span> the values being read at
                    any given time fits into your virtual address space (which is
                    at least 2Gb on 32 bit, 8Tb on 64 bit).
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <span class="aligncenter"><span class="red">&#10008;</span></span>
                  </p>
                </td>
<td>
                  <p>
                    Only one thread or process will ever interact with the key-value
                    store at a time.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <span class="aligncenter"><span class="red">&#10008;</span></span>
                  </p>
                </td>
<td>
                  <p>
                    You don't care what happens if your process unexpectedly exits
                    during a modify.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <span class="aligncenter"><span class="red">&#10008;</span></span>
                  </p>
                </td>
<td>
                  <p>
                    Maximum performance isn't important to you.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <span class="aligncenter"><span class="red">&#10008;</span></span>
                  </p>
                </td>
<td>
                  <p>
                    You don't care what happens under power loss.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <span class="aligncenter"><span class="red">&#10008;</span></span>
                  </p>
                </td>
<td>
                  <p>
                    You don't need to update more than one key-value at once.
                  </p>
                </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break">
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013-2015 Niall Douglas
      and Paul Kirth<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav"><form action="http://melpon.org/wandbox/permlink/nx1G8Xn7fyQdpKLz"><input type="submit" class="tryitnowbtn" value="Try AFIO now in online web compiler"/></form>

<a accesskey="p" href="naive.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../workshop.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../afio.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="naive_afio_async.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
