<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.AFIO</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.AFIO" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Enumerating file extents</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; future<br class="typebreak"/>
&lt; std::vector&lt; std::pair<br class="typebreak"/>
&lt; off_t, off_t &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extents.html#ga490a91017f5f8ed5616386572644ac35">boost::afio::dispatcher::extents</a> (const std::vector&lt; future&lt;&gt;&gt; &amp;ops)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous extent enumerations after preceding operations.  <a href="#ga490a91017f5f8ed5616386572644ac35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::vector&lt; std::pair<br class="typebreak"/>
&lt; off_t, off_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extents.html#gaa1d7fb95799bf5d7ec7539fbcecf7b3f">boost::afio::async_extents</a> (future&lt;&gt; _precondition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous extent enumeration after a preceding operation.  <a href="#gaa1d7fb95799bf5d7ec7539fbcecf7b3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; off_t, <br class="typebreak"/>
off_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extents.html#ga4d97d2fad2c4746bffcab6976fb20b0c">boost::afio::extents</a> (future&lt;&gt; _precondition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous extent enumeration after a preceding operation.  <a href="#ga4d97d2fad2c4746bffcab6976fb20b0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; off_t, <br class="typebreak"/>
off_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extents.html#ga9a678dff8fe43f8ee7129889d96ae9e9">boost::afio::extents</a> (error_code &amp;_ec, future&lt;&gt; _precondition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous extent enumeration after a preceding operation.  <a href="#ga9a678dff8fe43f8ee7129889d96ae9e9"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga490a91017f5f8ed5616386572644ac35"></a><!-- doxytag: member="boost::afio::dispatcher::extents" ref="ga490a91017f5f8ed5616386572644ac35" args="(const std::vector&lt; future&lt;&gt;&gt; &amp;ops)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt; &gt; &gt; <a class="el" href="group__extents.html#ga490a91017f5f8ed5616386572644ac35">boost::afio::dispatcher::extents</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classboost_1_1afio_1_1future.html">future</a>&lt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule a batch of asynchronous extent enumerations after preceding operations. </p>
<p>In a sparsely allocated file, it can be useful to know which extents contain non-zero data. Note that this call is racy (i.e. the extents are enumerated one by one on some platforms, this means they may be out of date with respect to one another) when other threads or processes are concurrently calling <a class="el" href="group__zero.html#ga33bd422b55e8db4f64344707537484c4" title="Schedule a batch of asynchronous zeroing and deallocations of physical storage (&quot;hole punching&quot;) afte...">zero()</a> or <a class="el" href="group__write.html#gab19cc3489106e2998fac116f84cd0540" title="Schedule a batch of asynchronous data writes after preceding operations, where offset and total data ...">write()</a> - this is a host OS API limitation.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A batch of stl_future vectors of extents. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ops</td><td>A batch of op handles.</td></tr>
  </table>
  </dd>
</dl>
 { [raceguarantee FreeBSD, Linux, OS X..Very racy, even individual extent offset and length can race. The following filters are applied before returning results: (i) Any extent whose end appears before its start is retried (ii) Sequences of contiguous extents are merged into single extents.] [raceguarantee Windows..Race free.] }    
<p>Definition at line <a class="el" href="afio_8hpp_source.html#l03725">3725</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa1d7fb95799bf5d7ec7539fbcecf7b3f"></a><!-- doxytag: member="boost::afio::async_extents" ref="gaa1d7fb95799bf5d7ec7539fbcecf7b3f" args="(future&lt;&gt; _precondition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt;std::vector&lt;std::pair&lt;off_t, off_t&gt; &gt; &gt; boost::afio::async_extents </td>
          <td>(</td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronous extent enumeration after a preceding operation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A `future&lt;std::vector&lt;std::pair&lt;off_t, off_t&gt;&gt;&gt;` </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_precondition</td><td>The precondition to use.</td></tr>
  </table>
  </dd>
</dl>
<p>{ [raceguarantee FreeBSD, Linux, OS X..Very racy, even individual extent offset and length can race. The following filters are applied before returning results: (i) Any extent whose end appears before its start is retried (ii) Sequences of contiguous extents are merged into single extents.] [raceguarantee Windows..Race free.] } {Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of extents in each file.}  {extents_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05601">5601</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4d97d2fad2c4746bffcab6976fb20b0c"></a><!-- doxytag: member="boost::afio::extents" ref="ga4d97d2fad2c4746bffcab6976fb20b0c" args="(future&lt;&gt; _precondition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;off_t, off_t&gt; &gt; boost::afio::extents </td>
          <td>(</td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous extent enumeration after a preceding operation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector of extents </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_precondition</td><td>The precondition to use.</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, throwing} { [raceguarantee FreeBSD, Linux, OS X..Very racy, even individual extent offset and length can race. The following filters are applied before returning results: (i) Any extent whose end appears before its start is retried (ii) Sequences of contiguous extents are merged into single extents.] [raceguarantee Windows..Race free.] } {Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of extents in each file.}  {extents_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05623">5623</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9a678dff8fe43f8ee7129889d96ae9e9"></a><!-- doxytag: member="boost::afio::extents" ref="ga9a678dff8fe43f8ee7129889d96ae9e9" args="(error_code &amp;_ec, future&lt;&gt; _precondition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;off_t, off_t&gt; &gt; boost::afio::extents </td>
          <td>(</td>
          <td class="paramtype">error_code &amp;&#160;</td>
          <td class="paramname"><em>_ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous extent enumeration after a preceding operation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector of extents </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_ec</td><td>Error code to set. </td></tr>
    <tr><td class="paramname">_precondition</td><td>The precondition to use.</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, non throwing} { [raceguarantee FreeBSD, Linux, OS X..Very racy, even individual extent offset and length can race. The following filters are applied before returning results: (i) Any extent whose end appears before its start is retried (ii) Sequences of contiguous extents are merged into single extents.] [raceguarantee Windows..Race free.] } {Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of extents in each file.}  {extents_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05646">5646</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>January, 2014</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2013-2014 Niall Douglas, Cork, Ireland<br>
Copyright &copy; 2013 Paul Kirth, California<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
