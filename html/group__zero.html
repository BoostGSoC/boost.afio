<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.AFIO</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.AFIO" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Zeroing and Deallocation</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; future&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__zero.html#ga33bd422b55e8db4f64344707537484c4">boost::afio::dispatcher::zero</a> (const std::vector&lt; future&lt;&gt;&gt; &amp;ops, const std::vector&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt;&gt; &amp;ranges)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous zeroing and deallocations of physical storage ("hole punching") after preceding operations.  <a href="#ga33bd422b55e8db4f64344707537484c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__zero.html#ga30e447c6749c713d291e5748f28b15a8">boost::afio::async_zero</a> (future&lt;&gt; _precondition, std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt; ranges)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous zeroing and deallocation of physical storage ("hole punching") after a preceding operation.  <a href="#ga30e447c6749c713d291e5748f28b15a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__zero.html#ga9d7814e51cf9539362317c1e29f1af1e">boost::afio::zero</a> (future&lt;&gt; _precondition, std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt; ranges)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous zeroing and deallocation of physical storage ("hole punching") after a preceding operation.  <a href="#ga9d7814e51cf9539362317c1e29f1af1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__zero.html#gaa4ff11261aefea5e639b8f9b36e1ecb6">boost::afio::zero</a> (error_code &amp;_ec, future&lt;&gt; _precondition, std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt; ranges)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous zeroing and deallocation of physical storage ("hole punching") after a preceding operation.  <a href="#gaa4ff11261aefea5e639b8f9b36e1ecb6"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga33bd422b55e8db4f64344707537484c4"></a><!-- doxytag: member="boost::afio::dispatcher::zero" ref="ga33bd422b55e8db4f64344707537484c4" args="(const std::vector&lt; future&lt;&gt;&gt; &amp;ops, const std::vector&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt;&gt; &amp;ranges)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future <a class="el" href="group__zero.html#ga33bd422b55e8db4f64344707537484c4">boost::afio::dispatcher::zero</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classboost_1_1afio_1_1future.html">future</a>&lt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule a batch of asynchronous zeroing and deallocations of physical storage ("hole punching") after preceding operations. </p>
<p>Most extent based filing systems provide an optimised way of zeroing parts of a file by deallocating the storage backing those regions, and marking those regions as unwritten instead of actually writing zero bytes to storage. They appear as zeroes to anything reading those ranges, and have the big advantage of not consuming any actual physical storage. On Windows, extent deallocation writes zeros for ordinary files and only actually deallocates physical storage if the file is sparse or compressed (note that AFIO by default creates sparse files where possible, and converts any file opened for writing to a sparse file). For your information, deallocation on NTFS is on a 64Kb granularity, but the zeros are written at a byte granularity. On Linux, an attempt is made to use FALLOC_FL_PUNCH_HOLE which if it fails then a write of zeros corresponding to the same ranges is made instead. On FreeBSD, long runs of zeros are automatically detected and eliminated on physical storage, and so zeros are simply written. On OS X, there is no formal hole punching API that we are aware of, and so zeros are simply written.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A batch of op handles. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ops</td><td>A batch of op handles. </td></tr>
    <tr><td class="paramname">ranges</td><td>A batch of vectors of extents to zero and deallocate.</td></tr>
  </table>
  </dd>
</dl>
    
<p>Definition at line <a class="el" href="afio_8hpp_source.html#l03661">3661</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga30e447c6749c713d291e5748f28b15a8"></a><!-- doxytag: member="boost::afio::async_zero" ref="ga30e447c6749c713d291e5748f28b15a8" args="(future&lt;&gt; _precondition, std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt; ranges)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future boost::afio::async_zero </td>
          <td>(</td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt;&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronous zeroing and deallocation of physical storage ("hole punching") after a preceding operation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classboost_1_1afio_1_1future_3_01void_01_4.html">future&lt;void&gt;</a> </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">ranges</td><td>A sequence of extents to zero and deallocate</td></tr>
  </table>
  </dd>
</dl>
<p>{Amortised O(1) to dispatch. Amortised O(1) to complete if deallocation is constant time.}  {extents_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l04925">4925</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9d7814e51cf9539362317c1e29f1af1e"></a><!-- doxytag: member="boost::afio::zero" ref="ga9d7814e51cf9539362317c1e29f1af1e" args="(future&lt;&gt; _precondition, std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt; ranges)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boost::afio::zero </td>
          <td>(</td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt;&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous zeroing and deallocation of physical storage ("hole punching") after a preceding operation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">ranges</td><td>A sequence of extents to zero and deallocate</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, throwing} {Amortised O(1) to dispatch. Amortised O(1) to complete if deallocation is constant time.}  {extents_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l04941">4941</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa4ff11261aefea5e639b8f9b36e1ecb6"></a><!-- doxytag: member="boost::afio::zero" ref="gaa4ff11261aefea5e639b8f9b36e1ecb6" args="(error_code &amp;_ec, future&lt;&gt; _precondition, std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt; ranges)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boost::afio::zero </td>
          <td>(</td>
          <td class="paramtype">error_code &amp;&#160;</td>
          <td class="paramname"><em>_ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt;&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous zeroing and deallocation of physical storage ("hole punching") after a preceding operation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_ec</td><td>Error code to set. </td></tr>
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">ranges</td><td>A sequence of extents to zero and deallocate</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, non throwing} {Amortised O(1) to dispatch. Amortised O(1) to complete if deallocation is constant time.}  {extents_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l04958">4958</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>January, 2014</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2013-2014 Niall Douglas, Cork, Ireland<br>
Copyright &copy; 2013 Paul Kirth, California<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
