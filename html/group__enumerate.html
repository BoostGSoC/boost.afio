<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.AFIO</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.AFIO" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Enumerating directory contents</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; future<br class="typebreak"/>
&lt; std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga315dc3185fa74461c03a3a9c385ca271">boost::afio::dispatcher::enumerate</a> (const std::vector&lt; enumerate_req &gt; &amp;reqs)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous directory enumerations after preceding operations.  <a href="#ga315dc3185fa74461c03a3a9c385ca271"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga74015ec31aca796992c680e191a0d968">boost::afio::async_enumerate</a> (future&lt;&gt; _precondition, size_t _maxitems=2, bool _restart=true, path _glob=path(), metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous directory enumeration after a preceding operation.  <a href="#ga74015ec31aca796992c680e191a0d968"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gac462b1b97b97c59db8849a67baf8f53c">boost::afio::enumerate</a> (future&lt;&gt; _precondition, size_t _maxitems=2, bool _restart=true, path _glob=path(), metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory enumeration after a preceding operation.  <a href="#gac462b1b97b97c59db8849a67baf8f53c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga04cbf82a44c13d75a0c402b869cfd014">boost::afio::enumerate</a> (error_code &amp;_ec, future&lt;&gt; _precondition, size_t _maxitems=2, bool _restart=true, path _glob=path(), metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory enumeration after a preceding operation.  <a href="#ga04cbf82a44c13d75a0c402b869cfd014"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga7b651769faf2cc67c5fee222a18d3b99">boost::afio::async_enumerate</a> (future&lt;&gt; _precondition, path _glob, size_t _maxitems=2, bool _restart=true, metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous directory enumeration after a preceding operation.  <a href="#ga7b651769faf2cc67c5fee222a18d3b99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gac123eb82a14e339cb3a5d4df52154f24">boost::afio::enumerate</a> (future&lt;&gt; _precondition, path _glob, size_t _maxitems=2, bool _restart=true, metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory enumeration after a preceding operation.  <a href="#gac123eb82a14e339cb3a5d4df52154f24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga2a3bff10dfeb3202a1486cfc9cbf152f">boost::afio::enumerate</a> (error_code &amp;_ec, future&lt;&gt; _precondition, path _glob, size_t _maxitems=2, bool _restart=true, metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory enumeration after a preceding operation.  <a href="#ga2a3bff10dfeb3202a1486cfc9cbf152f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga739567abeecfcb5225aef06e28ff8d99">boost::afio::async_enumerate</a> (future&lt;&gt; _precondition, metadata_flags _metadata, size_t _maxitems=2, bool _restart=true, path _glob=path(), enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous directory enumeration after a preceding operation.  <a href="#ga739567abeecfcb5225aef06e28ff8d99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga9c5568e7ec7a3178f8b2cabd84f5aa09">boost::afio::enumerate</a> (future&lt;&gt; _precondition, metadata_flags _metadata, size_t _maxitems=2, bool _restart=true, path _glob=path(), enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory enumeration after a preceding operation.  <a href="#ga9c5568e7ec7a3178f8b2cabd84f5aa09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga743f1a79f93929f3e68260718cb47e87">boost::afio::enumerate</a> (error_code &amp;_ec, future&lt;&gt; _precondition, metadata_flags _metadata, size_t _maxitems=2, bool _restart=true, path _glob=path(), enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory enumeration after a preceding operation.  <a href="#ga743f1a79f93929f3e68260718cb47e87"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga315dc3185fa74461c03a3a9c385ca271"></a><!-- doxytag: member="boost::afio::dispatcher::enumerate" ref="ga315dc3185fa74461c03a3a9c385ca271" args="(const std::vector&lt; enumerate_req &gt; &amp;reqs)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; std::pair&lt; std::vector&lt; directory_entry &gt;, bool &gt; &gt; <a class="el" href="group__enumerate.html#ga315dc3185fa74461c03a3a9c385ca271">boost::afio::dispatcher::enumerate</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1enumerate__req.html">enumerate_req</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>reqs</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule a batch of asynchronous directory enumerations after preceding operations. </p>
<p>By default <a class="el" href="group__dir.html#ga53dab7942b6737dbdc5b052bdc8db2d7" title="Schedule a batch of asynchronous directory creations and opens after optional preconditions.">dir()</a> returns shared handles i.e. dir( foo) and dir( foo) will return the exact same handle, and therefore enumerating not all of the entries at once is a race condition. The solution is to either set maxitems to a value large enough to guarantee a directory will be enumerated in a single shot, or to open a separate directory handle using the file_flags::unique_directory_handle flag.</p>
<p>Note that setting maxitems=1 will often cause a buffer space exhaustion, causing a second syscall with an enlarged buffer. This is because AFIO cannot know if the allocated buffer can hold all of the filename being retrieved, so it may have to retry. Put another way, setting maxitems=1 will give you the worst performance possible, whereas maxitems=2 will probably only return one item most of the time.</p>
<p>Related types: `__afio_enumerate_req__`, `__afio_directory_entry__`, `__afio_stat_t__`</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A batch of stl_future vectors of directory entries with boolean returning false if done. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reqs</td><td>A batch of enumeration requests.</td></tr>
  </table>
  </dd>
</dl>
 { [raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so comparing inodes for equivalence to a direntry() won't help you.] [raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated, birthtim, sparse, compressed.] }    
<p>Definition at line <a class="el" href="afio_8hpp_source.html#l03717">3717</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga74015ec31aca796992c680e191a0d968"></a><!-- doxytag: member="boost::afio::async_enumerate" ref="ga74015ec31aca796992c680e191a0d968" args="(future&lt;&gt; _precondition, size_t _maxitems=2, bool _restart=true, path _glob=path(), metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, bool&gt; &gt; boost::afio::async_enumerate </td>
          <td>(</td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxitems</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_restart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">path&#160;</td>
          <td class="paramname"><em>_glob</em> = <code>path()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metadata_flags&#160;</td>
          <td class="paramname"><em>_metadata</em> = <code>metadata_flags::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enumerate_req::filter&#160;</td>
          <td class="paramname"><em>_filtering</em> = <code>enumerate_req::filter::fastdeleted</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronous directory enumeration after a preceding operation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A `future&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, bool&gt;&gt;` </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">_maxitems</td><td>The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. </td></tr>
    <tr><td class="paramname">_restart</td><td>Restarts the enumeration for this open directory handle. </td></tr>
    <tr><td class="paramname">_glob</td><td>An optional shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. </td></tr>
    <tr><td class="paramname">_metadata</td><td>The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. </td></tr>
    <tr><td class="paramname">_filtering</td><td>Any filtering you want AFIO to do for you.</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, maxitems first} { [raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so comparing inodes for equivalence to a direntry() won't help you.] [raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated, birthtim, sparse, compressed.] } {Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.}  {enumerate_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05333">5333</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gac462b1b97b97c59db8849a67baf8f53c"></a><!-- doxytag: member="boost::afio::enumerate" ref="gac462b1b97b97c59db8849a67baf8f53c" args="(future&lt;&gt; _precondition, size_t _maxitems=2, bool _restart=true, path _glob=path(), metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;directory_entry&gt;, bool&gt; boost::afio::enumerate </td>
          <td>(</td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxitems</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_restart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">path&#160;</td>
          <td class="paramname"><em>_glob</em> = <code>path()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metadata_flags&#160;</td>
          <td class="paramname"><em>_metadata</em> = <code>metadata_flags::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enumerate_req::filter&#160;</td>
          <td class="paramname"><em>_filtering</em> = <code>enumerate_req::filter::fastdeleted</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous directory enumeration after a preceding operation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector of results and a bool indicating if there is more. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">_maxitems</td><td>The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. </td></tr>
    <tr><td class="paramname">_restart</td><td>Restarts the enumeration for this open directory handle. </td></tr>
    <tr><td class="paramname">_glob</td><td>An optional shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. </td></tr>
    <tr><td class="paramname">_metadata</td><td>The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. </td></tr>
    <tr><td class="paramname">_filtering</td><td>Any filtering you want AFIO to do for you.</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, max items first throwing} { [raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so comparing inodes for equivalence to a direntry() won't help you.] [raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated, birthtim, sparse, compressed.] } {Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.}  {enumerate_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05362">5362</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga04cbf82a44c13d75a0c402b869cfd014"></a><!-- doxytag: member="boost::afio::enumerate" ref="ga04cbf82a44c13d75a0c402b869cfd014" args="(error_code &amp;_ec, future&lt;&gt; _precondition, size_t _maxitems=2, bool _restart=true, path _glob=path(), metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;directory_entry&gt;, bool&gt; boost::afio::enumerate </td>
          <td>(</td>
          <td class="paramtype">error_code &amp;&#160;</td>
          <td class="paramname"><em>_ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxitems</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_restart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">path&#160;</td>
          <td class="paramname"><em>_glob</em> = <code>path()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metadata_flags&#160;</td>
          <td class="paramname"><em>_metadata</em> = <code>metadata_flags::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enumerate_req::filter&#160;</td>
          <td class="paramname"><em>_filtering</em> = <code>enumerate_req::filter::fastdeleted</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous directory enumeration after a preceding operation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector of results and a bool indicating if there is more. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_ec</td><td>Error code to set. </td></tr>
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">_maxitems</td><td>The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. </td></tr>
    <tr><td class="paramname">_restart</td><td>Restarts the enumeration for this open directory handle. </td></tr>
    <tr><td class="paramname">_glob</td><td>An optional shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. </td></tr>
    <tr><td class="paramname">_metadata</td><td>The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. </td></tr>
    <tr><td class="paramname">_filtering</td><td>Any filtering you want AFIO to do for you.</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, max items first non throwing} { [raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so comparing inodes for equivalence to a direntry() won't help you.] [raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated, birthtim, sparse, compressed.] } {Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.}  {enumerate_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05392">5392</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7b651769faf2cc67c5fee222a18d3b99"></a><!-- doxytag: member="boost::afio::async_enumerate" ref="ga7b651769faf2cc67c5fee222a18d3b99" args="(future&lt;&gt; _precondition, path _glob, size_t _maxitems=2, bool _restart=true, metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, bool&gt; &gt; boost::afio::async_enumerate </td>
          <td>(</td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">path&#160;</td>
          <td class="paramname"><em>_glob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxitems</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_restart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metadata_flags&#160;</td>
          <td class="paramname"><em>_metadata</em> = <code>metadata_flags::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enumerate_req::filter&#160;</td>
          <td class="paramname"><em>_filtering</em> = <code>enumerate_req::filter::fastdeleted</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronous directory enumeration after a preceding operation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A `future&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, bool&gt;&gt;` </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">_glob</td><td>A shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. </td></tr>
    <tr><td class="paramname">_maxitems</td><td>The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. </td></tr>
    <tr><td class="paramname">_restart</td><td>Restarts the enumeration for this open directory handle. </td></tr>
    <tr><td class="paramname">_metadata</td><td>The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. </td></tr>
    <tr><td class="paramname">_filtering</td><td>Any filtering you want AFIO to do for you.</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, glob first} { [raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so comparing inodes for equivalence to a direntry() won't help you.] [raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated, birthtim, sparse, compressed.] } {Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.}  {enumerate_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05424">5424</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gac123eb82a14e339cb3a5d4df52154f24"></a><!-- doxytag: member="boost::afio::enumerate" ref="gac123eb82a14e339cb3a5d4df52154f24" args="(future&lt;&gt; _precondition, path _glob, size_t _maxitems=2, bool _restart=true, metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;directory_entry&gt;, bool&gt; boost::afio::enumerate </td>
          <td>(</td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">path&#160;</td>
          <td class="paramname"><em>_glob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxitems</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_restart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metadata_flags&#160;</td>
          <td class="paramname"><em>_metadata</em> = <code>metadata_flags::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enumerate_req::filter&#160;</td>
          <td class="paramname"><em>_filtering</em> = <code>enumerate_req::filter::fastdeleted</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous directory enumeration after a preceding operation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector of results and a bool indicating if there is more. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">_glob</td><td>A shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. </td></tr>
    <tr><td class="paramname">_maxitems</td><td>The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. </td></tr>
    <tr><td class="paramname">_restart</td><td>Restarts the enumeration for this open directory handle. </td></tr>
    <tr><td class="paramname">_metadata</td><td>The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. </td></tr>
    <tr><td class="paramname">_filtering</td><td>Any filtering you want AFIO to do for you.</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, glob first throwing} { [raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so comparing inodes for equivalence to a direntry() won't help you.] [raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated, birthtim, sparse, compressed.] } {Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.}  {enumerate_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05453">5453</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga2a3bff10dfeb3202a1486cfc9cbf152f"></a><!-- doxytag: member="boost::afio::enumerate" ref="ga2a3bff10dfeb3202a1486cfc9cbf152f" args="(error_code &amp;_ec, future&lt;&gt; _precondition, path _glob, size_t _maxitems=2, bool _restart=true, metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;directory_entry&gt;, bool&gt; boost::afio::enumerate </td>
          <td>(</td>
          <td class="paramtype">error_code &amp;&#160;</td>
          <td class="paramname"><em>_ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">path&#160;</td>
          <td class="paramname"><em>_glob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxitems</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_restart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metadata_flags&#160;</td>
          <td class="paramname"><em>_metadata</em> = <code>metadata_flags::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enumerate_req::filter&#160;</td>
          <td class="paramname"><em>_filtering</em> = <code>enumerate_req::filter::fastdeleted</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous directory enumeration after a preceding operation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector of results and a bool indicating if there is more. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_ec</td><td>Error code to set. </td></tr>
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">_glob</td><td>A shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. </td></tr>
    <tr><td class="paramname">_maxitems</td><td>The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. </td></tr>
    <tr><td class="paramname">_restart</td><td>Restarts the enumeration for this open directory handle. </td></tr>
    <tr><td class="paramname">_metadata</td><td>The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. </td></tr>
    <tr><td class="paramname">_filtering</td><td>Any filtering you want AFIO to do for you.</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, glob first non throwing} { [raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so comparing inodes for equivalence to a direntry() won't help you.] [raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated, birthtim, sparse, compressed.] } {Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.}  {enumerate_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05483">5483</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga739567abeecfcb5225aef06e28ff8d99"></a><!-- doxytag: member="boost::afio::async_enumerate" ref="ga739567abeecfcb5225aef06e28ff8d99" args="(future&lt;&gt; _precondition, metadata_flags _metadata, size_t _maxitems=2, bool _restart=true, path _glob=path(), enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, bool&gt; &gt; boost::afio::async_enumerate </td>
          <td>(</td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metadata_flags&#160;</td>
          <td class="paramname"><em>_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxitems</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_restart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">path&#160;</td>
          <td class="paramname"><em>_glob</em> = <code>path()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enumerate_req::filter&#160;</td>
          <td class="paramname"><em>_filtering</em> = <code>enumerate_req::filter::fastdeleted</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronous directory enumeration after a preceding operation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A `future&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, bool&gt;&gt;` </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">_metadata</td><td>The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. </td></tr>
    <tr><td class="paramname">_maxitems</td><td>The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. </td></tr>
    <tr><td class="paramname">_restart</td><td>Restarts the enumeration for this open directory handle. </td></tr>
    <tr><td class="paramname">_glob</td><td>An optional shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. </td></tr>
    <tr><td class="paramname">_filtering</td><td>Any filtering you want AFIO to do for you.</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, metadata first} { [raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so comparing inodes for equivalence to a direntry() won't help you.] [raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated, birthtim, sparse, compressed.] } {Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.}  {enumerate_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05515">5515</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9c5568e7ec7a3178f8b2cabd84f5aa09"></a><!-- doxytag: member="boost::afio::enumerate" ref="ga9c5568e7ec7a3178f8b2cabd84f5aa09" args="(future&lt;&gt; _precondition, metadata_flags _metadata, size_t _maxitems=2, bool _restart=true, path _glob=path(), enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;directory_entry&gt;, bool&gt; boost::afio::enumerate </td>
          <td>(</td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metadata_flags&#160;</td>
          <td class="paramname"><em>_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxitems</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_restart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">path&#160;</td>
          <td class="paramname"><em>_glob</em> = <code>path()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enumerate_req::filter&#160;</td>
          <td class="paramname"><em>_filtering</em> = <code>enumerate_req::filter::fastdeleted</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous directory enumeration after a preceding operation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector of results and a bool indicating if there is more. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">_metadata</td><td>The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. </td></tr>
    <tr><td class="paramname">_maxitems</td><td>The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. </td></tr>
    <tr><td class="paramname">_restart</td><td>Restarts the enumeration for this open directory handle. </td></tr>
    <tr><td class="paramname">_glob</td><td>An optional shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. </td></tr>
    <tr><td class="paramname">_filtering</td><td>Any filtering you want AFIO to do for you.</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, metadata first throwing} { [raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so comparing inodes for equivalence to a direntry() won't help you.] [raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated, birthtim, sparse, compressed.] } {Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.}  {enumerate_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05544">5544</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga743f1a79f93929f3e68260718cb47e87"></a><!-- doxytag: member="boost::afio::enumerate" ref="ga743f1a79f93929f3e68260718cb47e87" args="(error_code &amp;_ec, future&lt;&gt; _precondition, metadata_flags _metadata, size_t _maxitems=2, bool _restart=true, path _glob=path(), enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;directory_entry&gt;, bool&gt; boost::afio::enumerate </td>
          <td>(</td>
          <td class="paramtype">error_code &amp;&#160;</td>
          <td class="paramname"><em>_ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metadata_flags&#160;</td>
          <td class="paramname"><em>_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxitems</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_restart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">path&#160;</td>
          <td class="paramname"><em>_glob</em> = <code>path()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enumerate_req::filter&#160;</td>
          <td class="paramname"><em>_filtering</em> = <code>enumerate_req::filter::fastdeleted</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous directory enumeration after a preceding operation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector of results and a bool indicating if there is more. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_ec</td><td>Error code to set. </td></tr>
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">_metadata</td><td>The metadata to prefetch for each item enumerated. AFIO may fetch more metadata than requested if it is cost free. </td></tr>
    <tr><td class="paramname">_maxitems</td><td>The maximum number of items to return in this request. Note that setting to one will often invoke two syscalls. </td></tr>
    <tr><td class="paramname">_restart</td><td>Restarts the enumeration for this open directory handle. </td></tr>
    <tr><td class="paramname">_glob</td><td>An optional shell glob by which to filter the items returned. Done kernel side on Windows, user side on POSIX. </td></tr>
    <tr><td class="paramname">_filtering</td><td>Any filtering you want AFIO to do for you.</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, metadata first non throwing} { [raceguarantee FreeBSD, Linux, OS X..Race free per batch of up to ['maxitems] for ino and type only. Remember that many filing systems will recycle inodes such that a created file will get the inode of a just deleted file, so comparing inodes for equivalence to a direntry() won't help you.] [raceguarantee Windows..Race free per batch of up to ['maxitems] for ino, type, atim, mtim, ctim, size, allocated, birthtim, sparse, compressed.] } {Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.}  {enumerate_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05574">5574</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>January, 2014</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2013-2014 Niall Douglas, Cork, Ireland<br>
Copyright &copy; 2013 Paul Kirth, California<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
