<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.AFIO</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.AFIO" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/v2/afio.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides a batch asynchronous file i/o implementation based on Boost.ASIO.  
<a href="#details">More...</a></p>

<p><a href="afio_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1detail_1_1enqueued__task__impl.html">boost::afio::detail::enqueued_task_impl&lt; R &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1enqueued__task__impl_1_1_private.html">boost::afio::detail::enqueued_task_impl&lt; R &gt;::Private</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1enqueued__task_3_01_r_07_08_4.html">boost::afio::enqueued_task&lt; R()&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1enqueued__task_3_01void_07_08_4.html">boost::afio::enqueued_task&lt; void()&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1thread__source.html">boost::afio::thread_source</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for a source of thread workers.  <a href="classboost_1_1afio_1_1thread__source.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1std__thread__pool.html">boost::afio::std_thread_pool</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A very simple thread pool based on std::thread or boost::thread.  <a href="classboost_1_1afio_1_1std__thread__pool.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::std_thread_pool::worker</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1path.html">boost::afio::path</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An AFIO filesystem path, a thin wrapper of filesystem::path used to mark when a filesystem path has been prepared for AFIO usage. Note that on Windows this exclusively refers to a case sensitive NT kernel path, not a Win32 path (Win32 paths are converted in the constructor).  <a href="classboost_1_1afio_1_1path.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::path::direct</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1path_1_1make__absolute.html">boost::afio::path::make_absolute</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a path absolute according to the current working directory.  <a href="structboost_1_1afio_1_1path_1_1make__absolute.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1path__hash.html">boost::afio::path_hash</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A hasher for path.  <a href="structboost_1_1afio_1_1path__hash.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1stat__t.html">boost::afio::stat_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata about a directory entry.  <a href="structboost_1_1afio_1_1stat__t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1statfs__t.html">boost::afio::statfs_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata about a filing system. Unsupported entries are -1.  <a href="structboost_1_1afio_1_1statfs__t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1statfs__t_1_1f__flags__t.html">boost::afio::statfs_t::f_flags_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1directory__entry.html">boost::afio::directory_entry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base class for an entry in a directory with lazily filled metadata.  <a href="classboost_1_1afio_1_1directory__entry.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1directory__entry__hash.html">boost::afio::directory_entry_hash</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A hasher for <a class="el" href="classboost_1_1afio_1_1directory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>, hashing inode and birth time (if available on this platform).  <a href="structboost_1_1afio_1_1directory__entry__hash.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1handle.html">boost::afio::handle</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base class encapsulating a platform-specific file handle.  <a href="classboost_1_1afio_1_1handle.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1handle_1_1mapped__file.html">boost::afio::handle::mapped_file</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A holder of a mapped file.  <a href="structboost_1_1afio_1_1handle_1_1mapped__file.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1current__dispatcher__guard.html">boost::afio::current_dispatcher_guard</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1is__future.html">boost::afio::is_future&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait for determining if a type is an afio::future&lt;T&gt;  <a href="structboost_1_1afio_1_1is__future.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1is__future_3_01future_3_01_t_01_4_01_4.html">boost::afio::is_future&lt; future&lt; T &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1future_3_01void_01_4.html">boost::afio::future&lt; void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1future.html">boost::afio::future&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The future status of a scheduled asynchronous operation.  <a href="classboost_1_1afio_1_1future.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1do__continuation.html">boost::afio::detail::do_continuation&lt; future_type, promise_type &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1do__continuation_3_01future_3_01_r_01_4_00_01void_01_4.html">boost::afio::detail::do_continuation&lt; future&lt; R &gt;, void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1vs2013__variadic__overload__resolution__workaround.html">boost::afio::detail::vs2013_variadic_overload_resolution_workaround&lt; C, Args &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1dispatcher.html">boost::afio::dispatcher</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for dispatching file i/o asynchronously.  <a href="classboost_1_1afio_1_1dispatcher.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1when__all__state.html">boost::afio::detail::when_all_state</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1when__any__state.html">boost::afio::detail::when_any_state</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1select__when__ops__return__type.html">boost::afio::detail::select_when_ops_return_type&lt; is_all &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1select__when__ops__return__type_3_01false_01_4.html">boost::afio::detail::select_when_ops_return_type&lt; false &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1enable__if__async__op.html">boost::afio::detail::enable_if_async_op&lt; is_all, T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1enable__if__async__op_3_01is__all_00_01future_3_01_t_01_4_01_4.html">boost::afio::detail::enable_if_async_op&lt; is_all, future&lt; T &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1path__req.html">boost::afio::path_req</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of path and flags, with optional precondition. Paths may be a path fragment (relative to the precondition) or absolute, in which case if necessary they are made canonical and absolute in the constructor according to the current working directory.  <a href="structboost_1_1afio_1_1path__req.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1path__req_1_1relative.html">boost::afio::path_req::relative</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience tag type constructing a relative path <a class="el" href="structboost_1_1afio_1_1path__req.html" title="A convenience bundle of path and flags, with optional precondition. Paths may be a path fragment (rel...">path_req</a>.  <a href="structboost_1_1afio_1_1path__req_1_1relative.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1path__req_1_1absolute.html">boost::afio::path_req::absolute</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience tag type constructing an absolute path <a class="el" href="structboost_1_1afio_1_1path__req.html" title="A convenience bundle of path and flags, with optional precondition. Paths may be a path fragment (rel...">path_req</a>.  <a href="structboost_1_1afio_1_1path__req_1_1absolute.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, T, is_trivial, is_container &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01_t_00_01true_00_01false_01_4.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, T, true, false &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1container__to__asio__buffers__helper.html">boost::afio::detail::container_to_asio_buffers_helper&lt; R, C, T, is_const, is_trivial &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1container__to__asio__buffers__helper_3_01_r_00_01std_1_1basic__5b83d962173a868180c70129e7984b44.html">boost::afio::detail::container_to_asio_buffers_helper&lt; R, std::basic_string&lt; C, T, A &gt;, _Ct, is_const, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1container__to__asio__buffers__helper_3_01_r_00_01std_1_1vector_08cceb32b20cab5c10bc02eea27ecdef.html">boost::afio::detail::container_to_asio_buffers_helper&lt; R, std::vector&lt; T, A &gt;, _T, is_const, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1container__to__asio__buffers__helper_3_01_r_00_01std_1_1array_31d265f3bd056d3edf5412f1bb8b25367.html">boost::afio::detail::container_to_asio_buffers_helper&lt; R, std::array&lt; T, N &gt;, _T, is_const, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01_t_00_01is__trivial_00_01true_01_4.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, T, is_trivial, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01std_1_1vec015c9a1671103d5540a40db22dcf2c1f.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, std::vector&lt; asio::mutable_buffer &gt;, false, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01asio_1_1mutable__ba628783a2410b194f4c8f9901c9e881d.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, asio::mutable_buffer, std::vector&lt; asio::mutable_buffer &gt;, false, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01std_1_1vecf0033e923d262694df69e5de182cb274.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, std::vector&lt; asio::const_buffer &gt;, false, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01asio_1_1const__bufc343c227ba61700fa8c7433b21830407.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, asio::const_buffer, std::vector&lt; asio::const_buffer &gt;, false, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01std_1_1arr71ff4d886b752dc4ea6a8a63c5132139.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, std::array&lt; asio::mutable_buffer, N &gt;, false, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01std_1_1arr7698302ecba29743ef4e88d006e0ea0e.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, std::array&lt; asio::const_buffer, N &gt;, false, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1detail_1_1io__req__impl_3_01false_01_4.html">boost::afio::detail::io_req_impl&lt; false &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1detail_1_1io__req__impl_3_01true_01_4.html">boost::afio::detail::io_req_impl&lt; true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1io__req.html">boost::afio::io_req&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for reading into a T as specified by its <a class="el" href="group__to__asio__buffers.html#ga772fe53eebaa2177dc53227bbef03f3f" title="Any trivial type T or STL container.">to_asio_buffers()</a> overload. Data <b>MUST</b> stay around until the operation completes.  <a href="structboost_1_1afio_1_1io__req.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1io__req_3_01const_01_t_01_4.html">boost::afio::io_req&lt; const T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for reading into a T as specified by its <a class="el" href="group__to__asio__buffers.html#ga772fe53eebaa2177dc53227bbef03f3f" title="Any trivial type T or STL container.">to_asio_buffers()</a> overload. Data <b>MUST</b> stay around until the operation completes.  <a href="structboost_1_1afio_1_1io__req_3_01const_01_t_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1io__req_3_01void_01_4.html">boost::afio::io_req&lt; void &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for reading into a T as specified by its <a class="el" href="group__to__asio__buffers.html#ga772fe53eebaa2177dc53227bbef03f3f" title="Any trivial type T or STL container.">to_asio_buffers()</a> overload. Data <b>MUST</b> stay around until the operation completes.  <a href="structboost_1_1afio_1_1io__req_3_01void_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1io__req_3_01const_01void_01_4.html">boost::afio::io_req&lt; const void &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for reading into a T as specified by its <a class="el" href="group__to__asio__buffers.html#ga772fe53eebaa2177dc53227bbef03f3f" title="Any trivial type T or STL container.">to_asio_buffers()</a> overload. Data <b>MUST</b> stay around until the operation completes.  <a href="structboost_1_1afio_1_1io__req_3_01const_01void_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1make__io__req.html">boost::afio::detail::make_io_req&lt; T, is_container &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1make__io__req_3_01_t_00_01true_01_4.html">boost::afio::detail::make_io_req&lt; T, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1enumerate__req.html">boost::afio::enumerate_req</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, number of items to enumerate, item pattern match and metadata to prefetch.  <a href="structboost_1_1afio_1_1enumerate__req.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1lock__req.html">boost::afio::lock_req</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__file__io__dispatcher__rwconverter.html">boost::afio::detail::async_file_io_dispatcher_rwconverter&lt; iswrite, T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__dir.html">boost::afio::detail::async_dir&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__rmdir.html">boost::afio::detail::async_rmdir&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__file.html">boost::afio::detail::async_file&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__rmfile.html">boost::afio::detail::async_rmfile&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__symlink.html">boost::afio::detail::async_symlink&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__rmsymlink.html">boost::afio::detail::async_rmsymlink&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__sync.html">boost::afio::detail::async_sync</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__close.html">boost::afio::detail::async_close</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__read.html">boost::afio::detail::async_read</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__write.html">boost::afio::detail::async_write</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__truncate.html">boost::afio::detail::async_truncate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__enumerate.html">boost::afio::detail::async_enumerate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__zero.html">boost::afio::detail::async_zero</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__extents.html">boost::afio::detail::async_extents</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__statfs.html">boost::afio::detail::async_statfs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1__is__not__handle.html">boost::afio::detail::_is_not_handle&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1__is__not__handle_3_01future_3_01_t_01_4_01_4.html">boost::afio::detail::_is_not_handle&lt; future&lt; T &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1__is__not__handle_3_01handle__ptr_01_4.html">boost::afio::detail::_is_not_handle&lt; handle_ptr &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1is__not__handle.html">boost::afio::detail::is_not_handle&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1utils_1_1secded__ecc.html">boost::afio::utils::secded_ecc&lt; blocksize &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the single error correcting double error detecting (SECDED) Hamming Error Correcting Code for a <em>blocksize</em> block of bytes. For example, a secdec_ecc&lt;8&gt; would be the very common 72,64 Hamming code used in ECC RAM, or secdec_ecc&lt;4096&gt; would be for a 32784,32768 Hamming code.  <a href="classboost_1_1afio_1_1utils_1_1secded__ecc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1utils_1_1detail_1_1large__page__allocation.html">boost::afio::utils::detail::large_page_allocation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1utils_1_1page__allocator.html">boost::afio::utils::page_allocator&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An STL allocator which allocates large TLB page memory.If the operating system is configured to allow it, this type of memory is particularly efficient for doing large scale file i/o. This is because the kernel must normally convert the scatter gather buffers you pass into extended scatter gather buffers as the memory you see as contiguous may not, and probably isn't, actually be contiguous in physical memory. Regions returned by this allocator <em>may</em> be allocated contiguously in physical memory and therefore the kernel can pass through your scatter gather buffers unmodified.  <a href="classboost_1_1afio_1_1utils_1_1page__allocator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1utils_1_1page__allocator_1_1rebind.html">boost::afio::utils::page_allocator&lt; T &gt;::rebind&lt; U &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1utils_1_1page__allocator_3_01void_01_4.html">boost::afio::utils::page_allocator&lt; void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1utils_1_1page__allocator_3_01void_01_4_1_1rebind.html">boost::afio::utils::page_allocator&lt; void &gt;::rebind&lt; U &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1hash_3_01boost_1_1afio_1_1path_01_4.html">std::hash&lt; boost::afio::path &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1hash_3_01boost_1_1afio_1_1directory__entry_01_4.html">std::hash&lt; boost::afio::directory_entry &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1afio_1_1detail.html">boost::afio::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The namespace containing Boost.ASIO internal details. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1afio_1_1utils.html">boost::afio::utils</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Utility routines often useful when using AFIO. </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="afio_8hpp.html#a7d6cb43e029a76765081fb3a2f47187d">BOOST_AFIO_HEADERS_ONLY</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if AFIO is compiled as headers only. Defaults to 1.  <a href="#a7d6cb43e029a76765081fb3a2f47187d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="afio_8hpp.html#a183b5c98a87ff28a56ea3bfdbe141ee9">BOOST_AFIO_USE_BOOST_THREAD</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if AFIO is bound against Boost.Thread or the C++ 11 STL thread. Defaults to 0.  <a href="#a183b5c98a87ff28a56ea3bfdbe141ee9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="afio_8hpp.html#ab5974d84a78dbcf8b072fca370f1291d">BOOST_AFIO_USE_BOOST_FILESYSTEM</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if AFIO is bound against Boost.Filesystem or the C++ 1z Filesystem TS. Defaults to 1 unless on VS2015 which provides a full Filesystem TS implementation.  <a href="#ab5974d84a78dbcf8b072fca370f1291d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="afio_8hpp.html#a5b90f4adb6bc09ca319c35c3448ee67a">ASIO_STANDALONE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if AFIO is bound against standalone ASIO or Boost.ASIO. Defaults to undefined, and therefore Boost.ASIO.  <a href="#a5b90f4adb6bc09ca319c35c3448ee67a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9fda2e1537705604ffb6f707cb9eed7"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_V2_NAMESPACE" ref="ad9fda2e1537705604ffb6f707cb9eed7" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_V2_NAMESPACE</b>&#160;&#160;&#160;boost::afio</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1c6bc5f2e5ebf3d2d18ee8ceee0f740"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_V2_NAMESPACE_BEGIN" ref="aa1c6bc5f2e5ebf3d2d18ee8ceee0f740" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_V2_NAMESPACE_BEGIN</b>&#160;&#160;&#160;namespace boost { namespace afio {</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39f521144fef02193249bb7e3b0698fe"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_V2_NAMESPACE_END" ref="a39f521144fef02193249bb7e3b0698fe" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_V2_NAMESPACE_END</b>&#160;&#160;&#160;} }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a75b0e1ac1a86e60b2666ed2f64d36f"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC" ref="a5a75b0e1ac1a86e60b2666ed2f64d36f" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4f63024aa1238f1d6a067b3d7fb23c7"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC" ref="ab4f63024aa1238f1d6a067b3d7fb23c7" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC</b>&#160;&#160;&#160;virtual</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19812b1d7c3f2fb967d5a58d509638fb"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_AFIO_H" ref="a19812b1d7c3f2fb967d5a58d509638fb" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_AFIO_H</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga8abeb465d2ca6fa15b3c3754697e5577">BOOST_AFIO_VALIDATE_INPUTS</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate inputs at the point of instantiation.  <a href="group__macros.html#ga8abeb465d2ca6fa15b3c3754697e5577"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD</b>(type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac794ed8c3e9fc1a99bd54d5b993d2b6c"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD" ref="ac794ed8c3e9fc1a99bd54d5b993d2b6c" args="(field)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD</b>(field)&#160;&#160;&#160;fieldtype st_##field(handle_ptr dirh=handle_ptr()) { if(!(have_metadata&amp;metadata_flags::field)) { _int_fetch(metadata_flags::field, dirh); } return stat.st_##field; }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a130389fe4d2bf643955597dfb34fe962"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_SECDEC_INTRINSICS" ref="a130389fe4d2bf643955597dfb34fe962" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_SECDEC_INTRINSICS</b>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_ROUND</b>(n)</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90c6d3eb9c6ffd8c9b90e0d4578415e0"></a><!-- doxytag: member="afio.hpp::off_t" ref="a90c6d3eb9c6ffd8c9b90e0d4578415e0" args="" -->
typedef unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::off_t</b></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>path_normalise</b> { <b>boost::afio::dos</b>, 
<b>boost::afio::guid_volume</b>, 
<b>boost::afio::guid_all</b>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The types of path normalisation available.  <a href="namespaceboost_1_1afio.html#afae7a43ba5460cf42cc5614c1948b136">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__file__flags.html#ga1615042683add1802cfc6dc86bd078ee">boost::afio::file_flags</a> { <br/>
&#160;&#160;<b>boost::afio::none</b> = 0, 
<b>boost::afio::read</b> = 1, 
<b>boost::afio::write</b> = 2, 
<b>boost::afio::read_write</b> = 3, 
<br/>
&#160;&#160;<b>boost::afio::append</b> = 4, 
<b>boost::afio::truncate</b> = 8, 
<b>boost::afio::create</b> = 16, 
<b>boost::afio::create_only_if_not_exist</b> = 32, 
<br/>
&#160;&#160;<b>boost::afio::create_compressed</b> = 64, 
<b>boost::afio::will_be_sequentially_accessed</b> = 128, 
<b>boost::afio::will_be_randomly_accessed</b> = 256, 
<b>boost::afio::no_sparse</b> = 512, 
<br/>
&#160;&#160;<b>boost::afio::hold_parent_open</b> = (1&lt;&lt;10), 
<b>boost::afio::unique_directory_handle</b> = (1&lt;&lt;11), 
<b>boost::afio::no_race_protection</b> = (1&lt;&lt;12), 
<b>boost::afio::temporary_file</b> = (1&lt;&lt;13), 
<br/>
&#160;&#160;<b>boost::afio::delete_on_close</b> = (1&lt;&lt;14), 
<b>boost::afio::os_direct</b> = (1&lt;&lt;16), 
<b>os_lockable</b> = (1&lt;&lt;17), 
<b>boost::afio::always_sync</b> = (1&lt;&lt;24), 
<br/>
&#160;&#160;<b>boost::afio::sync_on_close</b> = (1&lt;&lt;25), 
<b>boost::afio::int_hold_parent_open_nested</b> = (1&lt;&lt;27), 
<b>boost::afio::int_file_share_delete</b> = (1&lt;&lt;28), 
<b>boost::afio::int_opening_link</b> = (1&lt;&lt;29), 
<br/>
&#160;&#160;<b>boost::afio::int_opening_dir</b> = (1&lt;&lt;30)
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise file and directory open flags.  <a href="group__file__flags.html#ga1615042683add1802cfc6dc86bd078ee">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__op__flags.html#ga3d03d4b42e2ae303e282d0a1dec22976">boost::afio::async_op_flags</a> { <b>boost::afio::none</b> = 0, 
<b>boost::afio::immediate</b> = 1
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise async_op_flags flags.  <a href="group__async__op__flags.html#ga3d03d4b42e2ae303e282d0a1dec22976">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1afio_1_1detail.html#a0988089f34c099ad2ef946d6ff03c959">boost::afio::detail::OpType</a> { <br/>
&#160;&#160;<b>Unknown</b>, 
<b>UserCompletion</b>, 
<b>dir</b>, 
<b>rmdir</b>, 
<br/>
&#160;&#160;<b>file</b>, 
<b>rmfile</b>, 
<b>symlink</b>, 
<b>rmsymlink</b>, 
<br/>
&#160;&#160;<b>sync</b>, 
<b>close</b>, 
<b>read</b>, 
<b>write</b>, 
<br/>
&#160;&#160;<b>truncate</b>, 
<b>barrier</b>, 
<b>enumerate</b>, 
<b>adopt</b>, 
<br/>
&#160;&#160;<b>zero</b>, 
<b>extents</b>, 
<b>statfs</b>, 
<b>lock</b>, 
<br/>
&#160;&#160;<b>Last</b>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of operation.  <a href="namespaceboost_1_1afio_1_1detail.html#a0988089f34c099ad2ef946d6ff03c959">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1afio_1_1detail.html#af3116f1d2de8f7ba95f5a2e36c7bf251">boost::afio::detail::unit_testing_flags</a> { <a class="el" href="namespaceboost_1_1afio_1_1detail.html#af3116f1d2de8f7ba95f5a2e36c7bf251ac26df2d2a5f37aaaa525c1aa1057428a">boost::afio::detail::none</a> = 0, 
<a class="el" href="namespaceboost_1_1afio_1_1detail.html#af3116f1d2de8f7ba95f5a2e36c7bf251ace6ba4420a272bd919f0fb3cc5278e29">boost::afio::detail::no_symbol_lookup</a> = (1&lt;&lt;0)
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metadata__flags.html#ga228a95ca96f053e74e69e6d1ab23eccb">boost::afio::metadata_flags</a> { <br/>
&#160;&#160;<b>None</b> = 0, 
<b>dev</b> = 1&lt;&lt;0, 
<b>ino</b> = 1&lt;&lt;1, 
<b>type</b> = 1&lt;&lt;2, 
<br/>
&#160;&#160;<b>perms</b> = 1&lt;&lt;3, 
<b>nlink</b> = 1&lt;&lt;4, 
<b>uid</b> = 1&lt;&lt;5, 
<b>gid</b> = 1&lt;&lt;6, 
<br/>
&#160;&#160;<b>rdev</b> = 1&lt;&lt;7, 
<b>atim</b> = 1&lt;&lt;8, 
<b>mtim</b> = 1&lt;&lt;9, 
<b>ctim</b> = 1&lt;&lt;10, 
<br/>
&#160;&#160;<b>size</b> = 1&lt;&lt;11, 
<b>allocated</b> = 1&lt;&lt;12, 
<b>blocks</b> = 1&lt;&lt;13, 
<b>blksize</b> = 1&lt;&lt;14, 
<br/>
&#160;&#160;<b>flags</b> = 1&lt;&lt;15, 
<b>gen</b> = 1&lt;&lt;16, 
<b>birthtim</b> = 1&lt;&lt;17, 
<b>sparse</b> = 1&lt;&lt;24, 
<br/>
&#160;&#160;<b>compressed</b> = 1&lt;&lt;25, 
<b>reparse_point</b> = 1&lt;&lt;26, 
<b>boost::afio::All</b> = (size_t)-1
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitflags for availability of metadata from `struct stat_t`See __afio_stat_t__ for explanation of meaning.  <a href="group__metadata__flags.html#ga228a95ca96f053e74e69e6d1ab23eccb">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__metadata__flags.html#gadc548bc518f40378c9c9c97f4a994438">boost::afio::fs_metadata_flags</a> { <br/>
&#160;&#160;<b>None</b> = 0, 
<b>flags</b> = 1&lt;&lt;15, 
<b>bsize</b> = 1&lt;&lt;2, 
<b>iosize</b> = 1&lt;&lt;3, 
<br/>
&#160;&#160;<b>blocks</b> = 1&lt;&lt;13, 
<b>bfree</b> = 1&lt;&lt;5, 
<b>bavail</b> = 1&lt;&lt;6, 
<b>files</b> = 1&lt;&lt;7, 
<br/>
&#160;&#160;<b>ffree</b> = 1&lt;&lt;8, 
<b>namemax</b> = 1&lt;&lt;9, 
<b>owner</b> = 1&lt;&lt;10, 
<b>fsid</b> = 1&lt;&lt;11, 
<br/>
&#160;&#160;<b>fstypename</b> = 1&lt;&lt;12, 
<b>mntfromname</b> = 1&lt;&lt;13, 
<b>mntonname</b> = 1&lt;&lt;14, 
<b>boost::afio::All</b> = (size_t)-1
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitflags for availability of metadata from `struct statfs_t`.  <a href="group__fs__metadata__flags.html#gadc548bc518f40378c9c9c97f4a994438">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOST_AFIO_DECL <br class="typebreak"/>
std::shared_ptr<br class="typebreak"/>
&lt; std_thread_pool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__process__threadpool.html#gabb4747cc11ef3ee1bbb969bc78c238bb">boost::afio::process_threadpool</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the process threadpool.  <a href="group__process__threadpool.html#gabb4747cc11ef3ee1bbb969bc78c238bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0e3d02935dd8a2a8277daead11eb4b0"></a><!-- doxytag: member="afio.hpp::operator&lt;" ref="ae0e3d02935dd8a2a8277daead11eb4b0" args="(const path &amp;lhs, const path &amp;rhs)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::operator&lt;</b> (const path &amp;lhs, const path &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae19787194c1042aef3dcb693f4329559"></a><!-- doxytag: member="afio.hpp::operator&lt;=" ref="ae19787194c1042aef3dcb693f4329559" args="(const path &amp;lhs, const path &amp;rhs)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::operator&lt;=</b> (const path &amp;lhs, const path &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c800de48262cde6cffb71bcaff872db"></a><!-- doxytag: member="afio.hpp::operator&gt;" ref="a4c800de48262cde6cffb71bcaff872db" args="(const path &amp;lhs, const path &amp;rhs)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::operator&gt;</b> (const path &amp;lhs, const path &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8779e551d691aeeba100fc91554961f6"></a><!-- doxytag: member="afio.hpp::operator&gt;=" ref="a8779e551d691aeeba100fc91554961f6" args="(const path &amp;lhs, const path &amp;rhs)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::operator&gt;=</b> (const path &amp;lhs, const path &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98dded77e29c80a11adf0b788d64848c"></a><!-- doxytag: member="afio.hpp::operator==" ref="a98dded77e29c80a11adf0b788d64848c" args="(const path &amp;lhs, const path &amp;rhs)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::operator==</b> (const path &amp;lhs, const path &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac988be6a1643f87dcf367ecb5b74d256"></a><!-- doxytag: member="afio.hpp::operator!=" ref="ac988be6a1643f87dcf367ecb5b74d256" args="(const path &amp;lhs, const path &amp;rhs)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::operator!=</b> (const path &amp;lhs, const path &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24d1607ab696725ffba9dfbf81269a7f"></a><!-- doxytag: member="afio.hpp::operator/" ref="a24d1607ab696725ffba9dfbf81269a7f" args="(const path &amp;lhs, const path &amp;rhs)" -->
path&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::operator/</b> (const path &amp;lhs, const path &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a654ce987a7ca43daebb51c2dfcd173f4"></a><!-- doxytag: member="afio.hpp::operator&lt;&lt;" ref="a654ce987a7ca43daebb51c2dfcd173f4" args="(std::ostream &amp;s, const path &amp;p)" -->
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::operator&lt;&lt;</b> (std::ostream &amp;s, const path &amp;p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__normalise__path.html#ga39a6017e4b2141d24e37f89f3ef03416">boost::afio::normalise_path</a> (path p, path_normalise type=path_normalise::dos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a normalised filesystem::path from an AFIO path.  <a href="group__normalise__path.html#ga39a6017e4b2141d24e37f89f3ef03416"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa676bdf762c5e8d6f8826e199cae924f"></a><!-- doxytag: member="afio.hpp::static_assert" ref="aa676bdf762c5e8d6f8826e199cae924f" args="(static_cast&lt; size_t &gt;(OpType::Last)==sizeof(optypes)/sizeof(*optypes),&quot;You forgot to fix up the strings matching OpType&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::detail::static_assert</b> (static_cast&lt; size_t &gt;(OpType::Last)==sizeof(optypes)/sizeof(*optypes),&quot;You forgot to fix up the strings matching OpType&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOST_AFIO_DECL dispatcher_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher.html#gacfe9912eab3bdb55d9ea751dad84f733">boost::afio::current_dispatcher</a> (option&lt; dispatcher_ptr &gt; new_dispatcher=empty)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the currently set async_file_io_dispatcher for this thread, optionally setting it to a new dispatcher.  <a href="group__async__file__io__dispatcher.html#gacfe9912eab3bdb55d9ea751dad84f733"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ab951c257b1df364ba0b8b4251e269628"></a><!-- doxytag: member="afio.hpp::decode_relative_path" ref="ab951c257b1df364ba0b8b4251e269628" args="(path_req &amp;req, bool force_absolute=false)" -->
template&lt;class Impl , class Handle &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">handle_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::detail::decode_relative_path</b> (path_req &amp;req, bool force_absolute=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOST_AFIO_DECL outcome<br class="typebreak"/>
&lt; dispatcher_ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher.html#ga061d7fbaacd6489cc4c631ad3b0170f4">boost::afio::make_dispatcher</a> (std::string uri=&quot;file : / / /&quot;, file_flags flagsforce=file_flags::none, file_flags flagsmask=file_flags::none, std::shared_ptr&lt; thread_source &gt; threadpool=process_threadpool()) noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Instatiates the best available async_file_io_dispatcher implementation for this system for the given uri.  <a href="group__async__file__io__dispatcher.html#ga061d7fbaacd6489cc4c631ad3b0170f4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ab2379f238e2ebbacf46d54cbd434da38"></a><!-- doxytag: member="afio.hpp::when_all_ops_do" ref="ab2379f238e2ebbacf46d54cbd434da38" args="(std::shared_ptr&lt; when_all_state &gt; state)" -->
template&lt;bool rethrow&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::detail::when_all_ops_do</b> (std::shared_ptr&lt; when_all_state &gt; state)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8887c350f6eb346e750dec25a08b7b83"></a><!-- doxytag: member="afio.hpp::when_all_ops" ref="a8887c350f6eb346e750dec25a08b7b83" args="(Iterator first, Iterator last)" -->
template&lt;bool rethrow, class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">stl_future&lt; std::vector<br class="typebreak"/>
&lt; handle_ptr &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::detail::when_all_ops</b> (Iterator first, Iterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="add509906206f9687a06a29698d41cd81"></a><!-- doxytag: member="afio.hpp::when_any_ops_do" ref="add509906206f9687a06a29698d41cd81" args="(std::shared_ptr&lt; when_any_state &gt; state, size_t idx, size_t id, future&lt;&gt; h)" -->
template&lt;bool rethrow&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, handle_ptr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::detail::when_any_ops_do</b> (std::shared_ptr&lt; when_any_state &gt; state, size_t idx, size_t id, future&lt;&gt; h)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a33f4601f2abdb116fbcfeb0eb9e665c8"></a><!-- doxytag: member="afio.hpp::when_any_ops" ref="a33f4601f2abdb116fbcfeb0eb9e665c8" args="(Iterator first, Iterator last)" -->
template&lt;bool rethrow, class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">stl_future&lt; handle_ptr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::detail::when_any_ops</b> (Iterator first, Iterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_async_op<br class="typebreak"/>
&lt; true, typename <br class="typebreak"/>
Iterator::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::when_all_p</b> (std::nothrow_t _, Iterator first, Iterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when all the supplied ops complete. Does not propagate exception states.  <a href="#a233cc1c91e1cfe9caede854287c0cdf0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_async_op<br class="typebreak"/>
&lt; false, typename <br class="typebreak"/>
Iterator::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::when_any</b> (std::nothrow_t _, Iterator first, Iterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when any the supplied ops complete. Does not propagate exception states.  <a href="#a85c6d5c463b1ecffdc2a6bda4f040bb0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">stl_future&lt; std::vector<br class="typebreak"/>
&lt; handle_ptr &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::when_all_p</b> (std::nothrow_t _, std::vector&lt; future&lt; T &gt;&gt; ops)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when all the supplied ops complete. Does not propagate exception states.  <a href="#aede828e133f781ded2c561be2422ea5c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">stl_future&lt; handle_ptr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::when_any</b> (std::nothrow_t _, std::vector&lt; future&lt; T &gt;&gt; ops)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when any the supplied ops complete. Does not propagate exception states.  <a href="#a30e476856061b03226c4eb6851da17e6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_async_op<br class="typebreak"/>
&lt; true, typename <br class="typebreak"/>
Iterator::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::when_all_p</b> (Iterator first, Iterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when all the supplied ops complete. Propagates exception states.  <a href="#ad779f2544c109948dc5b02a104e2940b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_async_op<br class="typebreak"/>
&lt; false, typename <br class="typebreak"/>
Iterator::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::when_any</b> (Iterator first, Iterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when any the supplied ops complete. Propagates exception states.  <a href="#a1a452f7d0c7a0517e824cddb0816e872"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">stl_future&lt; std::vector<br class="typebreak"/>
&lt; handle_ptr &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::when_all_p</b> (std::vector&lt; future&lt; T &gt;&gt; ops)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when all the supplied ops complete. Propagates exception states.  <a href="#aa52d2807802731cbdebea60caaef09ad"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">stl_future&lt; handle_ptr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::when_any</b> (std::vector&lt; future&lt; T &gt;&gt; ops)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when any the supplied ops complete. Propagates exception states.  <a href="#afb5ddc17bb7f1e7c495ee0b2704053db"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">stl_future&lt; std::vector<br class="typebreak"/>
&lt; handle_ptr &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::when_all_p</b> (std::nothrow_t _, future&lt; T &gt; op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when the supplied op completes. Does not propagate exception states.  <a href="#a3c780237c13fefa0e8fe7494a8b8eb85"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class... Types&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">stl_future&lt; std::vector<br class="typebreak"/>
&lt; handle_ptr &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::when_all_p</b> (future&lt; Types &gt; &amp;...ops)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when the supplied op completes. Propagates exception states.  <a href="#a50fe2b706f0e70f54711c92703333428"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::mutable_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#ga772fe53eebaa2177dc53227bbef03f3f">boost::afio::to_asio_buffers</a> (T &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Any trivial type T or STL container.  <a href="group__to__asio__buffers.html#ga772fe53eebaa2177dc53227bbef03f3f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::const_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#ga0967653554334e6532eeaf4de0f7fe07">boost::afio::to_asio_buffers</a> (const T &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Any trivial type T or STL container.  <a href="group__to__asio__buffers.html#ga0967653554334e6532eeaf4de0f7fe07"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::mutable_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#ga403430fff790e5142116cfbf562cdf07">boost::afio::to_asio_buffers</a> (T(&amp;v)[N])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer at v sized N*sizeof(T)  <a href="group__to__asio__buffers.html#ga403430fff790e5142116cfbf562cdf07"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::const_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#gac055cc87431a0c5700e9cda29453f3bb">boost::afio::to_asio_buffers</a> (const T(&amp;v)[N])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer at v sized N*sizeof(T)  <a href="group__to__asio__buffers.html#gac055cc87431a0c5700e9cda29453f3bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; asio::mutable_buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#ga4d5b48b8b62041f0eb1d332b6ee3c8a9">boost::afio::to_asio_buffers</a> (asio::mutable_buffer &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Passing through asio::mutable_buffer.  <a href="group__to__asio__buffers.html#ga4d5b48b8b62041f0eb1d332b6ee3c8a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; asio::const_buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#gaad8ba2d78365cbb49705467d8e3923b8">boost::afio::to_asio_buffers</a> (asio::const_buffer &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Passing through asio::const_buffer.  <a href="group__to__asio__buffers.html#gaad8ba2d78365cbb49705467d8e3923b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::mutable_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#gae9038306b955f1af06f765ae0f2880a1">boost::afio::to_asio_buffers</a> (T *v, size_t length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer at v sized length*sizeof(T)  <a href="group__to__asio__buffers.html#gae9038306b955f1af06f765ae0f2880a1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::const_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#gad414435390ce9e4cfe4bf85d43447c0b">boost::afio::to_asio_buffers</a> (const T *v, size_t length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer at v sized length*sizeof(T)  <a href="group__to__asio__buffers.html#gad414435390ce9e4cfe4bf85d43447c0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; asio::mutable_buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#ga6d517384616b5648508780391b3e8f5f">boost::afio::to_asio_buffers</a> (void *v, size_t length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer at v sized length.  <a href="group__to__asio__buffers.html#ga6d517384616b5648508780391b3e8f5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; asio::const_buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#ga42be30127e97be9c73906906e74b24b0">boost::afio::to_asio_buffers</a> (const void *v, size_t length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer at v sized length.  <a href="group__to__asio__buffers.html#ga42be30127e97be9c73906906e74b24b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__make__io__req.html#ga44d919a9b54e0cc52c63a05a6e116c44">boost::afio::make_io_req</a> (future&lt;&gt; _precondition, T &amp;&amp;v, off_t _where)-&gt; decltype(detail</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience instantiator of a <a class="el" href="structboost_1_1afio_1_1io__req.html" title="A convenience bundle of precondition, data and where for reading into a T as specified by its to_asio...">io_req</a>, letting the compiler deduce the template specialisation to use.  <a href="group__make__io__req.html#ga44d919a9b54e0cc52c63a05a6e116c44"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">io_req&lt; const <br class="typebreak"/>
std::initializer_list&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__make__io__req.html#ga34ef4e16833eba205e565e314fb3a468">boost::afio::make_io_req</a> (future&lt;&gt; _precondition, const std::initializer_list&lt; T &gt; &amp;v, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience instantiator of a <a class="el" href="structboost_1_1afio_1_1io__req.html" title="A convenience bundle of precondition, data and where for reading into a T as specified by its to_asio...">io_req</a>, letting the compiler deduce the template specialisation to use.  <a href="group__make__io__req.html#ga34ef4e16833eba205e565e314fb3a468"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__make__io__req.html#ga925273d03932a47999f55808af333a59">boost::afio::make_io_req</a> (future&lt;&gt; _precondition, T &amp;&amp;v, size_t _length, off_t _where)-&gt; decltype(detail</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience instantiator of a <a class="el" href="structboost_1_1afio_1_1io__req.html" title="A convenience bundle of precondition, data and where for reading into a T as specified by its to_asio...">io_req</a>, letting the compiler deduce the template specialisation to use.  <a href="group__make__io__req.html#ga925273d03932a47999f55808af333a59"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="abf792b13368e8deb1715e9dc81e7c872"></a><!-- doxytag: member="afio.hpp::doCall" ref="abf792b13368e8deb1715e9dc81e7c872" args="(size_t, future&lt;&gt; _, std::shared_ptr&lt; tasktype &gt; c)" -->
template&lt;class tasktype &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, handle_ptr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::detail::doCall</b> (size_t, future&lt;&gt; _, std::shared_ptr&lt; tasktype &gt; c)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dir.html#ga5a20a4818164005c8640772c63205fcc">boost::afio::async_dir</a> (future&lt;&gt; _precondition, T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous directory creation and open after an optional precondition.  <a href="group__dir.html#ga5a20a4818164005c8640772c63205fcc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dir.html#ga6fecb4c9353296bc45c7abd942ca5329">boost::afio::async_dir</a> (T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous directory creation and open after an optional precondition.  <a href="group__dir.html#ga6fecb4c9353296bc45c7abd942ca5329"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">handle_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dir.html#ga778e4a88c929b4abaa6264e49cfa4657">boost::afio::dir</a> (future&lt;&gt; _precondition, T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory creation and open after an optional precondition.  <a href="group__dir.html#ga778e4a88c929b4abaa6264e49cfa4657"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">handle_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dir.html#gacdf6a3977e2a8d2841a50c41c6a4e2a9">boost::afio::dir</a> (T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory creation and open after an optional precondition.  <a href="group__dir.html#gacdf6a3977e2a8d2841a50c41c6a4e2a9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">handle_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dir.html#gab1ca36868f62f9a12511e87289659e3f">boost::afio::dir</a> (error_code &amp;_ec, future&lt;&gt; _precondition, T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory creation and open after an optional precondition.  <a href="group__dir.html#gab1ca36868f62f9a12511e87289659e3f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">handle_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dir.html#ga681d090afd3d83f8f149127822d6b035">boost::afio::dir</a> (error_code &amp;_ec, T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory creation and open after an optional precondition.  <a href="group__dir.html#ga681d090afd3d83f8f149127822d6b035"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T  = path&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmdir.html#ga474fb6569da2bdd27f370374f72ef34c">boost::afio::async_rmdir</a> (future&lt;&gt; _precondition, T _path=path(), file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous directory deletion after an optional precondition.  <a href="group__rmdir.html#ga474fb6569da2bdd27f370374f72ef34c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmdir.html#gac69bbcb40618c07e5674f076a1dc81c0">boost::afio::async_rmdir</a> (T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous directory deletion after an optional precondition.  <a href="group__rmdir.html#gac69bbcb40618c07e5674f076a1dc81c0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T  = path&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmdir.html#gab562ebc267ce340011b51f6d5204f65e">boost::afio::rmdir</a> (future&lt;&gt; _precondition, T _path=path(), file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory deletion after an optional precondition.  <a href="group__rmdir.html#gab562ebc267ce340011b51f6d5204f65e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmdir.html#gab2832cf63a71b94b97baeacb09ad2870">boost::afio::rmdir</a> (T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory deletion after an optional precondition.  <a href="group__rmdir.html#gab2832cf63a71b94b97baeacb09ad2870"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T  = path&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmdir.html#ga13a666bf2e73b6085db12879ab44d0ae">boost::afio::rmdir</a> (error_code &amp;_ec, future&lt;&gt; _precondition, T _path=path(), file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory deletion after an optional precondition.  <a href="group__rmdir.html#ga13a666bf2e73b6085db12879ab44d0ae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmdir.html#ga569f6bcbe0ad07951b045dc52c513977">boost::afio::rmdir</a> (error_code &amp;_ec, T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory deletion after an optional precondition.  <a href="group__rmdir.html#ga569f6bcbe0ad07951b045dc52c513977"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__file.html#ga5c53d2b273af197144049fd163fee9e7">boost::afio::async_file</a> (future&lt;&gt; _precondition, T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous file creation and open after an optional precondition.  <a href="group__file.html#ga5c53d2b273af197144049fd163fee9e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__file.html#ga8193d39767259b5fed7f183049584856">boost::afio::async_file</a> (T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous file creation and open after an optional precondition.  <a href="group__file.html#ga8193d39767259b5fed7f183049584856"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">handle_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__file.html#gabeef9e35748d4729b5ef09e3e2663481">boost::afio::file</a> (future&lt;&gt; _precondition, T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous file creation and open after an optional precondition.  <a href="group__file.html#gabeef9e35748d4729b5ef09e3e2663481"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">handle_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__file.html#ga8f67d2733a575c9d4ce0cfd770e8d407">boost::afio::file</a> (T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous file creation and open after an optional precondition.  <a href="group__file.html#ga8f67d2733a575c9d4ce0cfd770e8d407"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">handle_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__file.html#ga182caaad67acfed6cf50c53c2480d88f">boost::afio::file</a> (error_code &amp;_ec, future&lt;&gt; _precondition, T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous file creation and open after an optional precondition.  <a href="group__file.html#ga182caaad67acfed6cf50c53c2480d88f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">handle_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__file.html#gada32c45dd92447ef54b9d6ef22eae0c2">boost::afio::file</a> (error_code &amp;_ec, T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous file creation and open after an optional precondition.  <a href="group__file.html#gada32c45dd92447ef54b9d6ef22eae0c2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T  = path&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmfile.html#ga6b0a32f1ff85824f3884df770a601abf">boost::afio::async_rmfile</a> (future&lt;&gt; _precondition, T _path=path(), file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous file deletion after an optional precondition.  <a href="group__rmfile.html#ga6b0a32f1ff85824f3884df770a601abf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmfile.html#ga5323e4a1af6037836c787570fa9c329f">boost::afio::async_rmfile</a> (T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous file deletion after an optional precondition.  <a href="group__rmfile.html#ga5323e4a1af6037836c787570fa9c329f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T  = path&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmfile.html#ga925473688066a4a625a62c59af93d48a">boost::afio::rmfile</a> (future&lt;&gt; _precondition, T _path=path(), file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous file deletion after an optional precondition.  <a href="group__rmfile.html#ga925473688066a4a625a62c59af93d48a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmfile.html#ga6b247cab4be4e2ff767c5b0a74bee487">boost::afio::rmfile</a> (T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous file deletion after an optional precondition.  <a href="group__rmfile.html#ga6b247cab4be4e2ff767c5b0a74bee487"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T  = path&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmfile.html#ga62f1ecf14f0a598133a57329f4418e41">boost::afio::rmfile</a> (error_code &amp;_ec, future&lt;&gt; _precondition, T _path=path(), file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous file deletion after an optional precondition.  <a href="group__rmfile.html#ga62f1ecf14f0a598133a57329f4418e41"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmfile.html#ga99df853c75dc7fb63b02be3e286ecac3">boost::afio::rmfile</a> (error_code &amp;_ec, T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous file deletion after an optional precondition.  <a href="group__rmfile.html#ga99df853c75dc7fb63b02be3e286ecac3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__symlink.html#ga0e6a7d45bc2af5424d6cfcb1e9aad2f9">boost::afio::async_symlink</a> (future&lt;&gt; _precondition, T _path, future&lt;&gt; _target=future&lt;&gt;(), file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous symlink creation and open after a precondition.  <a href="group__symlink.html#ga0e6a7d45bc2af5424d6cfcb1e9aad2f9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__symlink.html#gaaf28dcd891c54c2b5242aa0ba7c0312c">boost::afio::async_symlink</a> (T _path, future&lt;&gt; _target=future&lt;&gt;(), file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous symlink creation and open after a precondition.  <a href="group__symlink.html#gaaf28dcd891c54c2b5242aa0ba7c0312c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">handle_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__symlink.html#ga8fc07e04b8762d01e038152ea346efc3">boost::afio::symlink</a> (future&lt;&gt; _precondition, T _path, future&lt;&gt; _target=future&lt;&gt;(), file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous symlink creation and open after a precondition..  <a href="group__symlink.html#ga8fc07e04b8762d01e038152ea346efc3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">handle_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__symlink.html#gaa02b764e0f8be34f758cc0cc59f85f6a">boost::afio::symlink</a> (T _path, future&lt;&gt; _target=future&lt;&gt;(), file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous symlink creation and open after a precondition.  <a href="group__symlink.html#gaa02b764e0f8be34f758cc0cc59f85f6a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">handle_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__symlink.html#ga6c136870d84ac8cb267fb3ea2643415c">boost::afio::symlink</a> (error_code &amp;_ec, future&lt;&gt; _precondition, T _path, future&lt;&gt; _target=future&lt;&gt;(), file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous symlink creation and open after a precondition.  <a href="group__symlink.html#ga6c136870d84ac8cb267fb3ea2643415c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">handle_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__symlink.html#ga14569fd7d7dcdd3548a3f7ff6ef16d6b">boost::afio::symlink</a> (error_code &amp;_ec, T _path, future&lt;&gt; _target=future&lt;&gt;(), file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous symlink creation and open after a precondition.  <a href="group__symlink.html#ga14569fd7d7dcdd3548a3f7ff6ef16d6b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T  = path&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmsymlink.html#gace449b75069c4f96671c9302b66dee6e">boost::afio::async_rmsymlink</a> (future&lt;&gt; _precondition, T _path=path(), file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous symlink deletion after an optional precondition.  <a href="group__rmsymlink.html#gace449b75069c4f96671c9302b66dee6e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmsymlink.html#ga47b9123130b1ebeaff92490ff33c1030">boost::afio::async_rmsymlink</a> (T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous symlink deletion after an optional precondition.  <a href="group__rmsymlink.html#ga47b9123130b1ebeaff92490ff33c1030"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T  = path&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmsymlink.html#ga27bc61ab9287fd2d67cbf4e02b33b333">boost::afio::rmsymlink</a> (future&lt;&gt; _precondition, T _path=path(), file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous symlink deletion after an optional precondition.  <a href="group__rmsymlink.html#ga27bc61ab9287fd2d67cbf4e02b33b333"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmsymlink.html#gad6d4e3db1798849a5638da1c5cf7d738">boost::afio::rmsymlink</a> (T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous symlink deletion after an optional precondition.  <a href="group__rmsymlink.html#gad6d4e3db1798849a5638da1c5cf7d738"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T  = path&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmsymlink.html#ga34230957da5ee5b74e8438cbc571400d">boost::afio::rmsymlink</a> (error_code &amp;_ec, future&lt;&gt; _precondition, T _path=path(), file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous symlink deletion after an optional precondition.  <a href="group__rmsymlink.html#ga34230957da5ee5b74e8438cbc571400d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;detail::is_not_handle&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rmsymlink.html#ga6e985c0119f7856059558f17ab4c5a25">boost::afio::rmsymlink</a> (error_code &amp;_ec, T _path, file_flags _flags=file_flags::none)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous symlink deletion after an optional precondition.  <a href="group__rmsymlink.html#ga6e985c0119f7856059558f17ab4c5a25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sync.html#ga13ed056124e2310090415af506ffd109">boost::afio::async_sync</a> (future&lt;&gt; _precondition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous content synchronisation with physical storage after a preceding operation.  <a href="group__sync.html#ga13ed056124e2310090415af506ffd109"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sync.html#gac5e026a564a3d0f4c30c24e0d06d3451">boost::afio::sync</a> (future&lt;&gt; _precondition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous content synchronisation with physical storage after a preceding operation.  <a href="group__sync.html#gac5e026a564a3d0f4c30c24e0d06d3451"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sync.html#gad21731619a03c23385b33ef0b9ee6f0a">boost::afio::sync</a> (error_code &amp;_ec, future&lt;&gt; _precondition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous content synchronisation with physical storage after a preceding operation.  <a href="group__sync.html#gad21731619a03c23385b33ef0b9ee6f0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__zero.html#ga30e447c6749c713d291e5748f28b15a8">boost::afio::async_zero</a> (future&lt;&gt; _precondition, std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt; ranges)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous zeroing and deallocation of physical storage ("hole punching") after a preceding operation.  <a href="group__zero.html#ga30e447c6749c713d291e5748f28b15a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__zero.html#ga9d7814e51cf9539362317c1e29f1af1e">boost::afio::zero</a> (future&lt;&gt; _precondition, std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt; ranges)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous zeroing and deallocation of physical storage ("hole punching") after a preceding operation.  <a href="group__zero.html#ga9d7814e51cf9539362317c1e29f1af1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__zero.html#gaa4ff11261aefea5e639b8f9b36e1ecb6">boost::afio::zero</a> (error_code &amp;_ec, future&lt;&gt; _precondition, std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt; ranges)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous zeroing and deallocation of physical storage ("hole punching") after a preceding operation.  <a href="group__zero.html#gaa4ff11261aefea5e639b8f9b36e1ecb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__close.html#gab22573ef0ac6a55249418a8629dc9310">boost::afio::async_close</a> (future&lt;&gt; _precondition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous file or directory handle close after a preceding operation.  <a href="group__close.html#gab22573ef0ac6a55249418a8629dc9310"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__close.html#ga21ba3b262183f7e8877c10ddef325a69">boost::afio::close</a> (future&lt;&gt; _precondition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous file or directory handle close after a preceding operation.  <a href="group__close.html#ga21ba3b262183f7e8877c10ddef325a69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__close.html#ga1016fe157861d1f3d2c192f4f0957085">boost::afio::close</a> (error_code &amp;_ec, future&lt;&gt; _precondition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous file or directory handle close after a preceding operation.  <a href="group__close.html#ga1016fe157861d1f3d2c192f4f0957085"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#gadc1b927777732d065474d845c9d64af8">boost::afio::async_read</a> (future&lt;&gt; _precondition, T &amp;&amp;v, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous data read after a preceding operation, where offset and total data read must not exceed the present file size.  <a href="group__read.html#gadc1b927777732d065474d845c9d64af8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga91eefbeec03a2cbf2f7b0faa82c937b8">boost::afio::async_read</a> (future&lt;&gt; _precondition, T &amp;&amp;v, size_t _length, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous data read after a preceding operation, where offset and total data read must not exceed the present file size.  <a href="group__read.html#ga91eefbeec03a2cbf2f7b0faa82c937b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga4e992fe38f62d94b84819c17285a5fa9">boost::afio::read</a> (future&lt;&gt; _precondition, T &amp;&amp;v, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous data read after a preceding operation, where offset and total data read must not exceed the present file size.  <a href="group__read.html#ga4e992fe38f62d94b84819c17285a5fa9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#gaf83812504911011ecc5ca2c470de9fcb">boost::afio::read</a> (future&lt;&gt; _precondition, T &amp;&amp;v, size_t _length, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous data read after a preceding operation, where offset and total data read must not exceed the present file size.  <a href="group__read.html#gaf83812504911011ecc5ca2c470de9fcb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga8b1cbd7173ec175df510f34c25855917">boost::afio::read</a> (error_code &amp;_ec, future&lt;&gt; _precondition, T &amp;&amp;v, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous data read after a preceding operation, where offset and total data read must not exceed the present file size.  <a href="group__read.html#ga8b1cbd7173ec175df510f34c25855917"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga76d3b26225d3f6f7ab0fcc61b16ac52f">boost::afio::read</a> (error_code &amp;_ec, future&lt;&gt; _precondition, T &amp;&amp;v, size_t _length, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous data read after a preceding operation, where offset and total data read must not exceed the present file size.  <a href="group__read.html#ga76d3b26225d3f6f7ab0fcc61b16ac52f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#gab9c892d19f17e66dbb10f7b5d1f2835e">boost::afio::async_write</a> (future&lt;&gt; _precondition, T &amp;&amp;v, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous data write after a preceding operation, where offset and total data written must not exceed the present file size.  <a href="group__write.html#gab9c892d19f17e66dbb10f7b5d1f2835e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#gaa3ede34089d21b572711065c346c9c33">boost::afio::async_write</a> (future&lt;&gt; _precondition, T &amp;&amp;v, size_t _length, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous data write after a preceding operation, where offset and total data written must not exceed the present file size.  <a href="group__write.html#gaa3ede34089d21b572711065c346c9c33"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#gab9e8a184889629c0d8939f9ac10a99ea">boost::afio::write</a> (future&lt;&gt; _precondition, T &amp;&amp;v, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous data write after a preceding operation, where offset and total data written must not exceed the present file size.  <a href="group__write.html#gab9e8a184889629c0d8939f9ac10a99ea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#ga856e3ccae23be302b682c19285d8575e">boost::afio::write</a> (future&lt;&gt; _precondition, T &amp;&amp;v, size_t _length, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous data write after a preceding operation, where offset and total data written must not exceed the present file size.  <a href="group__write.html#ga856e3ccae23be302b682c19285d8575e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#gae7e5e9e93ed2c5e4000f1948b4c73454">boost::afio::write</a> (error_code &amp;_ec, future&lt;&gt; _precondition, T &amp;&amp;v, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous data write after a preceding operation, where offset and total data written must not exceed the present file size.  <a href="group__write.html#gae7e5e9e93ed2c5e4000f1948b4c73454"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#gabb484be50650777055f8f534860390b2">boost::afio::write</a> (error_code &amp;_ec, future&lt;&gt; _precondition, T &amp;&amp;v, size_t _length, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous data write after a preceding operation, where offset and total data written must not exceed the present file size.  <a href="group__write.html#gabb484be50650777055f8f534860390b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__truncate.html#ga64f5e85e808fe8e76899a0aaa785602b">boost::afio::async_truncate</a> (future&lt;&gt; _precondition, off_t newsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous file length truncation after a preceding operation.  <a href="group__truncate.html#ga64f5e85e808fe8e76899a0aaa785602b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__truncate.html#ga2e81ae4496af922ff723b1e938fe7556">boost::afio::truncate</a> (future&lt;&gt; _precondition, off_t newsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous file length truncation after a preceding operation.  <a href="group__truncate.html#ga2e81ae4496af922ff723b1e938fe7556"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__truncate.html#gadcf80681c64de985173f53132dd48453">boost::afio::truncate</a> (error_code &amp;_ec, future&lt;&gt; _precondition, off_t newsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous file length truncation after a preceding operation.  <a href="group__truncate.html#gadcf80681c64de985173f53132dd48453"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga74015ec31aca796992c680e191a0d968">boost::afio::async_enumerate</a> (future&lt;&gt; _precondition, size_t _maxitems=2, bool _restart=true, path _glob=path(), metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous directory enumeration after a preceding operation.  <a href="group__enumerate.html#ga74015ec31aca796992c680e191a0d968"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gac462b1b97b97c59db8849a67baf8f53c">boost::afio::enumerate</a> (future&lt;&gt; _precondition, size_t _maxitems=2, bool _restart=true, path _glob=path(), metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory enumeration after a preceding operation.  <a href="group__enumerate.html#gac462b1b97b97c59db8849a67baf8f53c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga04cbf82a44c13d75a0c402b869cfd014">boost::afio::enumerate</a> (error_code &amp;_ec, future&lt;&gt; _precondition, size_t _maxitems=2, bool _restart=true, path _glob=path(), metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory enumeration after a preceding operation.  <a href="group__enumerate.html#ga04cbf82a44c13d75a0c402b869cfd014"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga7b651769faf2cc67c5fee222a18d3b99">boost::afio::async_enumerate</a> (future&lt;&gt; _precondition, path _glob, size_t _maxitems=2, bool _restart=true, metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous directory enumeration after a preceding operation.  <a href="group__enumerate.html#ga7b651769faf2cc67c5fee222a18d3b99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gac123eb82a14e339cb3a5d4df52154f24">boost::afio::enumerate</a> (future&lt;&gt; _precondition, path _glob, size_t _maxitems=2, bool _restart=true, metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory enumeration after a preceding operation.  <a href="group__enumerate.html#gac123eb82a14e339cb3a5d4df52154f24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga2a3bff10dfeb3202a1486cfc9cbf152f">boost::afio::enumerate</a> (error_code &amp;_ec, future&lt;&gt; _precondition, path _glob, size_t _maxitems=2, bool _restart=true, metadata_flags _metadata=metadata_flags::None, enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory enumeration after a preceding operation.  <a href="group__enumerate.html#ga2a3bff10dfeb3202a1486cfc9cbf152f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga739567abeecfcb5225aef06e28ff8d99">boost::afio::async_enumerate</a> (future&lt;&gt; _precondition, metadata_flags _metadata, size_t _maxitems=2, bool _restart=true, path _glob=path(), enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous directory enumeration after a preceding operation.  <a href="group__enumerate.html#ga739567abeecfcb5225aef06e28ff8d99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga9c5568e7ec7a3178f8b2cabd84f5aa09">boost::afio::enumerate</a> (future&lt;&gt; _precondition, metadata_flags _metadata, size_t _maxitems=2, bool _restart=true, path _glob=path(), enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory enumeration after a preceding operation.  <a href="group__enumerate.html#ga9c5568e7ec7a3178f8b2cabd84f5aa09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; directory_entry &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga743f1a79f93929f3e68260718cb47e87">boost::afio::enumerate</a> (error_code &amp;_ec, future&lt;&gt; _precondition, metadata_flags _metadata, size_t _maxitems=2, bool _restart=true, path _glob=path(), enumerate_req::filter _filtering=enumerate_req::filter::fastdeleted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous directory enumeration after a preceding operation.  <a href="group__enumerate.html#ga743f1a79f93929f3e68260718cb47e87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::vector&lt; std::pair<br class="typebreak"/>
&lt; off_t, off_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extents.html#gaa1d7fb95799bf5d7ec7539fbcecf7b3f">boost::afio::async_extents</a> (future&lt;&gt; _precondition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous extent enumeration after a preceding operation.  <a href="group__extents.html#gaa1d7fb95799bf5d7ec7539fbcecf7b3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; off_t, <br class="typebreak"/>
off_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extents.html#ga4d97d2fad2c4746bffcab6976fb20b0c">boost::afio::extents</a> (future&lt;&gt; _precondition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous extent enumeration after a preceding operation.  <a href="group__extents.html#ga4d97d2fad2c4746bffcab6976fb20b0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; off_t, <br class="typebreak"/>
off_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extents.html#ga9a678dff8fe43f8ee7129889d96ae9e9">boost::afio::extents</a> (error_code &amp;_ec, future&lt;&gt; _precondition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous extent enumeration after a preceding operation.  <a href="group__extents.html#ga9a678dff8fe43f8ee7129889d96ae9e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; statfs_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__statfs.html#ga515e321b6ca7e791b4d19f58e81dd2ad">boost::afio::async_statfs</a> (future&lt;&gt; _precondition, fs_metadata_flags req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous volume enumeration after a preceding operation.  <a href="group__statfs.html#ga515e321b6ca7e791b4d19f58e81dd2ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">statfs_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__statfs.html#ga4be685a830245024b35e663728ef8ca2">boost::afio::statfs</a> (future&lt;&gt; _precondition, fs_metadata_flags req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous volume enumeration after a preceding operation.  <a href="group__statfs.html#ga4be685a830245024b35e663728ef8ca2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">statfs_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__statfs.html#ga09daaa9b27e7c6fec2044dfb4e8134a9">boost::afio::statfs</a> (error_code &amp;_ec, future&lt;&gt; _precondition, fs_metadata_flags req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous volume enumeration after a preceding operation.  <a href="group__statfs.html#ga09daaa9b27e7c6fec2044dfb4e8134a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher.html#ga04542fe9f6b920fa7c4d98d1b0256bdb">boost::afio::depends</a> (future&lt;&gt; precondition, future&lt;&gt; out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make ready a future after a precondition future readies.  <a href="group__async__file__io__dispatcher.html#ga04542fe9f6b920fa7c4d98d1b0256bdb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOST_AFIO_DECL std::vector<br class="typebreak"/>
&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga9b33da2bc3cd4989446286eebb19ea70">boost::afio::utils::page_sizes</a> (bool only_actually_available=true) noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the page sizes of this architecture which is useful for calculating direct i/o multiples.  <a href="group__utils.html#ga9b33da2bc3cd4989446286eebb19ea70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga55768bbb4e68c40408d1e8e7b7ffd6bd">boost::afio::utils::file_buffer_default_size</a> () noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reasonable default size for <a class="el" href="classboost_1_1afio_1_1utils_1_1page__allocator.html" title="An STL allocator which allocates large TLB page memory.If the operating system is configured to allow...">page_allocator</a>, typically the closest page size from <a class="el" href="group__utils.html#ga9b33da2bc3cd4989446286eebb19ea70" title="Returns the page sizes of this architecture which is useful for calculating direct i/o multiples...">page_sizes()</a> to 1Mb.  <a href="group__utils.html#ga55768bbb4e68c40408d1e8e7b7ffd6bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOST_AFIO_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga1fbfc2cc5dc368f487b8d78e6ba07979">boost::afio::utils::random_fill</a> (char *buffer, size_t bytes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the buffer supplied with cryptographically strong randomness. Uses the OS kernel API.  <a href="group__utils.html#ga1fbfc2cc5dc368f487b8d78e6ba07979"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga2833abcfab4aed29c3e44abc037a1010">boost::afio::utils::to_hex_string</a> (char *out, size_t outlen, const char *_in, size_t inlen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number to a hex string. Out buffer can be same as in buffer.  <a href="group__utils.html#ga2833abcfab4aed29c3e44abc037a1010"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1afio_1_1utils.html#a8579699e78a933faad9a3615eea537ff">boost::afio::utils::to_hex_string</a> (std::string in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga4dcd0afda0bee44936aefef80a6f012f">boost::afio::utils::from_hex_string</a> (char *out, size_t outlen, const char *in, size_t inlen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a hex string to a number. Out buffer can be same as in buffer.  <a href="group__utils.html#ga4dcd0afda0bee44936aefef80a6f012f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gab190a12ca7648c31c9bd65defb23a99b">boost::afio::utils::random_string</a> (size_t randomlen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a cryptographically random string capable of being used as a filename. Essentially <a class="el" href="group__utils.html#ga1fbfc2cc5dc368f487b8d78e6ba07979" title="Fills the buffer supplied with cryptographically strong randomness. Uses the OS kernel API...">random_fill()</a> + <a class="el" href="group__utils.html#ga2833abcfab4aed29c3e44abc037a1010" title="Converts a number to a hex string. Out buffer can be same as in buffer.">to_hex_string()</a>.  <a href="group__utils.html#gab190a12ca7648c31c9bd65defb23a99b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a906037d22fbfb40d1eaf3e9bbda63fe6"></a><!-- doxytag: member="afio.hpp::calculate_large_page_allocation" ref="a906037d22fbfb40d1eaf3e9bbda63fe6" args="(size_t bytes)" -->
large_page_allocation&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::utils::detail::calculate_large_page_allocation</b> (size_t bytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d8e6b475fa688c976ab184f52f6d41c"></a><!-- doxytag: member="afio.hpp::allocate_large_pages" ref="a2d8e6b475fa688c976ab184f52f6d41c" args="(size_t bytes)" -->
BOOST_AFIO_DECL <br class="typebreak"/>
large_page_allocation&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::utils::detail::allocate_large_pages</b> (size_t bytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96d16893a45034c25d503c96c4e9890b"></a><!-- doxytag: member="afio.hpp::deallocate_large_pages" ref="a96d16893a45034c25d503c96c4e9890b" args="(void *p, size_t bytes)" -->
BOOST_AFIO_DECL void&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::utils::detail::deallocate_large_pages</b> (void *p, size_t bytes)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a19cd487eabd310dc7ac28e50092fd2c0"></a><!-- doxytag: member="afio.hpp::operator==" ref="a19cd487eabd310dc7ac28e50092fd2c0" args="(const page_allocator&lt; T &gt; &amp;, const page_allocator&lt; U &gt; &amp;) noexcept" -->
template&lt;class T , class U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::utils::operator==</b> (const page_allocator&lt; T &gt; &amp;, const page_allocator&lt; U &gt; &amp;) noexcept</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::detail::optypes</b> []</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Provides a batch asynchronous file i/o implementation based on Boost.ASIO. </p>

<p>Definition in file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a7d6cb43e029a76765081fb3a2f47187d"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_HEADERS_ONLY" ref="a7d6cb43e029a76765081fb3a2f47187d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="afio_8hpp.html#a7d6cb43e029a76765081fb3a2f47187d">BOOST_AFIO_HEADERS_ONLY</a>&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if AFIO is compiled as headers only. Defaults to 1. </p>

</div>
</div>
<a class="anchor" id="a183b5c98a87ff28a56ea3bfdbe141ee9"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_USE_BOOST_THREAD" ref="a183b5c98a87ff28a56ea3bfdbe141ee9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="afio_8hpp.html#a183b5c98a87ff28a56ea3bfdbe141ee9">BOOST_AFIO_USE_BOOST_THREAD</a>&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if AFIO is bound against Boost.Thread or the C++ 11 STL thread. Defaults to 0. </p>

</div>
</div>
<a class="anchor" id="ab5974d84a78dbcf8b072fca370f1291d"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_USE_BOOST_FILESYSTEM" ref="ab5974d84a78dbcf8b072fca370f1291d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="afio_8hpp.html#ab5974d84a78dbcf8b072fca370f1291d">BOOST_AFIO_USE_BOOST_FILESYSTEM</a>&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if AFIO is bound against Boost.Filesystem or the C++ 1z Filesystem TS. Defaults to 1 unless on VS2015 which provides a full Filesystem TS implementation. </p>

</div>
</div>
<a class="anchor" id="a5b90f4adb6bc09ca319c35c3448ee67a"></a><!-- doxytag: member="afio.hpp::ASIO_STANDALONE" ref="a5b90f4adb6bc09ca319c35c3448ee67a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="afio_8hpp.html#a5b90f4adb6bc09ca319c35c3448ee67a">ASIO_STANDALONE</a>&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if AFIO is bound against standalone ASIO or Boost.ASIO. Defaults to undefined, and therefore Boost.ASIO. </p>

</div>
</div>
<a class="anchor" id="a933046d7a31248aa271a978579ee8977"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD" ref="a933046d7a31248aa271a978579ee8977" args="(type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">inline</span> constexpr type operator&amp;(type a, type b) \
{ \
    return <span class="keyword">static_cast&lt;</span>type<span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(a) &amp; static_cast&lt;size_t&gt;(b)); \
} \
inline constexpr type operator|(type a, type b) \
{ \
    return <span class="keyword">static_cast&lt;</span>type<span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(a) | static_cast&lt;size_t&gt;(b)); \
} \
inline constexpr type operator~(type a) \
{ \
    return <span class="keyword">static_cast&lt;</span>type<span class="keyword">&gt;</span>(~static_cast&lt;<span class="keywordtype">size_t</span>&gt;(a)); \
} \
inline constexpr <span class="keywordtype">bool</span> operator!(type a) \
{ \
    return 0==<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(a); \
}
</pre></div>
<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00661">661</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4eff8ea7c1ee25af59b33fa679c9793e"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_ROUND" ref="a4eff8ea7c1ee25af59b33fa679c9793e" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_AFIO_ROUND</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">prefetch[0]=ecc_table[(i+0)*8+n]; \
          prefetch[1]=ecc_table[(i+1)*8+n]; \
          prefetch[2]=ecc_table[(i+2)*8+n]; \
          prefetch[3]=ecc_table[(i+3)*8+n]; \
          prefetch[4]=ecc_table[(i+4)*8+n]; \
          prefetch[5]=ecc_table[(i+5)*8+n]; \
          prefetch[6]=ecc_table[(i+6)*8+n]; \
          prefetch[7]=ecc_table[(i+7)*8+n]; \
          if(c[0]&amp;((unit_type)1&lt;&lt;n))\
            ecc^=prefetch[0];\
          if(c[1]&amp;((unit_type)1&lt;&lt;n))\
            ecc^=prefetch[1];\
          if(c[2]&amp;((unit_type)1&lt;&lt;n))\
            ecc^=prefetch[2];\
          if(c[3]&amp;((unit_type)1&lt;&lt;n))\
            ecc^=prefetch[3];\
          if(c[4]&amp;((unit_type)1&lt;&lt;n))\
            ecc^=prefetch[4];\
          if(c[5]&amp;((unit_type)1&lt;&lt;n))\
            ecc^=prefetch[5];\
          if(c[6]&amp;((unit_type)1&lt;&lt;n))\
            ecc^=prefetch[6];\
          if(c[7]&amp;((unit_type)1&lt;&lt;n))\
            ecc^=prefetch[7];
</pre></div>
</div>
</div>
</div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>January, 2014</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2013-2014 Niall Douglas, Cork, Ireland<br>
Copyright &copy; 2013 Paul Kirth, California<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
