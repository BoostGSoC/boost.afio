<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.AFIO</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.AFIO" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li class="current"><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Class List</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock">Here are the classes, structs, unions and interfaces with brief descriptions:</div><table>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1afio_1_1current__dispatcher__guard.html">boost::afio::current_dispatcher_guard</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1__is__not__handle.html">boost::afio::detail::_is_not_handle&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1__is__not__handle_3_01future_3_01_t_01_4_01_4.html">boost::afio::detail::_is_not_handle&lt; future&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1__is__not__handle_3_01handle__ptr_01_4.html">boost::afio::detail::_is_not_handle&lt; handle_ptr &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__close.html">boost::afio::detail::async_close</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__dir.html">boost::afio::detail::async_dir&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__enumerate.html">boost::afio::detail::async_enumerate</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__extents.html">boost::afio::detail::async_extents</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__file.html">boost::afio::detail::async_file&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__file__io__dispatcher__rwconverter.html">boost::afio::detail::async_file_io_dispatcher_rwconverter&lt; iswrite, T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__read.html">boost::afio::detail::async_read</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__rmdir.html">boost::afio::detail::async_rmdir&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__rmfile.html">boost::afio::detail::async_rmfile&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__rmsymlink.html">boost::afio::detail::async_rmsymlink&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__statfs.html">boost::afio::detail::async_statfs</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__symlink.html">boost::afio::detail::async_symlink&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__sync.html">boost::afio::detail::async_sync</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__truncate.html">boost::afio::detail::async_truncate</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__write.html">boost::afio::detail::async_write</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__zero.html">boost::afio::detail::async_zero</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1container__to__asio__buffers__helper.html">boost::afio::detail::container_to_asio_buffers_helper&lt; R, C, T, is_const, is_trivial &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1container__to__asio__buffers__helper_3_01_r_00_01std_1_1array_31d265f3bd056d3edf5412f1bb8b25367.html">boost::afio::detail::container_to_asio_buffers_helper&lt; R, std::array&lt; T, N &gt;, _T, is_const, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1container__to__asio__buffers__helper_3_01_r_00_01std_1_1basic__5b83d962173a868180c70129e7984b44.html">boost::afio::detail::container_to_asio_buffers_helper&lt; R, std::basic_string&lt; C, T, A &gt;, _Ct, is_const, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1container__to__asio__buffers__helper_3_01_r_00_01std_1_1vector_08cceb32b20cab5c10bc02eea27ecdef.html">boost::afio::detail::container_to_asio_buffers_helper&lt; R, std::vector&lt; T, A &gt;, _T, is_const, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1do__continuation.html">boost::afio::detail::do_continuation&lt; future_type, promise_type &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1do__continuation_3_01future_3_01_r_01_4_00_01void_01_4.html">boost::afio::detail::do_continuation&lt; future&lt; R &gt;, void &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1enable__if__async__op.html">boost::afio::detail::enable_if_async_op&lt; is_all, T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1enable__if__async__op_3_01is__all_00_01future_3_01_t_01_4_01_4.html">boost::afio::detail::enable_if_async_op&lt; is_all, future&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1afio_1_1detail_1_1enqueued__task__impl.html">boost::afio::detail::enqueued_task_impl&lt; R &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1enqueued__task__impl_1_1_private.html">boost::afio::detail::enqueued_task_impl&lt; R &gt;::Private</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1afio_1_1detail_1_1io__req__impl_3_01false_01_4.html">boost::afio::detail::io_req_impl&lt; false &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1afio_1_1detail_1_1io__req__impl_3_01true_01_4.html">boost::afio::detail::io_req_impl&lt; true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1is__not__handle.html">boost::afio::detail::is_not_handle&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1make__io__req.html">boost::afio::detail::make_io_req&lt; T, is_container &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1make__io__req_3_01_t_00_01true_01_4.html">boost::afio::detail::make_io_req&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1select__when__ops__return__type.html">boost::afio::detail::select_when_ops_return_type&lt; is_all &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1select__when__ops__return__type_3_01false_01_4.html">boost::afio::detail::select_when_ops_return_type&lt; false &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, T, is_trivial, is_container &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01asio_1_1const__bufc343c227ba61700fa8c7433b21830407.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, asio::const_buffer, std::vector&lt; asio::const_buffer &gt;, false, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01asio_1_1mutable__ba628783a2410b194f4c8f9901c9e881d.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, asio::mutable_buffer, std::vector&lt; asio::mutable_buffer &gt;, false, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01std_1_1arr7698302ecba29743ef4e88d006e0ea0e.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, std::array&lt; asio::const_buffer, N &gt;, false, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01std_1_1arr71ff4d886b752dc4ea6a8a63c5132139.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, std::array&lt; asio::mutable_buffer, N &gt;, false, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01std_1_1vecf0033e923d262694df69e5de182cb274.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, std::vector&lt; asio::const_buffer &gt;, false, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01std_1_1vec015c9a1671103d5540a40db22dcf2c1f.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, std::vector&lt; asio::mutable_buffer &gt;, false, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01_t_00_01is__trivial_00_01true_01_4.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, T, is_trivial, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01_t_00_01true_00_01false_01_4.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, T, true, false &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1vs2013__variadic__overload__resolution__workaround.html">boost::afio::detail::vs2013_variadic_overload_resolution_workaround&lt; C, Args &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1when__all__state.html">boost::afio::detail::when_all_state</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1detail_1_1when__any__state.html">boost::afio::detail::when_any_state</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1afio_1_1directory__entry.html">boost::afio::directory_entry</a></td><td class="indexvalue">The abstract base class for an entry in a directory with lazily filled metadata </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1directory__entry__hash.html">boost::afio::directory_entry_hash</a></td><td class="indexvalue">A hasher for <a class="el" href="classboost_1_1afio_1_1directory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>, hashing inode and birth time (if available on this platform) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1afio_1_1dispatcher.html">boost::afio::dispatcher</a></td><td class="indexvalue">Abstract base class for dispatching file i/o asynchronously </td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1afio_1_1enqueued__task_3_01_r_07_08_4.html">boost::afio::enqueued_task&lt; R()&gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1afio_1_1enqueued__task_3_01void_07_08_4.html">boost::afio::enqueued_task&lt; void()&gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1enumerate__req.html">boost::afio::enumerate_req</a></td><td class="indexvalue">A convenience bundle of precondition, number of items to enumerate, item pattern match and metadata to prefetch </td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1afio_1_1future.html">boost::afio::future&lt; T &gt;</a></td><td class="indexvalue">The future status of a scheduled asynchronous operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1afio_1_1future_3_01void_01_4.html">boost::afio::future&lt; void &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1afio_1_1handle.html">boost::afio::handle</a></td><td class="indexvalue">The abstract base class encapsulating a platform-specific file handle </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1handle_1_1mapped__file.html">boost::afio::handle::mapped_file</a></td><td class="indexvalue">A holder of a mapped file </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1io__req.html">boost::afio::io_req&lt; T &gt;</a></td><td class="indexvalue">A convenience bundle of precondition, data and where for reading into a T as specified by its <a class="el" href="group__to__asio__buffers.html#ga772fe53eebaa2177dc53227bbef03f3f" title="Any trivial type T or STL container.">to_asio_buffers()</a> overload. Data <b>MUST</b> stay around until the operation completes </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1io__req_3_01const_01_t_01_4.html">boost::afio::io_req&lt; const T &gt;</a></td><td class="indexvalue">A convenience bundle of precondition, data and where for reading into a T as specified by its <a class="el" href="group__to__asio__buffers.html#ga772fe53eebaa2177dc53227bbef03f3f" title="Any trivial type T or STL container.">to_asio_buffers()</a> overload. Data <b>MUST</b> stay around until the operation completes </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1io__req_3_01const_01void_01_4.html">boost::afio::io_req&lt; const void &gt;</a></td><td class="indexvalue">A convenience bundle of precondition, data and where for reading into a T as specified by its <a class="el" href="group__to__asio__buffers.html#ga772fe53eebaa2177dc53227bbef03f3f" title="Any trivial type T or STL container.">to_asio_buffers()</a> overload. Data <b>MUST</b> stay around until the operation completes </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1io__req_3_01void_01_4.html">boost::afio::io_req&lt; void &gt;</a></td><td class="indexvalue">A convenience bundle of precondition, data and where for reading into a T as specified by its <a class="el" href="group__to__asio__buffers.html#ga772fe53eebaa2177dc53227bbef03f3f" title="Any trivial type T or STL container.">to_asio_buffers()</a> overload. Data <b>MUST</b> stay around until the operation completes </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1is__future.html">boost::afio::is_future&lt; T &gt;</a></td><td class="indexvalue">Trait for determining if a type is an afio::future&lt;T&gt; </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1is__future_3_01future_3_01_t_01_4_01_4.html">boost::afio::is_future&lt; future&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1lock__req.html">boost::afio::lock_req</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1afio_1_1path.html">boost::afio::path</a></td><td class="indexvalue">An AFIO filesystem path, a thin wrapper of filesystem::path used to mark when a filesystem path has been prepared for AFIO usage. Note that on Windows this exclusively refers to a case sensitive NT kernel path, not a Win32 path (Win32 paths are converted in the constructor) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1path_1_1make__absolute.html">boost::afio::path::make_absolute</a></td><td class="indexvalue">Makes a path absolute according to the current working directory </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1path__hash.html">boost::afio::path_hash</a></td><td class="indexvalue">A hasher for path </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1path__req.html">boost::afio::path_req</a></td><td class="indexvalue">A convenience bundle of path and flags, with optional precondition. Paths may be a path fragment (relative to the precondition) or absolute, in which case if necessary they are made canonical and absolute in the constructor according to the current working directory </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1path__req_1_1absolute.html">boost::afio::path_req::absolute</a></td><td class="indexvalue">Convenience tag type constructing an absolute path <a class="el" href="structboost_1_1afio_1_1path__req.html" title="A convenience bundle of path and flags, with optional precondition. Paths may be a path fragment (rel...">path_req</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1path__req_1_1relative.html">boost::afio::path_req::relative</a></td><td class="indexvalue">Convenience tag type constructing a relative path <a class="el" href="structboost_1_1afio_1_1path__req.html" title="A convenience bundle of path and flags, with optional precondition. Paths may be a path fragment (rel...">path_req</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1stat__t.html">boost::afio::stat_t</a></td><td class="indexvalue">Metadata about a directory entry </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1statfs__t.html">boost::afio::statfs_t</a></td><td class="indexvalue">Metadata about a filing system. Unsupported entries are -1 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1statfs__t_1_1f__flags__t.html">boost::afio::statfs_t::f_flags_t</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1afio_1_1std__thread__pool.html">boost::afio::std_thread_pool</a></td><td class="indexvalue">A very simple thread pool based on std::thread or boost::thread </td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1afio_1_1thread__source.html">boost::afio::thread_source</a></td><td class="indexvalue">Abstract base class for a source of thread workers </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1utils_1_1detail_1_1large__page__allocation.html">boost::afio::utils::detail::large_page_allocation</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1afio_1_1utils_1_1page__allocator.html">boost::afio::utils::page_allocator&lt; T &gt;</a></td><td class="indexvalue">An STL allocator which allocates large TLB page memory.If the operating system is configured to allow it, this type of memory is particularly efficient for doing large scale file i/o. This is because the kernel must normally convert the scatter gather buffers you pass into extended scatter gather buffers as the memory you see as contiguous may not, and probably isn't, actually be contiguous in physical memory. Regions returned by this allocator <em>may</em> be allocated contiguously in physical memory and therefore the kernel can pass through your scatter gather buffers unmodified </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1utils_1_1page__allocator_1_1rebind.html">boost::afio::utils::page_allocator&lt; T &gt;::rebind&lt; U &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1afio_1_1utils_1_1page__allocator_3_01void_01_4.html">boost::afio::utils::page_allocator&lt; void &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1afio_1_1utils_1_1page__allocator_3_01void_01_4_1_1rebind.html">boost::afio::utils::page_allocator&lt; void &gt;::rebind&lt; U &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1afio_1_1utils_1_1secded__ecc.html">boost::afio::utils::secded_ecc&lt; blocksize &gt;</a></td><td class="indexvalue">Calculates the single error correcting double error detecting (SECDED) Hamming Error Correcting Code for a <em>blocksize</em> block of bytes. For example, a secdec_ecc&lt;8&gt; would be the very common 72,64 Hamming code used in ECC RAM, or secdec_ecc&lt;4096&gt; would be for a 32784,32768 Hamming code </td></tr>
  <tr><td class="indexkey"><a class="el" href="classenqueued__task.html">enqueued_task</a></td><td class="indexvalue">Effectively our own custom std::packaged_task&lt;&gt;, with copy semantics and letting us early set value to significantly improve performance </td></tr>
  <tr><td class="indexkey"><a class="el" href="structstd_1_1hash_3_01boost_1_1afio_1_1directory__entry_01_4.html">std::hash&lt; boost::afio::directory_entry &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structstd_1_1hash_3_01boost_1_1afio_1_1path_01_4.html">std::hash&lt; boost::afio::path &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classstd_1_1true__type.html">true_type</a></td><td class="indexvalue"></td></tr>
</table>
</div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>January, 2014</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2013-2014 Niall Douglas, Cork, Ireland<br>
Copyright &copy; 2013 Paul Kirth, California<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
