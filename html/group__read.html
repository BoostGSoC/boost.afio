<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.AFIO</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.AFIO" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Reading data</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">virtual std::vector&lt; future&lt;&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga2574eb88fe3088715f46736fb6d1e6b0">boost::afio::dispatcher::read</a> (const std::vector&lt; io_req&lt; T &gt;&gt; &amp;ops)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous data reads after preceding operations, where offset and total data read must not exceed the present file size.  <a href="#ga2574eb88fe3088715f46736fb6d1e6b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#gadc1b927777732d065474d845c9d64af8">boost::afio::async_read</a> (future&lt;&gt; _precondition, T &amp;&amp;v, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous data read after a preceding operation, where offset and total data read must not exceed the present file size.  <a href="#gadc1b927777732d065474d845c9d64af8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga91eefbeec03a2cbf2f7b0faa82c937b8">boost::afio::async_read</a> (future&lt;&gt; _precondition, T &amp;&amp;v, size_t _length, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous data read after a preceding operation, where offset and total data read must not exceed the present file size.  <a href="#ga91eefbeec03a2cbf2f7b0faa82c937b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga4e992fe38f62d94b84819c17285a5fa9">boost::afio::read</a> (future&lt;&gt; _precondition, T &amp;&amp;v, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous data read after a preceding operation, where offset and total data read must not exceed the present file size.  <a href="#ga4e992fe38f62d94b84819c17285a5fa9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#gaf83812504911011ecc5ca2c470de9fcb">boost::afio::read</a> (future&lt;&gt; _precondition, T &amp;&amp;v, size_t _length, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous data read after a preceding operation, where offset and total data read must not exceed the present file size.  <a href="#gaf83812504911011ecc5ca2c470de9fcb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga8b1cbd7173ec175df510f34c25855917">boost::afio::read</a> (error_code &amp;_ec, future&lt;&gt; _precondition, T &amp;&amp;v, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous data read after a preceding operation, where offset and total data read must not exceed the present file size.  <a href="#ga8b1cbd7173ec175df510f34c25855917"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga76d3b26225d3f6f7ab0fcc61b16ac52f">boost::afio::read</a> (error_code &amp;_ec, future&lt;&gt; _precondition, T &amp;&amp;v, size_t _length, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous data read after a preceding operation, where offset and total data read must not exceed the present file size.  <a href="#ga76d3b26225d3f6f7ab0fcc61b16ac52f"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga2574eb88fe3088715f46736fb6d1e6b0"></a><!-- doxytag: member="boost::afio::dispatcher::read" ref="ga2574eb88fe3088715f46736fb6d1e6b0" args="(const std::vector&lt; io_req&lt; T &gt;&gt; &amp;ops)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; future&lt;&gt; &gt; <a class="el" href="group__read.html#ga2574eb88fe3088715f46736fb6d1e6b0">boost::afio::dispatcher::read</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1io__req.html">io_req</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule a batch of asynchronous data reads after preceding operations, where offset and total data read must not exceed the present file size. </p>
<p>Related types: `__afio_io_req__` Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. You should therefore assume that only each buffer is atomically read or written rather than the full sequence of buffers at once (this also applies to POSIX systems without the preadv()/pwritev() operations).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A batch of op handles. </dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">class T</td><td>Any type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ops</td><td>A batch of io_req&lt;T&gt; structures.</td></tr>
  </table>
  </dd>
</dl>
    
<p>Definition at line <a class="el" href="afio_8hpp_source.html#l03698">3698</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gadc1b927777732d065474d845c9d64af8"></a><!-- doxytag: member="boost::afio::async_read" ref="gadc1b927777732d065474d845c9d64af8" args="(future&lt;&gt; _precondition, T &amp;&amp;v, off_t _where)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">future boost::afio::async_read </td>
          <td>(</td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>_where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronous data read after a preceding operation, where offset and total data read must not exceed the present file size. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">class T</td><td>Any type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classboost_1_1afio_1_1future_3_01void_01_4.html">future&lt;void&gt;</a> </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">v</td><td>Some item understood by `to_asio_buffers()` </td></tr>
    <tr><td class="paramname">_where</td><td>The file offset to do the i/o</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, length deducing} {Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.}  {readwrite_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05028">5028</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga91eefbeec03a2cbf2f7b0faa82c937b8"></a><!-- doxytag: member="boost::afio::async_read" ref="ga91eefbeec03a2cbf2f7b0faa82c937b8" args="(future&lt;&gt; _precondition, T &amp;&amp;v, size_t _length, off_t _where)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">future boost::afio::async_read </td>
          <td>(</td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>_where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronous data read after a preceding operation, where offset and total data read must not exceed the present file size. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">class T</td><td>Any type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classboost_1_1afio_1_1future_3_01void_01_4.html">future&lt;void&gt;</a> </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">v</td><td>Some item understood by `to_asio_buffers()` </td></tr>
    <tr><td class="paramname">_length</td><td>The length of the item </td></tr>
    <tr><td class="paramname">_where</td><td>The file offset to do the i/o</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, length specifying} {Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.}  {readwrite_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05049">5049</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4e992fe38f62d94b84819c17285a5fa9"></a><!-- doxytag: member="boost::afio::read" ref="ga4e992fe38f62d94b84819c17285a5fa9" args="(future&lt;&gt; _precondition, T &amp;&amp;v, off_t _where)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void boost::afio::read </td>
          <td>(</td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>_where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous data read after a preceding operation, where offset and total data read must not exceed the present file size. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">class T</td><td>Any type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">v</td><td>Some item understood by `to_asio_buffers()` </td></tr>
    <tr><td class="paramname">_where</td><td>The file offset to do the i/o</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, length deducing throwing} {Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.}  {readwrite_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05068">5068</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaf83812504911011ecc5ca2c470de9fcb"></a><!-- doxytag: member="boost::afio::read" ref="gaf83812504911011ecc5ca2c470de9fcb" args="(future&lt;&gt; _precondition, T &amp;&amp;v, size_t _length, off_t _where)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void boost::afio::read </td>
          <td>(</td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>_where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous data read after a preceding operation, where offset and total data read must not exceed the present file size. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">class T</td><td>Any type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">v</td><td>Some item understood by `to_asio_buffers()` </td></tr>
    <tr><td class="paramname">_length</td><td>The length of the item </td></tr>
    <tr><td class="paramname">_where</td><td>The file offset to do the i/o</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, length specifying throwing} {Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.}  {readwrite_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05088">5088</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga8b1cbd7173ec175df510f34c25855917"></a><!-- doxytag: member="boost::afio::read" ref="ga8b1cbd7173ec175df510f34c25855917" args="(error_code &amp;_ec, future&lt;&gt; _precondition, T &amp;&amp;v, off_t _where)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void boost::afio::read </td>
          <td>(</td>
          <td class="paramtype">error_code &amp;&#160;</td>
          <td class="paramname"><em>_ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>_where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous data read after a preceding operation, where offset and total data read must not exceed the present file size. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">class T</td><td>Any type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_ec</td><td>Error code to set. </td></tr>
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">v</td><td>Some item understood by `to_asio_buffers()` </td></tr>
    <tr><td class="paramname">_where</td><td>The file offset to do the i/o</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, length deducing non throwing} {Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.}  {readwrite_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05108">5108</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga76d3b26225d3f6f7ab0fcc61b16ac52f"></a><!-- doxytag: member="boost::afio::read" ref="ga76d3b26225d3f6f7ab0fcc61b16ac52f" args="(error_code &amp;_ec, future&lt;&gt; _precondition, T &amp;&amp;v, size_t _length, off_t _where)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void boost::afio::read </td>
          <td>(</td>
          <td class="paramtype">error_code &amp;&#160;</td>
          <td class="paramname"><em>_ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">future&lt;&gt;&#160;</td>
          <td class="paramname"><em>_precondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>_where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous data read after a preceding operation, where offset and total data read must not exceed the present file size. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">class T</td><td>Any type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_ec</td><td>Error code to set. </td></tr>
    <tr><td class="paramname">_precondition</td><td>The precondition to use. </td></tr>
    <tr><td class="paramname">v</td><td>Some item understood by `to_asio_buffers()` </td></tr>
    <tr><td class="paramname">_length</td><td>The length of the item </td></tr>
    <tr><td class="paramname">_where</td><td>The file offset to do the i/o</td></tr>
  </table>
  </dd>
</dl>
<p>{distinguish, length specifying non throwing} {Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.}  {readwrite_example} </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l05129">5129</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>January, 2014</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2013-2014 Niall Douglas, Cork, Ireland<br>
Copyright &copy; 2013 Paul Kirth, California<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
