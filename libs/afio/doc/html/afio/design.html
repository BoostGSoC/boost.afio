<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Design Rationale</title>
<link rel="stylesheet" href="../myboostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.AFIO 0.1">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.AFIO 0.1">
<link rel="prev" href="../index.html" title="Chapter&#160;1.&#160;Boost.AFIO 0.1">
<link rel="next" href="compilation.html" title="Compilation">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="compilation.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="afio.design"></a><a class="link" href="design.html" title="Design Rationale">Design Rationale</a>
</h2></div></div></div>
<p>
      Boost.AFIO came about out of the need for a scalable, high performance, portable
      asynchronous file i/o implementation library for a forthcoming filing system
      based graph store ACID compliant persistence layer called TripleGit (with which
      I hope to implement portable Component Objects for C++ extending C++ Modules,
      which is why I am unfortunately unable to reuse <a href="http://unqlite.org/" target="_top">the
      UnQLite embedded NoSQL database engine</a> which is otherwise exactly what
      I need). The fact that one was needed at all came as a bit of a surprise: one
      thinks of these things as done and dusted decades ago, but it turns out that
      <a href="http://nikhilm.github.io/uvbook/filesystem.html" target="_top">libuv</a>,
      a C library, is good enough for most people needing asynchronous file i/o.
      However as great as libuv is, it isn't very C++-ish, and hooking it in with
      <a href="http://www.boost.org/libs/asio/" target="_top">Boost.ASIO</a> (parts of which
      are expected to enter the ISO C++ language standard) isn't particularly clean.
      I therefore resolved to write a native Boost asynchronous file i/o implementation,
      and keep it as simple as possible.
    </p>
<p>
      Boost.AFIO is actually, of course, really a different take on Google's <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3562.pdf" target="_top">WG21
      N3562 (Executors and schedulers)</a> and Microsoft's <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3634.pdf" target="_top">WG21
      N3634 (Improvements to std::future&lt;T&gt; and Related APIs)</a>. Both
      Google and Microsoft, like many other big iron C++ users, have much need to
      asynchronously execute large numbers of closures (bound function objects) with
      various dependencies between the completion of one or more closures and the
      ability to start one or more other closures. What one effectively does is to
      create a 'dependency chain' of small items to be executed, and then fire as
      many compute resources as possible at those chains, executing as many of them
      simultaneously as is permitted by the requirements of the dependency chains.
      Boost.AFIO differs from N3562 by directly extending Boost.ASIO, so if you're
      already using Boost.ASIO to do your networking, well it's a real cinch to add
      in asynchronous closure execution e.g. if a packet of data arrives, do this
      set of operations according to this dependency chain. Boost.AFIO differs from
      N3634 by going a lot further than N3634 does by having explicit support for
      both Boost.ASIO and targeted file i/o support infrastructure. Boost.AFIO therefore
      lies somewhere in between N3562 and N3634 in terms of complexity, but instead
      of specifying a new system of executors it uses Boost.ASIO as the executor.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013 Niall Douglas and Paul Kirth<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="compilation.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
