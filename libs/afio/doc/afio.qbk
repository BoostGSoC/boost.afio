[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]

[library Boost.AFIO
    [quickbook 1.7]
    [version 0.1]
    [id afio]
    [category afio]
    [authors [Douglas, Niall], [Kirth, Paul]]
    [copyright 2013 Niall Douglas and Paul Kirth]
    [purpose A batch, chainable, asynchronous closure execution engine integrated into Boost.ASIO]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [source-mode c++]
]

[def __boost__ Boost]
[def __boost_afio__ Boost.AFIO]
[def __boost_asio__ Boost.ASIO]
[def __boost_thread__ Boost.Thread]
[def __WG21_N3562__ [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3562.pdf]]
[def __WG21_N3634__ [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3634.pdf]]

[import ../test/examples/call_example.cpp]

__boost_afio__ is a scalable, batch, chainable, asynchronous closure execution engine extending __boost_asio__
and __boost_thread__ specialised as a portable and scalable asynchronous file i/o implementation
library. Implementation of this first version has been kept as simple as possible (< 1000 active
LOC) at the cost of some performance. This library was brought to __boost__ as part of Google
Summer of Code 2013.

Note that __boost_afio__ was originally written purely in C++11 and backported later to older compilers.
It requires, as an absolute minimum, a compiler with rvalue reference support. Some popular
compilers known to be minimally sufficient include:

* Microsoft Visual Studio 2010.
* GNU Compiler Collection v4.3.
* Any clang.

You may find the list of C++11 features in popular compilers at
[@http://wiki.apache.org/stdcxx/C++0xCompilerSupport] useful.

As a very quick example of minimal usage:

[call_example]

You can also schedule an asynchronous [when_all]() using [barrier]().

[include design_rationale.qbk]
[include compiling.qbk]
[include quickstart.qbk]
[include reference.qbk]
[include release_notes.qbk]
[include acknowledgments.qbk]

