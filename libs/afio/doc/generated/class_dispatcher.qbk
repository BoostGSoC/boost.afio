[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml\classboost_1_1afio_1_1dispatcher.xml]
[section:dispatcher dispatcher]
'''<?dbhtml-include href="disqus_identifiers/dispatcher.html"?>'''

'''<indexterm><primary>dispatcher</primary></indexterm>'''
Abstract base class for dispatching file i/o asynchronously. 

[heading Description]
This is a reference counted instance with platform-specific implementation in object code. Construct an instance using the [^`boost::afio::make_dispatcher()`] function.

[heading Synopsis]
``class dispatcher
      : public std::enable_shared_from_this< dispatcher >
{
  // ...
};
``

[heading Constructor(s)]
[table
[[Function] [Description] [Parameters] ]
[[``~dispatcher()``

] [Destroys the dispatcher, blocking inefficiently if any ops are still in flight. ] [

]]
]

[heading Member Function(s)]
[table
[[Function] [Description] [Parameters]  [Returns]]
[[``void testing_flags(detail::unit_testing_flags flags)``

] [] [[* detail::unit_testing_flags]: ['flags]:  



][

]
]
[[``std::shared_ptr< thread_source > threadsource()``

] [Returns the thread source used by this dispatcher. ] [

][

]
]
[[``file_flags fileflags(file_flags flags)``

] [Returns file flags as would be used after forcing and masking bits passed during construction. ] [[* file_flags]: ['flags]:  



][

]
]
[[``size_t wait_queue_depth()``

] [Returns the current wait queue depth of this dispatcher. ] [

][

]
]
[[``size_t fd_count()``

] [Returns the number of open items in this dispatcher. ] [

][

]
]
[[``std::vector< future<> > dir(const std::vector< path_req > & reqs)``

] [Schedule a batch of asynchronous directory creations and opens after optional preconditions. ] [[* const std::vector< path_req > &]: ['reqs]:  A batch of [^`path_req`] structures.



][
A batch of op handles. 

]
]
[[``std::vector< future<> > rmdir(const std::vector< path_req > & reqs)``

] [Schedule a batch of asynchronous directory deletions after optional preconditions. ] [[* const std::vector< path_req > &]: ['reqs]:  A batch of [^`path_req`] structures.



][
A batch of op handles. 

]
]
[[``std::vector< future<> > file(const std::vector< path_req > & reqs)``

] [Schedule a batch of asynchronous file creations and opens after optional preconditions. ] [[* const std::vector< path_req > &]: ['reqs]:  A batch of [^`path_req`] structures.



][
A batch of op handles. 

]
]
[[``std::vector< future<> > rmfile(const std::vector< path_req > & reqs)``

] [Schedule a batch of asynchronous file deletions after optional preconditions. ] [[* const std::vector< path_req > &]: ['reqs]:  A batch of [^`path_req`] structures.



][
A batch of op handles. 

]
]
[[``std::vector< future<> > symlink(const std::vector< path_req > & reqs, const std::vector< future<>> & targets = std::vector< future<>>())``

] [Schedule a batch of asynchronous symlink creations and opens after a precondition. ] [[* const std::vector< path_req > &]: ['reqs]:  A batch of [^`path_req`] structures. 

[* const std::vector< future<>> &]: ['targets]:  An optional batch of targets if creating symlinks.



][
A batch of op handles. 

]
]
[[``std::vector< future<> > rmsymlink(const std::vector< path_req > & reqs)``

] [Schedule a batch of asynchronous symlink deletions after optional preconditions. ] [[* const std::vector< path_req > &]: ['reqs]:  A batch of [^`path_req`] structures.



][
A batch of op handles. 

]
]
[[``std::vector< future<> > sync(const std::vector< future<>> & ops)``

] [Schedule a batch of asynchronous content synchronisations with physical storage after preceding operations. ] [[* const std::vector< future<>> &]: ['ops]:  A batch of op handles.



][
A batch of op handles. 

]
]
[[``std::vector< future<> > zero(const std::vector< future<>> & ops, const std::vector< std::vector< std::pair< off_t, off_t >>> & ranges)``

] [Schedule a batch of asynchronous zeroing and deallocations of physical storage ("hole punching") after preceding operations. ] [[* const std::vector< future<>> &]: ['ops]:  A batch of op handles. 

[* const std::vector< std::vector< std::pair< off_t, off_t >>> &]: ['ranges]:  A batch of vectors of extents to zero and deallocate.



][
A batch of op handles. 

]
]
[[``std::vector< future<> > close(const std::vector< future<>> & ops)``

] [Schedule a batch of asynchronous file or directory handle closes after preceding operations. ] [[* const std::vector< future<>> &]: ['ops]:  A batch of op handles.



][
A batch of op handles. 

]
]
[[``template<class T>
std::vector< future<> > read(const std::vector< io_req< T >> & ops)``

] [Schedule a batch of asynchronous data reads after preceding operations, where offset and total data read must not exceed the present file size. ] [[* const std::vector< io_req< T >> &]: ['ops]:  A batch of io_req<T> structures.



][
A batch of op handles. 

]
]
[[``template<class T>
std::vector< future<> > write(const std::vector< io_req< const T >> & ops)``

] [Schedule a batch of asynchronous data writes after preceding operations, where offset and total data written must not exceed the present file size. ] [[* const std::vector< io_req< const T >> &]: ['ops]:  A batch of io_req<const T> structures.



][
A batch of op handles. 

]
]
[[``std::vector< future<> > truncate(const std::vector< future<>> & ops, const std::vector< off_t > & sizes)``

] [Schedule a batch of asynchronous file length truncations after preceding operations. ] [[* const std::vector< future<>> &]: ['ops]:  A batch of op handles. 

[* const std::vector< off_t > &]: ['sizes]:  A batch of new lengths.



][
A batch of op handles. 

]
]
[[``std::vector< future< std::pair< std::vector< directory_entry >, bool > > > enumerate(const std::vector< enumerate_req > & reqs)``

] [Schedule a batch of asynchronous directory enumerations after preceding operations. ] [[* const std::vector< enumerate_req > &]: ['reqs]:  A batch of enumeration requests.



][
A batch of stl_future vectors of directory entries with boolean returning false if done. 

]
]
[[``std::vector< future< std::vector< std::pair< off_t, off_t > > > > extents(const std::vector< future<>> & ops)``

] [Schedule a batch of asynchronous extent enumerations after preceding operations. ] [[* const std::vector< future<>> &]: ['ops]:  A batch of op handles.



][
A batch of stl_future vectors of extents. 

]
]
[[``std::vector< future< statfs_t > > statfs(const std::vector< future<>> & ops, const std::vector< fs_metadata_flags > & reqs)``

] [Schedule a batch of asynchronous volume enumerations after preceding operations. ] [[* const std::vector< future<>> &]: ['ops]:  A batch of op handles. 

[* const std::vector< fs_metadata_flags > &]: ['reqs]:  A batch of metadata requests.



][
A batch of stl_future volume metadatas. 

]
]
[[``future depends(future<> precondition, future<> op)``

] [Schedule the return of an op handle after another op handle completes. This is useful when you need to supply one op handle to a function but it must not begin until another op handle has finished. ] [[* future<>]: ['precondition]:  The op handle which must complete for op to be passed through. 

[* future<>]: ['op]:  The op handle to return.



][
The op handle op. 

]
]
[[``void complete_async_op(size_t id, handle_ptr h, exception_ptr e = exception_ptr())``

] [Completes an operation with a handle or an error, usually used when an operation was previously deferred. ] [[* size_t]: ['id]:  

[* handle_ptr]: ['h]:  

[* exception_ptr]: ['e]:  



][

]
]
[[``void complete_async_op(size_t id, exception_ptr e)``

] [Completes an operation with an error, usually used when an operation was previously deferred. ] [[* size_t]: ['id]:  

[* exception_ptr]: ['e]:  



][

]
]
[[``template<class T>
std::vector< future<> > read(const std::vector< io_req< T >> & ops)``

] [] [[* const std::vector< io_req< T >> &]: ['ops]:  



][

]
]
[[``template<class T>
std::vector< future<> > write(const std::vector< io_req< T >> & ops)``

] [] [[* const std::vector< io_req< T >> &]: ['ops]:  



][

]
]
]

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[/ link afio.reference.functions.async_file_io_dispatcher `async_file_io_dispatcher()`]
[/ include generated/group_dispatcher__filter.qbk]
[/ include generated/group_dispatcher__completion.qbk]
[/ include generated/group_dispatcher__call.qbk]
[include generated/group_dispatcher__filedirops.qbk]
[include generated/group_dispatcher__enumerate.qbk]
[include generated/group_dispatcher__extents.qbk]
[include generated/group_dispatcher__statfs.qbk]
[/ include generated/group_dispatcher__depends.qbk]
[/ include generated/group_dispatcher__barrier.qbk]
[include generated/group_dispatcher__misc.qbk]

'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

