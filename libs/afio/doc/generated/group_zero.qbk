[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml\group__zero.xml]
[section:zero_2_batch zero (batch)]
'''<?dbhtml-include href="disqus_identifiers/zero_2_batch.html"?>'''

'''<indexterm><primary>zero</primary></indexterm>'''
Schedule a batch of asynchronous zeroing and deallocations of physical storage ("hole punching") after preceding operations. 

[heading Description]
Most extent based filing systems provide an optimised way of zeroing parts of a file by deallocating the storage backing those regions, and marking those regions as unwritten instead of actually writing zero bytes to storage. They appear as zeroes to anything reading those ranges, and have the big advantage of not consuming any actual physical storage. On Windows, extent deallocation writes zeros for ordinary files and only actually deallocates physical storage if the file is sparse or compressed (note that AFIO by default creates sparse files where possible, and converts any file opened for writing to a sparse file). For your information, deallocation on NTFS is on a 64Kb granularity, but the zeros are written at a byte granularity. On Linux, an attempt is made to use FALLOC\u005fFL\u005fPUNCH\u005fHOLE which if it fails then a write of zeros corresponding to the same ranges is made instead. On FreeBSD, long runs of zeros are automatically detected and eliminated on physical storage, and so zeros are simply written. On OS X, there is no formal hole punching API that we are aware of, and so zeros are simply written.

[heading Synopsis]
``future dispatcher::zero(const std::vector< future<>> & ops, const std::vector< std::vector< std::pair< off_t, off_t >>> & ranges)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const std::vector< future<>> &] [] [ops] [A batch of op handles. ]]
[[const std::vector< std::vector< std::pair< off_t, off_t >>> &] [] [ranges] [A batch of vectors of extents to zero and deallocate.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if deallocation is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][extents_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_zero async_zero]
'''<?dbhtml-include href="disqus_identifiers/async_zero.html"?>'''

'''<indexterm><primary>async_zero</primary></indexterm>'''
Asynchronous zeroing and deallocation of physical storage ("hole punching") after a preceding operation. 

[heading Description]
Most extent based filing systems provide an optimised way of zeroing parts of a file by deallocating the storage backing those regions, and marking those regions as unwritten instead of actually writing zero bytes to storage. They appear as zeroes to anything reading those ranges, and have the big advantage of not consuming any actual physical storage. On Windows, extent deallocation writes zeros for ordinary files and only actually deallocates physical storage if the file is sparse or compressed (note that AFIO by default creates sparse files where possible, and converts any file opened for writing to a sparse file). For your information, deallocation on NTFS is on a 64Kb granularity, but the zeros are written at a byte granularity. On Linux, an attempt is made to use FALLOC\u005fFL\u005fPUNCH\u005fHOLE which if it fails then a write of zeros corresponding to the same ranges is made instead. On FreeBSD, long runs of zeros are automatically detected and eliminated on physical storage, and so zeros are simply written. On OS X, there is no formal hole punching API that we are aware of, and so zeros are simply written.

[heading Synopsis]
``future async_zero(future<> _precondition, std::vector< std::pair< off_t, off_t >> ranges)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[std::vector< std::pair< off_t, off_t >>] [] [ranges] [A sequence of extents to zero and deallocate]]
]


[heading Returns]
A future<void>

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if deallocation is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][extents_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:zero_2_throwing zero (throwing)]
'''<?dbhtml-include href="disqus_identifiers/zero_2_throwing.html"?>'''

'''<indexterm><primary>zero</primary></indexterm>'''
Synchronous zeroing and deallocation of physical storage ("hole punching") after a preceding operation. 

[heading Description]
Most extent based filing systems provide an optimised way of zeroing parts of a file by deallocating the storage backing those regions, and marking those regions as unwritten instead of actually writing zero bytes to storage. They appear as zeroes to anything reading those ranges, and have the big advantage of not consuming any actual physical storage. On Windows, extent deallocation writes zeros for ordinary files and only actually deallocates physical storage if the file is sparse or compressed (note that AFIO by default creates sparse files where possible, and converts any file opened for writing to a sparse file). For your information, deallocation on NTFS is on a 64Kb granularity, but the zeros are written at a byte granularity. On Linux, an attempt is made to use FALLOC\u005fFL\u005fPUNCH\u005fHOLE which if it fails then a write of zeros corresponding to the same ranges is made instead. On FreeBSD, long runs of zeros are automatically detected and eliminated on physical storage, and so zeros are simply written. On OS X, there is no formal hole punching API that we are aware of, and so zeros are simply written.

[heading Synopsis]
``void zero(future<> _precondition, std::vector< std::pair< off_t, off_t >> ranges)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[std::vector< std::pair< off_t, off_t >>] [] [ranges] [A sequence of extents to zero and deallocate]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if deallocation is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][extents_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:zero_3_non_throwing zero (non throwing)]
'''<?dbhtml-include href="disqus_identifiers/zero_3_non_throwing.html"?>'''

'''<indexterm><primary>zero</primary></indexterm>'''
Synchronous zeroing and deallocation of physical storage ("hole punching") after a preceding operation. 

[heading Description]
Most extent based filing systems provide an optimised way of zeroing parts of a file by deallocating the storage backing those regions, and marking those regions as unwritten instead of actually writing zero bytes to storage. They appear as zeroes to anything reading those ranges, and have the big advantage of not consuming any actual physical storage. On Windows, extent deallocation writes zeros for ordinary files and only actually deallocates physical storage if the file is sparse or compressed (note that AFIO by default creates sparse files where possible, and converts any file opened for writing to a sparse file). For your information, deallocation on NTFS is on a 64Kb granularity, but the zeros are written at a byte granularity. On Linux, an attempt is made to use FALLOC\u005fFL\u005fPUNCH\u005fHOLE which if it fails then a write of zeros corresponding to the same ranges is made instead. On FreeBSD, long runs of zeros are automatically detected and eliminated on physical storage, and so zeros are simply written. On OS X, there is no formal hole punching API that we are aware of, and so zeros are simply written.

[heading Synopsis]
``void zero(error_code & _ec, future<> _precondition, std::vector< std::pair< off_t, off_t >> ranges)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[error_code &] [] [_ec] [Error code to set. ]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[std::vector< std::pair< off_t, off_t >>] [] [ranges] [A sequence of extents to zero and deallocate]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if deallocation is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][extents_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

