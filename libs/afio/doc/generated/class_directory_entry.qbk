[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml\classboost_1_1afio_1_1directory__entry.xml]
[section:directory_entry directory_entry]
'''<?dbhtml-include href="disqus_identifiers/directory_entry.html"?>'''

'''<indexterm><primary>directory_entry</primary></indexterm>'''
The abstract base class for an entry in a directory with lazily filled metadata. 

[heading Description]
Note that [^`directory_entry_hash`] will hash one of these for you, and a [^`std::hash<``directory_entry``>`] specialisation is defined for you so you ought to be able to use directory\u005fentry directly in an [^`unordered_map<>`].

See [^`__afio_stat_t__`] for explanations of the fields.

[heading Synopsis]
``class directory_entry
{
  // ...
};
``

[heading Constructor(s)]
[table
[[Function] [Description] [Parameters] ]
[[``directory_entry()``

] [Default constructor. ] [

]]
[[``directory_entry(path::string_type _leafname, stat_t __stat, metadata_flags _have_metadata)``

] [Default constructor. ] [[* path::string_type]: ['_leafname]:  

[* stat_t]: ['__stat]:  

[* metadata_flags]: ['_have_metadata]:  



]]
[[``directory_entry(const directory_entry & )``

] [] [[* const directory_entry &]: [']:  



]]
[[``directory_entry(directory_entry && o)``

] [] [[* directory_entry &&]: ['o]:  



]]
]

[heading Member Function(s)]
[table
[[Function] [Description] [Parameters]  [Returns]]
[[``directory_entry & operator=(const directory_entry & )``

] [] [[* const directory_entry &]: [']:  



][

]
]
[[``directory_entry & operator=(directory_entry && o)``

] [] [[* directory_entry &&]: ['o]:  



][

]
]
[[``bool operator==(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  



][

]
]
[[``bool operator!=(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  



][

]
]
[[``bool operator<(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  



][

]
]
[[``bool operator<=(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  



][

]
]
[[``bool operator>(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  



][

]
]
[[``bool operator>=(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  



][

]
]
[[``path::string_type name()``

] [] [

][
The name of the directory entry. May be empty if the file is deleted. 

]
]
[[``metadata_flags metadata_ready()``

] [] [

][
A bitfield of what metadata is ready right now 

]
]
[[``metadata_flags fetch_metadata(handle_ptr dirh, metadata_flags wanted)``

] [Fetches the specified metadata, returning that newly available. This is a blocking call if wanted metadata is not yet ready. Note that if the call blocks and the leafname no longer exists or the directory handle is null, an exception is thrown. ] [[* handle_ptr]: ['dirh]:  An open handle to the entry's containing directory. You can get this from an op ref using dirop.get_handle(). 

[* metadata_flags]: ['wanted]:  A bitfield of the metadata to fetch. This does not replace existing metadata. 



][
The metadata now available in this directory entry. 

]
]
[[``stat_t fetch_lstat(handle_ptr dirh, metadata_flags wanted = directory_entry::metadata_fastpath())``

] [Returns a copy of the internal [^`stat_t`] structure. This is a blocking call if wanted metadata is not yet ready. Note that if the call blocks and the leafname no longer exists or the directory handle is null, an exception is thrown. ] [[* handle_ptr]: ['dirh]:  An open handle to the entry's containing directory. You can get this from an op ref using dirop.get_handle(). 

[* metadata_flags]: ['wanted]:  A bitfield of the metadata to fetch. This does not replace existing metadata. 



][
A copy of the internal [^`stat_t`] structure. 

]
]
[[``fieldtype st_dev(handle_ptr dirh = handle_ptr())``

] [Returns st_dev. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``fieldtype st_ino(handle_ptr dirh = handle_ptr())``

] [Returns st_ino. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``fieldtype st_type(handle_ptr dirh = handle_ptr())``

] [Returns st_type. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``fieldtype st_perms(handle_ptr dirh = handle_ptr())``

] [Returns st_perms. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``fieldtype st_nlink(handle_ptr dirh = handle_ptr())``

] [Returns st_nlink. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``fieldtype st_uid(handle_ptr dirh = handle_ptr())``

] [Returns st_uid. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``fieldtype st_gid(handle_ptr dirh = handle_ptr())``

] [Returns st_gid. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``fieldtype st_rdev(handle_ptr dirh = handle_ptr())``

] [Returns st_rdev. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``fieldtype st_atim(handle_ptr dirh = handle_ptr())``

] [Returns st_atim. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``fieldtype st_mtim(handle_ptr dirh = handle_ptr())``

] [Returns st_mtim. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``fieldtype st_ctim(handle_ptr dirh = handle_ptr())``

] [Returns st_ctim. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``fieldtype st_size(handle_ptr dirh = handle_ptr())``

] [Returns st_size. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``fieldtype st_allocated(handle_ptr dirh = handle_ptr())``

] [Returns st_allocated. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``fieldtype st_blocks(handle_ptr dirh = handle_ptr())``

] [Returns st_blocks. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``fieldtype st_blksize(handle_ptr dirh = handle_ptr())``

] [Returns st_blksize. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``fieldtype st_flags(handle_ptr dirh = handle_ptr())``

] [Returns st_flags. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``fieldtype st_gen(handle_ptr dirh = handle_ptr())``

] [Returns st_gen. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``fieldtype st_birthtim(handle_ptr dirh = handle_ptr())``

] [Returns st_birthtim. ] [[* handle_ptr]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.get_handle(). 



][

]
]
[[``metadata_flags metadata_supported()``

] [A bitfield of what metadata is available on this platform. This doesn't mean all is available for every filing system. ] [

][

]
]
[[``metadata_flags metadata_fastpath()``

] [A bitfield of what metadata is fast on this platform. This doesn't mean all is available for every filing system. ] [

][

]
]
[[``size_t compatibility_maximum()``

] [The maximum number of entries which is "usual" to fetch at once i.e. what your libc does. ] [

][

]
]
]

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[include generated/struct_directory_entry_hash.qbk]

'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

