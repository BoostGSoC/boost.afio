[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.0, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml\classboost_1_1afio_1_1async__file__io__dispatcher__base.xml]
[section:async_file_io_dispatcher_base async_file_io_dispatcher_base]

'''<indexterm><primary>async_file_io_dispatcher_base</primary></indexterm>'''
Abstract base class for dispatching file i/o asynchronously. 

[heading Synopsis]
``class async_file_io_dispatcher_base
      : public std::enable_shared_from_this< async_file_io_dispatcher_base >
{
  // ...
};
``

[heading Constructor(s)]
[table
[[Function] [Description] [Parameters] ]
[[``~async_file_io_dispatcher_base()``

] [Destroys the dispatcher, blocking inefficiently if any ops are still in flight. ] [


]]
]

[heading Member Function(s)]
[table
[[Function] [Description] [Parameters]  [Returns]]
[[``thread_pool & threadpool()``

] [Returns the thread pool used by this dispatcher. ] [


]]
[[``file_flags fileflags(file_flags flags)``

] [Returns file flags as would be used after forcing and masking. ] [[* file_flags]: ['flags]:  




]]
[[``size_t wait_queue_depth()``

] [Returns the current wait queue depth of this dispatcher. ] [


]]
[[``size_t count()``

] [Returns the number of open items in this dispatcher. ] [


]]
[[``std::vector< async_io_op > completion(const std::vector< async_io_op > & ops, const std::vector< std::pair< async_op_flags, std::function< async_file_io_dispatcher_base::completion_t >>> & callbacks)``

] [Invoke the specified function when each of the supplied operations complete. ] [[* const std::vector< async_io_op > &]: ['ops]:  

[* const std::vector< std::pair< async_op_flags, std::function< async_file_io_dispatcher_base::completion_t >>> &]: ['callbacks]:  




]]
[[``async_io_op completion(const async_io_op & req, const std::pair< async_op_flags, std::function< async_file_io_dispatcher_base::completion_t >> & callback)``

] [Invoke the specified function when the supplied operation completes. ] [[* const async_io_op &]: ['req]:  

[* const std::pair< async_op_flags, std::function< async_file_io_dispatcher_base::completion_t >> &]: ['callback]:  




]]
[[``template<class R>
std::pair< std::vector< future< R > >, std::vector< async_io_op > > call(const std::vector< async_io_op > & ops, const std::vector< std::function< R()>> & callables)``

] [Schedule a batch of asynchronous invocations of the specified bound functions when their supplied preconditions complete.  ] [[* const std::vector< async_io_op > &]: ['ops]:  A batch of precondition op handles. If default constructed, a precondition is null. 

[* const std::vector< std::function< R()>> &]: ['callables]:  A batch of bound functions to call, returning R.



][
A pair with a batch of futures returning the result of each of the callables and a batch of op handles. 


]]
[[``template<class R>
std::pair< std::vector< future< R > >, std::vector< async_io_op > > call(const std::vector< std::function< R()>> & callables)``

] [Schedule a batch of asynchronous invocations of the specified bound functions when their supplied preconditions complete. ] [[* const std::vector< std::function< R()>> &]: ['callables]:  A batch of bound functions to call, returning R.



][
A pair with a batch of futures returning the result of each of the callables and a batch of op handles. 


]]
[[``template<class R>
std::pair< future< R >, async_io_op > call(const async_io_op & req, std::function< R()> callback)``

] [Schedule an asynchronous invocation of the specified bound function when its supplied precondition completes. ] [[* const async_io_op &]: ['req]:  A precondition op handle. If default constructed, the precondition is null. 

[* std::function< R()>]: ['callback]:  A bound functions to call, returning R.



][
A pair with a future returning the result of the callable and an op handle. 


]]
[[``template<class C, class... Args>
std::pair< future< typename std::result_of< C(Args...)>::type >, async_io_op > call(const async_io_op & req, C callback, Args... args)``

] [Schedule an asynchronous invocation of the specified unbound callable when its supplied precondition completes. Note that this function essentially calls [^`std::bind()`] on the callable and the args and passes it to the other call() overload taking a [^`std::function<>`]. You should therefore use [^`std::ref()`] etc. as appropriate. ] [[* const async_io_op &]: ['req]:  A precondition op handle. If default constructed, the precondition is null. 

[* C]: ['callback]:  An unbound callable to call. 

[* Args...]: ['args]:  An arbitrary sequence of arguments to bind to the callable.



][
A pair with a future returning the result of the callable and an op handle. 


]]
[[``std::vector< async_io_op > dir(const std::vector< async_path_op_req > & reqs)``

] [Asynchronously creates directories. ] [[* const std::vector< async_path_op_req > &]: ['reqs]:  




]]
[[``async_io_op dir(const async_path_op_req & req)``

] [Asynchronously creates a directory. ] [[* const async_path_op_req &]: ['req]:  




]]
[[``std::vector< async_io_op > rmdir(const std::vector< async_path_op_req > & reqs)``

] [Asynchronously deletes directories. ] [[* const std::vector< async_path_op_req > &]: ['reqs]:  




]]
[[``async_io_op rmdir(const async_path_op_req & req)``

] [Asynchronously deletes a directory. ] [[* const async_path_op_req &]: ['req]:  




]]
[[``std::vector< async_io_op > file(const std::vector< async_path_op_req > & reqs)``

] [Asynchronously opens or creates files. ] [[* const std::vector< async_path_op_req > &]: ['reqs]:  




]]
[[``async_io_op file(const async_path_op_req & req)``

] [Asynchronously opens or creates a file. ] [[* const async_path_op_req &]: ['req]:  




]]
[[``std::vector< async_io_op > rmfile(const std::vector< async_path_op_req > & reqs)``

] [Asynchronously deletes files. ] [[* const std::vector< async_path_op_req > &]: ['reqs]:  




]]
[[``async_io_op rmfile(const async_path_op_req & req)``

] [Asynchronously deletes files. ] [[* const async_path_op_req &]: ['req]:  




]]
[[``std::vector< async_io_op > sync(const std::vector< async_io_op > & ops)``

] [Asynchronously synchronises items with physical storage once they complete. ] [[* const std::vector< async_io_op > &]: ['ops]:  




]]
[[``async_io_op sync(const async_io_op & req)``

] [Asynchronously synchronises an item with physical storage once it completes. ] [[* const async_io_op &]: ['req]:  




]]
[[``std::vector< async_io_op > close(const std::vector< async_io_op > & ops)``

] [Asynchronously closes connections to items once they complete. ] [[* const std::vector< async_io_op > &]: ['ops]:  




]]
[[``async_io_op close(const async_io_op & req)``

] [Asynchronously closes the connection to an item once it completes. ] [[* const async_io_op &]: ['req]:  




]]
[[``std::vector< async_io_op > read(const std::vector< async_data_op_req< void >> & ops)``

] [Asynchronously reads data from items. ] [[* const std::vector< async_data_op_req< void >> &]: ['ops]:  




]]
[[``async_io_op read(const async_data_op_req< void > & req)``

] [Asynchronously reads data from an item. ] [[* const async_data_op_req< void > &]: ['req]:  




]]
[[``template<class T>
std::vector< async_io_op > read(const std::vector< async_data_op_req< T >> & ops)``

] [Asynchronously reads data from items. ] [[* const std::vector< async_data_op_req< T >> &]: ['ops]:  




]]
[[``std::vector< async_io_op > write(const std::vector< async_data_op_req< const void >> & ops)``

] [Asynchronously writes data to items. ] [[* const std::vector< async_data_op_req< const void >> &]: ['ops]:  




]]
[[``async_io_op write(const async_data_op_req< const void > & req)``

] [Asynchronously writes data to an item. ] [[* const async_data_op_req< const void > &]: ['req]:  




]]
[[``template<class T>
std::vector< async_io_op > write(const std::vector< async_data_op_req< T >> & ops)``

] [Asynchronously writes data to items. ] [[* const std::vector< async_data_op_req< T >> &]: ['ops]:  




]]
[[``std::vector< async_io_op > truncate(const std::vector< async_io_op > & ops, const std::vector< off_t > & sizes)``

] [Truncates the lengths of items. ] [[* const std::vector< async_io_op > &]: ['ops]:  

[* const std::vector< off_t > &]: ['sizes]:  




]]
[[``async_io_op truncate(const async_io_op & op, off_t newsize)``

] [Truncates the length of an item. ] [[* const async_io_op &]: ['op]:  

[* off_t]: ['newsize]:  




]]
[[``std::vector< async_io_op > barrier(const std::vector< async_io_op > & ops)``

] [Completes each of the supplied ops when and only when the last of the supplied ops completes. ] [[* const std::vector< async_io_op > &]: ['ops]:  




]]
]

[heading Header]
`#include <boost/afio/afio.hpp>`

[include generated/group_async_file_io_dispatcher__call.qbk]

[endsect]

