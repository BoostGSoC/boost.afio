[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml\group__rmsymlink.xml]
[section:rmsymlink_1_batch rmsymlink (batch)]
'''<?dbhtml-include href="disqus_identifiers/rmsymlink_1_batch.html"?>'''

'''<indexterm><primary>rmsymlink</primary></indexterm>'''
Schedule a batch of asynchronous symlink deletions after optional preconditions. 

[heading Description]
Make sure you read the docs for [^`__afio_handle__::unlink()`] for important caveats. Note that on operating systems with an unstable [^`__afio_handle__::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname. Related types: [^`__afio_path_req__`]

[heading Synopsis]
``future dispatcher::rmsymlink(const std::vector< path_req > & reqs)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const std::vector< path_req > &] [] [reqs] [A batch of [^`path_req`] structures.]]
]


[heading Returns]
A batch of op handles. 

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if symlink deletion is constant time.
[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_rmsymlink_3_relative async_rmsymlink (relative)]
'''<?dbhtml-include href="disqus_identifiers/async_rmsymlink_3_relative.html"?>'''

'''<indexterm><primary>async_rmsymlink</primary></indexterm>'''
Asynchronous symlink deletion after an optional precondition. 

[heading Description]
Make sure you read the docs for [^`__afio_handle__::unlink()`] for important caveats. Note that on operating systems with an unstable [^`__afio_handle__::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
future async_rmsymlink(future<> _precondition, T _path = path(), file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Returns]
A future<void>

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink deletion is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:async_rmsymlink_2_absolute async_rmsymlink (absolute)]
'''<?dbhtml-include href="disqus_identifiers/async_rmsymlink_2_absolute.html"?>'''

'''<indexterm><primary>async_rmsymlink</primary></indexterm>'''
Asynchronous symlink deletion after an optional precondition. 

[heading Description]
Make sure you read the docs for [^`__afio_handle__::unlink()`] for important caveats. Note that on operating systems with an unstable [^`__afio_handle__::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T, typename>
future async_rmsymlink(T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[] [] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Returns]
A future<void>

[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink deletion is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:rmsymlink_3_relative_throwing rmsymlink (relative throwing)]
'''<?dbhtml-include href="disqus_identifiers/rmsymlink_3_relative_throwing.html"?>'''

'''<indexterm><primary>rmsymlink</primary></indexterm>'''
Synchronous symlink deletion after an optional precondition. 

[heading Description]
Make sure you read the docs for [^`__afio_handle__::unlink()`] for important caveats. Note that on operating systems with an unstable [^`__afio_handle__::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
void rmsymlink(future<> _precondition, T _path = path(), file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink deletion is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:rmsymlink_2_absolute_throwing rmsymlink (absolute throwing)]
'''<?dbhtml-include href="disqus_identifiers/rmsymlink_2_absolute_throwing.html"?>'''

'''<indexterm><primary>rmsymlink</primary></indexterm>'''
Synchronous symlink deletion after an optional precondition. 

[heading Description]
Make sure you read the docs for [^`__afio_handle__::unlink()`] for important caveats. Note that on operating systems with an unstable [^`__afio_handle__::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T, typename>
void rmsymlink(T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[] [] [ - ] [Must be specified]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink deletion is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:rmsymlink_4_relative_non_throwing rmsymlink (relative non throwing)]
'''<?dbhtml-include href="disqus_identifiers/rmsymlink_4_relative_non_throwing.html"?>'''

'''<indexterm><primary>rmsymlink</primary></indexterm>'''
Synchronous symlink deletion after an optional precondition. 

[heading Description]
Make sure you read the docs for [^`__afio_handle__::unlink()`] for important caveats. Note that on operating systems with an unstable [^`__afio_handle__::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T>
void rmsymlink(error_code & _ec, future<> _precondition, T _path = path(),
               file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[error_code &] [] [_ec] [Error code to set. ]]
[[future<>] [] [_precondition] [The precondition to use. ]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink deletion is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

[section:rmsymlink_3_absolute_non_throwing rmsymlink (absolute non throwing)]
'''<?dbhtml-include href="disqus_identifiers/rmsymlink_3_absolute_non_throwing.html"?>'''

'''<indexterm><primary>rmsymlink</primary></indexterm>'''
Synchronous symlink deletion after an optional precondition. 

[heading Description]
Make sure you read the docs for [^`__afio_handle__::unlink()`] for important caveats. Note that on operating systems with an unstable [^`__afio_handle__::path(true)`] you need to be cautious of deleting files by handle as any hard link to that file may be deleted instead of the one you intended. To work around this, portable code should delete by directory handle as the precondition and known leafname. Related types: [^`__afio_path_req__`] Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``template<class T, typename>
void rmsymlink(error_code & _ec, T _path, file_flags _flags = file_flags::none)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[class T] [The type of path to be used. ] [ - ] [Must be specified]]
[[] [] [ - ] [Must be specified]]
[[error_code &] [] [_ec] [Error code to set. ]]
[[T] [] [_path] [The filing system path to be used. ]]
[[file_flags] [] [_flags] [The flags to be used.]]
]


[heading Header]
`#include <boost/afio/v2/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux, OS X, Windows..No guarantees.]
 ]
[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink deletion is constant time.
[heading Exception Model]Propagates the exception of any input precondition with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Note that error code returning functions may still throw exceptions e.g. failure to allocate memory.
[heading Example][filedir_example]


'''<?dbhtml-include href="disqus_comments.html"?>'''
[endsect]

