/* handle.hpp
A handle to a file
(C) 2015 Niall Douglas http://www.nedprod.com/
File Created: Dec 2015


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOST_AFIO_HANDLE_H
#define BOOST_AFIO_HANDLE_H

#include "io_service.hpp"

BOOST_AFIO_V2_NAMESPACE_BEGIN

//! A handle to an open file
class BOOST_AFIO_DECL handle
{
  io_service *_service;
  path _path;
  unsigned _flags;
  handle(io_service *service, path path, unsigned flags) : _service(service), _path(std::move(path)), _flags(flags) { }
  // Called when a move construction occurs
  BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC void _move_construct(handle &dest) && noexcept {}
public:
  //! The file extent type used by this i/o service
  using extent_type = io_service::extent_type;
  //! The memory extent type used by this i/o service
  using size_type = io_service::size_type;
  //! The scatter buffer type used by this i/o service
  using buffer_type = io_service::buffer_type;
  //! The gather buffer type used by this i/o service
  using const_buffer_type = io_service::const_buffer_type;
  //! The scatter buffers type used by this i/o service
  using buffers_type = io_service::buffers_type;
  //! The gather buffers type used by this i/o service
  using const_buffers_type = io_service::const_buffers_type;
  //! The i/o request type used by this i/o service
  template<class T> using io_request = io_service::io_request<T>;
  //! The i/o result type used by this i/o service
  template<class T> using io_result = io_service::io_result<T>;

  //! The behaviour of the handle: does it read, read and write, or atomic append?
  enum class mode
  {
    read = 0,
    write,
    append
  };
  //! On opening, do we also create a new file or truncate an existing one?
  enum class creation
  {
    open = 0,
    only_if_not_exist,
    if_needed,
    truncate
  };
  //! Will i/o bypass the kernel's page cache and go straight to the device?
  static constexpr unsigned flag_direct = (1 << 0);
  //! Will kernel caching of i/o be write through rather than write back?
  static constexpr unsigned flag_sync = (1 << 1);
  //! Maximum flags for this io_service
  static constexpr unsigned flags_max = (1 << 2);

  //! Create a handle opening access to a file on path managed using i/o service service
  static BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC result<handle> create(io_service &service, path _path, mode _mode = mode::read, creation _creation = creation::open, unsigned flags = 0) noexcept;
  BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC ~handle();
  //! Clone this handle (copy constructor is disabled to avoid accidental copying)
  result<handle> clone() const noexcept;
  handle(const handle &o) = delete;
  handle &operator=(const handle &o) = delete;
  //! Move the handle
  handle(handle &&o) noexcept : _service(o._service), _path(std::move(o._path)), _flags(o._flags), _v(std::move(o._v))
  {
    std::move(o)._move_construct(*this);
    o._service = nullptr;
    o._flags = 0;
    o._v = 0;
  }
  handle &operator=(handle &&o) noexcept
  {
    this->~handle();
    new(this) handle(std::move(o));
    return *this;
  }
  //! The i/o service this handle is attached to
  io_service *service() const noexcept { return _service; }
protected:
  using shared_size_type = size_type;
#ifdef WIN32
  win::handle _v;
#else
  int _v;
#endif
  // Holds state for an i/o in progress. Likely will be subclassed with platform specific state.
  // Note this is allocated using malloc not new to avoid memory zeroing, and therefore it has a custom deleter.
  template<class CompletionRoutine, class BuffersType> struct _io_state_type
  {
    handle *parent;
    io_result<BuffersType> result;
    CompletionRoutine completion;
    size_t items;
    shared_size_type items_to_go;
    constexpr _io_state_type(handle *_parent, CompletionRoutine &&f, size_t _items) : parent(_parent), result(make_result(BuffersType())), completion(std::forward<CompletionRoutine>(f)), items(_items), items_to_go(0) { }
    BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC ~_io_state_type()
    {
      // i/o still pending is very bad, this should never happen
      assert(!items_to_go);
      if (items_to_go)
      {
        BOOST_AFIO_LOG_FATAL_EXIT("FATAL: io_state destructed while i/o still in flight, the derived class should never allow this." << std::endl);
        abort();
      }
    }
  };
  struct _io_state_deleter { template<class U> void operator()(U *_ptr) const { _ptr->~U(); char *ptr = (char *)_ptr; ::free(ptr); } };
public:
  /*! Smart pointer to state of an i/o in progress. Destroying this before an i/o has completed
  is <b>blocking</b> because the i/o must be cancelled before the destructor can safely exit.
  */
  template<class CompletionRoutine, class BuffersType> using io_state_ptr = std::unique_ptr<_io_state_type<CompletionRoutine, BuffersType>, _io_state_deleter>;
protected:
  template<class CompletionRoutine, class BuffersType, class IORoutine>
  result<io_state_ptr<CompletionRoutine, BuffersType>>
    _begin_io(io_request<BuffersType> reqs,
      CompletionRoutine &&completion, IORoutine &&ioroutine) noexcept;
public:
  /*! \brief Schedule a read to occur asynchronously.

  \return Either an io_state_ptr to the i/o in progress, or an error code.
  \param reqs A scatter-gather and offset request.
  \param completion A callable to call upon i/o completion. Spec is void(handle *, io_result<buffers_type> &).
  Note that buffers returned may not be buffers input.
  */
  template<class CompletionRoutine> result<io_state_ptr<CompletionRoutine, buffers_type>> async_read(io_request<buffers_type> reqs, CompletionRoutine &&completion) noexcept;

  /*! \brief Schedule a write to occur asynchronously.

  \return Either an io_state_ptr to the i/o in progress, or an error code.
  \param reqs A scatter-gather and offset request.
  \param completion A callable to call upon i/o completion. Spec is void(handle *, io_result<const_buffers_type> &).
  Note that buffers returned may not be buffers input.
  */
  template<class CompletionRoutine> result<io_state_ptr<CompletionRoutine, const_buffers_type>> async_write(io_request<const_buffers_type> reqs, CompletionRoutine &&completion) noexcept;

  /*! \brief Read data from the open file.

  \return The buffers read, which may not be the buffers input.
  \param reqs A scatter-gather and offset request.
  \param deadline An optional deadline by which the i/o must complete, else it is cancelled.
  Note function may return significantly after this deadline if the i/o takes long to cancel.
  */
  io_result<buffers_type> read(io_request<buffers_type> reqs, const std::chrono::system_clock::time_point *deadline = nullptr) noexcept;

  /*! \brief Write data to the open file.

  \return The buffers written, which may not be the buffers input.
  \param reqs A scatter-gather and offset request.
  \param deadline An optional deadline by which the i/o must complete, else it is cancelled.
  Note function may return significantly after this deadline if the i/o takes long to cancel.
  */
  io_result<const_buffers_type> write(io_request<const_buffers_type> reqs, const std::chrono::system_clock::time_point *deadline = nullptr) noexcept;

  /*! Resize the current maximum permitted extent of the file to the given extent. Note that
  on extents based filing systems this will succeed even if there is insufficient free space
  on the storage medium.
  */
  result<extent_type> truncate(extent_type newsize) noexcept;
};


BOOST_AFIO_V2_NAMESPACE_END

#if BOOST_AFIO_HEADERS_ONLY == 1 && !defined(DOXYGEN_SHOULD_SKIP_THIS)
#define BOOST_AFIO_INCLUDED_BY_HEADER 1
#include "detail/impl/handle.ipp"
#undef BOOST_AFIO_INCLUDED_BY_HEADER
#endif

#endif
