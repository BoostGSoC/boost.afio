/* handle.hpp
A handle to a file
(C) 2015 Niall Douglas http://www.nedprod.com/
File Created: Dec 2015


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOST_AFIO_HANDLE_H
#define BOOST_AFIO_HANDLE_H

#include "io_service.hpp"

BOOST_AFIO_V2_NAMESPACE_BEGIN

//! A handle to an open file
class BOOST_AFIO_DECL handle
{
public:
  //! The path type used by this handle
  using path_type = path;
  //! The file extent type used by this handle
  using extent_type = io_service::extent_type;
  //! The memory extent type used by this handle
  using size_type = io_service::size_type;
  //! The scatter buffer type used by this handle
  using buffer_type = io_service::buffer_type;
  //! The gather buffer type used by this handle
  using const_buffer_type = io_service::const_buffer_type;
  //! The scatter buffers type used by this handle
  using buffers_type = io_service::buffers_type;
  //! The gather buffers type used by this handle
  using const_buffers_type = io_service::const_buffers_type;
  //! The i/o request type used by this handle
  template<class T> using io_request = io_service::io_request<T>;
  //! The i/o result type used by this handle
  template<class T> using io_result = io_service::io_result<T>;

  //! The behaviour of the handle: does it read, read and write, or atomic append?
  enum class mode : unsigned char
  {
    unchanged=0,
    none,
    read,
    write,
    append              //!< All mainstream OSs and CIFS guarantee this is atomic with respect to all other appenders
  };
  //! On opening, do we also create a new file or truncate an existing one?
  enum class creation : unsigned char
  {
    open_existing = 0,
    only_if_not_exist,
    if_needed,
    truncate            //!< Atomically truncate on open, leaving creation date unmodified.
  };
  //! How the handle's i/o will be cached by the OS kernel
  enum class caching : unsigned char
  {
    unchanged=0,
    none,                 //!< No caching whatsoever (i.e. <tt>O_DIRECT|O_SYNC</tt>). Align all i/o to 4Kb boundaries for this to work.
    metadata,             //!< Try to avoid caching data (<tt>O_DIRECT</tt>), thus i/o here does not affect other cached data for other handles. Align all i/o to 4Kb boundaries for this to work.
    reads,                //!< Cache reads, writes do not complete until reaching storage (<tt>O_SYNC</tt>).
    reads_and_metadata,   //!< Cache reads and writes of metadata, but not writes of data (<tt>fdatasync()</tt> after every write and <tt>fsync()</tt> after every metadata change, not completing until done).
    write_soon,           //!< Cache reads and writes of data and metadata, but send writes to storage immediately (<tt>fdatasync()</tt> after every write and <tt>fsync()</tt> after every metadata change but completing before sync).
    write_later,          //!< Cache reads and writes of data and metadata, but send writes to storage at some point when the kernel decides.
    write_on_close,       //!< Cache reads and writes of data and metadata, but send writes to storage when the handle is closed/destroyed (<tt>fsync()</tt> on close/destruction if any modification was made).
    write_latest          //!< Cache reads and writes of data and metadata, but only send any writes at all to storage on last handle close in the system or if memory becomes tight (Windows only).
  };
  //! Delete the file on last handle close
  static constexpr unsigned flag_delete_on_close = (1 << 0);
protected:
  io_service *_service;
  path_type _path;
  mode _mode;
  caching _caching;
  unsigned _flags;
  handle(io_service *service, path_type path, mode mode, caching caching, unsigned flags) : _service(service), _path(std::move(path)), _mode(mode), _caching(caching), _flags(flags) { }
  // Called when a move construction occurs
  BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC void _move_construct(handle &dest) && noexcept {}
public:
  //! Create a handle opening access to a file on path managed using i/o service service
  static BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC result<handle> create(io_service &service, path _path, mode _mode = mode::read, creation _creation = creation::open_existing, caching _caching = caching::write_later, unsigned flags = 0) noexcept;
  BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC ~handle();
  //! Clone this handle (copy constructor is disabled to avoid accidental copying)
  BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC result<handle> clone(io_service &service, mode _mode=mode::unchanged, caching _caching=caching::unchanged, unsigned _flags=(unsigned)-1) const noexcept;
  handle(const handle &o) = delete;
  handle &operator=(const handle &o) = delete;
  //! Move the handle
  handle(handle &&o) noexcept : _service(o._service), _path(std::move(o._path)), _mode(o._mode), _caching(o._caching), _flags(o._flags), _v(std::move(o._v))
  {
    std::move(o)._move_construct(*this);
    o._service = nullptr;
    o._flags = 0;
    o._v = 0;
  }
  handle &operator=(handle &&o) noexcept
  {
    this->~handle();
    new(this) handle(std::move(o));
    return *this;
  }
  //! The i/o service this handle is attached to
  io_service *service() const noexcept { return _service; }
  //! The path this handle refers to
  path_type path() const noexcept { return _path; }
  //! True if the handle is readable
  bool is_readable() const noexcept { return _mode == mode::read || _mode==mode::write; }
  //! True if the handle is writable
  bool is_writable() const noexcept { return _mode == mode::write || _mode == mode::append; }
  //! True if the handle is append only
  bool is_append_only() const noexcept { return _mode == mode::append; }

  //! Kernel cache strategy used by this handle
  caching kernel_caching() const noexcept { return _caching; }
  //! True if the handle needs 4Kb aligned i/o
  bool needs_aligned_io() const noexcept { return _caching == caching::none || _caching==caching::metadata; }
  //! True if the handle uses the kernel page cache for reads
  bool are_reads_from_cache() const noexcept { return _caching == caching::write_back || _caching == caching::write_through; }
  //! True if writes are safe on completion
  bool are_writes_durable() const noexcept { return _caching == caching::none || _caching == caching::write_through; }

  //! The flags this handle was opened with
  unsigned flags() const noexcept { return _flags; }
protected:
  using shared_size_type = size_type;
#ifdef WIN32
  win::handle _v;
#else
  int _v;
#endif
  // Holds state for an i/o in progress. Likely will be subclassed with platform specific state.
  // Note this is allocated using malloc not new to avoid memory zeroing, and therefore it has a custom deleter.
  template<class CompletionRoutine, class BuffersType> struct _io_state_type
  {
    handle *parent;
    io_result<BuffersType> result;
    CompletionRoutine completion;
    size_t items;
    shared_size_type items_to_go;
    constexpr _io_state_type(handle *_parent, CompletionRoutine &&f, size_t _items) : parent(_parent), result(make_result(BuffersType())), completion(std::forward<CompletionRoutine>(f)), items(_items), items_to_go(0) { }
    BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC ~_io_state_type()
    {
      // i/o still pending is very bad, this should never happen
      assert(!items_to_go);
      if (items_to_go)
      {
        BOOST_AFIO_LOG_FATAL_EXIT("FATAL: io_state destructed while i/o still in flight, the derived class should never allow this." << std::endl);
        abort();
      }
    }
  };
  struct _io_state_deleter { template<class U> void operator()(U *_ptr) const { _ptr->~U(); char *ptr = (char *)_ptr; ::free(ptr); } };
public:
  /*! Smart pointer to state of an i/o in progress. Destroying this before an i/o has completed
  is <b>blocking</b> because the i/o must be cancelled before the destructor can safely exit.
  */
  template<class CompletionRoutine, class BuffersType> using io_state_ptr = std::unique_ptr<_io_state_type<CompletionRoutine, BuffersType>, _io_state_deleter>;
protected:
  template<class CompletionRoutine, class BuffersType, class IORoutine>
  result<io_state_ptr<CompletionRoutine, BuffersType>>
    _begin_io(io_request<BuffersType> reqs,
      CompletionRoutine &&completion, IORoutine &&ioroutine) noexcept;
  void _write_flush() noexcept;
  void _metadata_flush() noexcept;
public:
  /*! \brief Schedule a read to occur asynchronously.

  \return Either an io_state_ptr to the i/o in progress, or an error code.
  \param reqs A scatter-gather and offset request.
  \param completion A callable to call upon i/o completion. Spec is void(handle *, io_result<buffers_type> &).
  Note that buffers returned may not be buffers input.
  */
  template<class CompletionRoutine> result<io_state_ptr<CompletionRoutine, buffers_type>> async_read(io_request<buffers_type> reqs, CompletionRoutine &&completion) noexcept;

  /*! \brief Schedule a write to occur asynchronously.

  \return Either an io_state_ptr to the i/o in progress, or an error code.
  \param reqs A scatter-gather and offset request.
  \param completion A callable to call upon i/o completion. Spec is void(handle *, io_result<const_buffers_type> &).
  Note that buffers returned may not be buffers input.
  */
  template<class CompletionRoutine> result<io_state_ptr<CompletionRoutine, const_buffers_type>> async_write(io_request<const_buffers_type> reqs, CompletionRoutine &&completion) noexcept;

  /*! \brief Read data from the open file.

  \return The buffers read, which may not be the buffers input.
  \param reqs A scatter-gather and offset request.
  \param deadline An optional deadline by which the i/o must complete, else it is cancelled.
  Note function may return significantly after this deadline if the i/o takes long to cancel.
  */
  io_result<buffers_type> read(io_request<buffers_type> reqs, deadline d = deadline()) noexcept;

  /*! \brief Write data to the open file.

  \return The buffers written, which may not be the buffers input.
  \param reqs A scatter-gather and offset request.
  \param deadline An optional deadline by which the i/o must complete, else it is cancelled.
  Note function may return significantly after this deadline if the i/o takes long to cancel.
  */
  io_result<const_buffers_type> write(io_request<const_buffers_type> reqs, deadline d = deadline()) noexcept;

  /*! Resize the current maximum permitted extent of the file to the given extent. Note that
  on extents based filing systems this will succeed even if there is insufficient free space
  on the storage medium.
  */
  result<extent_type> truncate(extent_type newsize) noexcept;
};


BOOST_AFIO_V2_NAMESPACE_END

#if BOOST_AFIO_HEADERS_ONLY == 1 && !defined(DOXYGEN_SHOULD_SKIP_THIS)
#define BOOST_AFIO_INCLUDED_BY_HEADER 1
#include "detail/impl/handle.ipp"
#undef BOOST_AFIO_INCLUDED_BY_HEADER
#endif

#endif
