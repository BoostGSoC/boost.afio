/* native_handle_type.hpp
Wraps the platform specific i/o reference object
(C) 2016 Niall Douglas http://www.nedprod.com/
File Created: March 2016


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include "config.hpp"

#ifndef BOOST_AFIO_NATIVE_HANDLE_TYPE_H
#define BOOST_AFIO_NATIVE_HANDLE_TYPE_H

BOOST_AFIO_V2_NAMESPACE_BEGIN

/*! \struct native_handle_type
\brief A native handle type used for wrapping file descriptors, process ids or HANDLEs.
Unmanaged, wrap in a handle object to manage.
*/
struct native_handle_type
{
  //! The type of handle.
  BOOST_AFIO_BITFIELD_BEGIN(disposition)
  {
    invalid = 0,  //!< Invalid handle

    readable = 1 << 0,     //!< Is readable
    writable = 1 << 1,     //!< Is writable
    append_only = 1 << 2,  //!< Is append only

    overlapped = 1 << 4,  //!< Requires additional synchronisation
    seekable = 1 << 5,    //!< Is seekable
    aligned_io = 1 << 6,  //!< Requires sector aligned i/o (typically 512 or 4096)

    file = 1 << 8,          //!< Is a regular file
    directory = 1 << 9,     //!< Is a directory
    symlink = 1 << 10,      //!< Is a symlink
    multiplexer = 1 << 11,  //!< Is a kqueue/epoll/iocp
    process = 1 << 12       //! Is a child process
  }
  BOOST_AFIO_BITFIELD_END(disposition)
  disposition behaviour;  //! The behaviour of the handle
  union {
    intptr_t _init;
    int fd;         //!< A POSIX file descriptor
    int pid;        //!< A POSIX process identifier
    win::handle h;  //!< A Windows HANDLE
  };
  //! Constructs a default instance
  constexpr native_handle_type() noexcept : behaviour(), _init(-1) {}
  //! Construct from a POSIX file descriptor
  constexpr native_handle_type(disposition _behaviour, int _fd) noexcept : behaviour(_behaviour), fd(_fd) {}
  //! Construct from a Windows HANDLE
  constexpr native_handle_type(disposition _behaviour, win::handle _h) noexcept : behaviour(_behaviour), h(_h) {}

  //! Copy construct
  constexpr native_handle_type(const native_handle_type &) = default;
  //! Move construct
  BOOST_CXX14_CONSTEXPR native_handle_type(native_handle_type &&o) noexcept : behaviour(std::move(o.behaviour)), _init(std::move(o._init))
  {
    o.behaviour = disposition();
    o._init = 0;
  }
  //! Copy assign
  native_handle_type &operator=(const native_handle_type &) = default;
  //! Move assign
  native_handle_type &operator=(native_handle_type &&o) noexcept
  {
    behaviour = std::move(o.behaviour);
    _init = std::move(o._init);
    o.behaviour = disposition();
    o._init = 0;
    return *this;
  }
  //! Swaps with another instance
  void swap(native_handle_type &o) noexcept
  {
    std::swap(behaviour, o.behaviour);
    std::swap(_init, o._init);
  }

  //! True if valid
  explicit constexpr operator bool() const noexcept { return _init != -1 && static_cast<unsigned>(behaviour) != 0; }
  //! True if invalid
  constexpr bool operator!() const noexcept { return _init == -1 || static_cast<unsigned>(behaviour) == 0; }

  //! True if the handle is readable
  constexpr bool is_readable() const noexcept { return behaviour && disposition::readable; }
  //! True if the handle is writable
  constexpr bool is_writable() const noexcept { return behaviour && disposition::writable; }
  //! True if the handle is append only
  constexpr bool is_append_only() const noexcept { return behaviour && disposition::append_only; }

  //! True if overlapped
  constexpr bool is_overlapped() const noexcept { return behaviour && disposition::overlapped; }
  //! True if seekable
  constexpr bool is_seekable() const noexcept { return behaviour && disposition::seekable; }
  //! True if requires aligned i/o
  constexpr bool requires_aligned_io() const noexcept { return behaviour && disposition::aligned_io; }

  //! True if a regular file or device
  constexpr bool is_regular() const noexcept { return behaviour && disposition::file; }
  //! True if a directory
  constexpr bool is_directory() const noexcept { return behaviour && disposition::directory; }
  //! True if a symlink
  constexpr bool is_symlink() const noexcept { return behaviour && disposition::symlink; }
  //! True if a multiplexer like BSD kqueues, Linux epoll or Windows IOCP
  constexpr bool is_multiplexer() const noexcept { return behaviour && disposition::multiplexer; }
  //! True if a process
  constexpr bool is_process() const noexcept { return behaviour && disposition::process; }
};

BOOST_AFIO_V2_NAMESPACE_END


#endif
