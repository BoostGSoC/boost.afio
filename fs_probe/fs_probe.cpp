/* fs_probe.cpp
Probes the OS and filing system for various characteristics
(C) 2015 Niall Douglas http://www.nedprod.com/
File Created: Nov 2015


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

// I absolutely require min Win32 API to be Vista
#define WINVER 0x0600
#define _WIN32_WINNT 0x0600

#define _CRT_SECURE_NO_WARNINGS

#include "../test/afio_pch.hpp"
#include <vector>
#include <deque>
#include <regex>
#include <thread>
#include <tuple>
#include <iomanip>
#undef _threadid

namespace afio = boost::afio;
namespace filesystem = boost::afio::filesystem;
using afio::result;
using afio::make_result;
using afio::make_errored_result;
namespace detail
{
  template<class F> using function_ptr = boost::outcome::detail::function_ptr<F>;
  using boost::outcome::detail::make_function_ptr;
  using boost::outcome::detail::emplace_function_ptr;
}

enum class mode
{
  read = 0,
  write,
  append
};
enum class creation
{
  open = 0,
  only_if_not_exist,
  if_needed,
  truncate
};

constexpr unsigned flag_direct = (1<<0);
constexpr unsigned flag_sync = (1<<1);
constexpr unsigned permute_flags_max = 4;
constexpr unsigned flag_delete_on_close = (1<<4);
constexpr unsigned flag_no_race_protection = (1 << 5);

result<bool> io_service::run_until(const std::chrono::system_clock::time_point *deadline) noexcept
{
  if (!_work_queued)
    return false;
#ifdef WIN32
  if (GetCurrentThreadId() != _threadid)
    return make_errored_result<bool>(EOPNOTSUPP);
  std::chrono::system_clock::time_point now = std::chrono::system_clock::now();
  DWORD tosleep = INFINITE;
  if (deadline)
  {
    auto _tosleep = std::chrono::duration_cast<std::chrono::milliseconds>(*deadline - now).count();
    if (_tosleep <= 0)
      _tosleep = 0;
    tosleep = (DWORD)_tosleep;
  }
  // Execute any APCs queued to this thread
  if (!SleepEx(tosleep, true))
  {
    auto _tosleep = std::chrono::duration_cast<std::chrono::milliseconds>(*deadline - now).count();
    if (_tosleep <= 0)
      return make_errored_result<bool>(ETIMEDOUT);
  }
#else
  if (pthread_self() != _threadh)
    return make_errored_result<bool>(EOPNOTSUPP);
#error todo
#endif
  return _work_queued != 0;
}

void io_service::post(detail::function_ptr<void(io_service *)> &&f)
{
  void *data = nullptr;
  {
    post_info pi(this, std::move(f));
    std::lock_guard<decltype(_posts_lock)> g(_posts_lock);
    _posts.push_back(std::move(pi));
    data = (void *) &_posts.back();
  }
#ifdef WIN32
  PAPCFUNC apcf = [](ULONG_PTR data) {
    post_info *pi = (post_info *) data;
    pi->f(pi->service);
    pi->service->_post_done(pi);
  };
  if (QueueUserAPC(apcf, _threadh, (ULONG_PTR)data))
    _work_enqueued();
#else
#error todo
#endif
}

// A handle object
class handle
{
  io_service *_service;
  filesystem::path _path;
  unsigned _flags;
  handle(io_service *service, filesystem::path path, unsigned flags) : _service(service), _path(std::move(path)), _flags(flags) { }
public:
  //! The file extent type used by this i/o service
  using extent_type = io_service::extent_type;
  //! The memory extent type used by this i/o service
  using size_type = io_service::size_type;
  //! The scatter buffer type used by this i/o service
  using buffer_type = io_service::buffer_type;
  //! The gather buffer type used by this i/o service
  using const_buffer_type = io_service::const_buffer_type;
  //! The scatter buffers type used by this i/o service
  using buffers_type = io_service::buffers_type;
  //! The gather buffers type used by this i/o service
  using const_buffers_type = io_service::const_buffers_type;
  //! The i/o request type used by this i/o service
  template<class T> using io_request = io_service::io_request<T>;
  //! The i/o result type used by this i/o service
  template<class T> using io_result = io_service::io_result<T>;

  handle(handle &&o) noexcept : _service(o._service), _path(std::move(o._path)), _flags(o._flags), _v(std::move(o._v))
  {
    o._service = nullptr;
    o._flags = 0;
    o._v = 0;
  }
  handle &operator=(handle &&o) noexcept
  {
    this->~handle();
    new(this) handle(std::move(o));
    return *this;
  }
  //! The i/o service this handle is attached to
  io_service *service() const noexcept { return _service; }
private:
  using shared_size_type = size_type;
#ifdef WIN32
  HANDLE _v;
public:
  //! Create a handle opening access to a file on path managed using i/o service service
  static result<handle> create(io_service &service, filesystem::path path, mode _mode=mode::read, creation _creation = creation::open, unsigned flags = 0) noexcept
  {
    DWORD access = GENERIC_READ;
    switch (_mode)
    {
    case mode::append:
      access = FILE_APPEND_DATA;
      break;
    case mode::write:
      access = GENERIC_WRITE | GENERIC_READ;
      break;
    }
    DWORD creation = OPEN_EXISTING;
    switch (_creation)
    {
    case creation::only_if_not_exist:
      creation = CREATE_NEW;
      break;
    case creation::if_needed:
      creation = OPEN_ALWAYS;
      break;
    case creation::truncate:
      creation = TRUNCATE_EXISTING;
      break;
    }
    DWORD attribs = FILE_FLAG_OVERLAPPED;
    if (!!(flags & flag_direct)) attribs |= FILE_FLAG_NO_BUFFERING;
    if (!!(flags & flag_sync)) attribs |= FILE_FLAG_WRITE_THROUGH;
    //if(flags & flag_delete_on_close)
    //  attribs |= FILE_FLAG_DELETE_ON_CLOSE;
    result<handle> ret(handle(&service, std::move(path), flags));
    if (INVALID_HANDLE_VALUE == (ret.value()._v = CreateFile(ret.value()._path.c_str(), access, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, creation, attribs, NULL)))
      return make_errored_result<handle>(GetLastError());
    return ret;
  }
  ~handle()
  {
    if (_v) CloseHandle(_v);
  }
#else
  int _v;
public:
  //! Create a handle opening access to a file on path managed using i/o service service
  static result<handle> create(io_service &service, filesystem::path path, mode _mode=mode::read, creation _creation = creation::open, unsigned flags = 0) noexcept
  {
    int attribs = O_RDONLY;
    switch (_mode)
    {
    case mode::write:
      attribs = O_RDWR;
      break;
    case mode::append:
      attribs = O_APPEND;
      break;
    }
    switch (_creation)
    {
    case creation::only_if_not_exist:
      attribs |= O_CREAT | O_EXCL;
      break;
    case creation::if_needed:
      attribs |= O_CREAT;
      break;
    case creation::truncate:
      attribs |= O_TRUNC;
      break;
    }
    if (!!(flags & flag_direct)) attribs |= O_DIRECT;
    if (!!(flags & flag_sync)) attribs |= O_SYNC;
    result<handle> ret(handle(&service, std::move(path), flags));
    if (-1 == (ret.value()._v = ::open(ret.value()._path.c_str(), attribs, 0x1b0/*660*/)))
      return make_errored_result<handle>(errno);
    return ret;
  }
  ~handle()
  {
    if (_v)
    {
      // FIXME: Should delete on last open file handle close instead
      if(_flags & flag_delete_on_close)
        ::unlink(_path.c_str());
      ::close(_v);
    }
  }
#endif
private:
  template<class CompletionRoutine, class BuffersType> struct _io_state_type
  {
    handle *parent;
    io_result<BuffersType> result;
    CompletionRoutine completion;
    size_t items;
    shared_size_type items_to_go;
    constexpr _io_state_type(handle *_parent, CompletionRoutine &&f, size_t _items) : parent(_parent), result(make_result(BuffersType())), completion(std::forward<CompletionRoutine>(f)), items(_items), items_to_go(0) { }
    virtual ~_io_state_type()
    {
      // i/o pending is very bad, this should never happen
      assert(!items_to_go);
      if (items_to_go)
      {
        std::cerr << "FATAL: io_state destructed while i/o still in flight, the derived class should never allow this." << std::endl;
        abort();
      }
    }
  };
  struct _io_state_deleter { template<class U> void operator()(U *_ptr) const { _ptr->~U(); char *ptr = (char *)_ptr; ::free(ptr); } };
  template<class CompletionRoutine, class BuffersType> using _io_state_ptr = std::unique_ptr<_io_state_type<CompletionRoutine, BuffersType>, _io_state_deleter>;
  template<class CompletionRoutine, class BuffersType, class IORoutine> result<_io_state_ptr<CompletionRoutine, BuffersType>> _begin_io(io_request<BuffersType> reqs, CompletionRoutine &&completion, IORoutine &&ioroutine, const std::chrono::system_clock::time_point *deadline = nullptr) noexcept
  {
#ifdef WIN32
    // Need to keep a set of OVERLAPPED matching the scatter-gather buffers
    struct state_type : public _io_state_type<CompletionRoutine, BuffersType>
    {
      OVERLAPPED ols[1];
      state_type(handle *_parent, CompletionRoutine &&f, size_t _items) : _io_state_type<CompletionRoutine, BuffersType>(_parent, std::forward<CompletionRoutine>(f), _items) { }
      virtual ~state_type() override final
      {
        // Do we need to cancel pending i/o?
        if (items_to_go)
        {
          for (size_t n = 0; n < items; n++)
          {
            // If this is non-zero, probably this i/o still in flight
            if (ols[n].hEvent)
              CancelIoEx(parent->_v, ols + n);
          }
          // Pump the i/o service until all pending i/o is completed
          while (items_to_go)
            parent->service()->run();
        }
      }
    } *state;
    extent_type offset = reqs.offset;
    size_t statelen = sizeof(state_type)+(reqs.buffers.size()-1)*sizeof(OVERLAPPED), items(reqs.buffers.size());
    using return_type = _io_state_ptr<CompletionRoutine, BuffersType>;
    void *mem = ::malloc(statelen);
    if (!mem)
      return make_errored_result<return_type>(ENOMEM);
    return_type _state((_io_state_type<CompletionRoutine, BuffersType> *) mem);
    memset((state=(state_type *) mem), 0, statelen);
    new(state) state_type(this, std::forward<CompletionRoutine>(completion), items);
    // To be called once each buffer is read
    struct handle_completion
    {
      static VOID CALLBACK Do(DWORD errcode, DWORD bytes_transferred, LPOVERLAPPED ol)
      {
        state_type *state = (state_type *)ol->hEvent;
        ol->hEvent = nullptr;
        if (state->result)
        {
          if (errcode)
            state->result = make_errored_result<BuffersType>(errcode);
          else
          {
            // Figure out which i/o I am and update the buffer in question
            size_t idx = ol - state->ols;
            state->result.value()[idx].second = bytes_transferred;
          }
        }
        state->parent->service()->_work_done();
        // Are we done?
        if (!--state->items_to_go)
          state->completion(state);
      }
    };
    // Noexcept move the buffers from req into result
    BuffersType &out = state->result.value();
    out = std::move(reqs.buffers);
    for (size_t n = 0; n < items; n++)
    {
      LPOVERLAPPED ol = state->ols + n;
      ol->Offset = offset & 0xffffffff;
      ol->OffsetHigh = (offset >> 32) & 0xffffffff;
      // Use the unused hEvent member to pass through the state
      ol->hEvent = (HANDLE)state;
      offset += out[n].second;
      ++state->items_to_go;
      if (!ioroutine(_v, out[n].first, (DWORD) out[n].second, ol, handle_completion::Do))
      {
        --state->items_to_go;
        state->result = make_errored_result<BuffersType>(GetLastError());
        // Fire completion now if we didn't schedule anything
        if (!n)
          state->completion(state);
        return _state;
      }
      service()->_work_enqueued();
    }
    return _state;
#else
#error todo
#endif
  }
public:
  /*! Scatter read buffers from an offset into the open file. Note buffers returned may not be buffers input,
  and the deadline is a best effort deadline, if i/o takes long to cancel it may be significantly late.
  */
  io_result<buffers_type> read(io_request<buffers_type> reqs, const std::chrono::system_clock::time_point *deadline = nullptr) noexcept
  {
    io_result<buffers_type> ret;
    auto _io_state(_begin_io(std::move(reqs), [&ret](auto *state) {
      ret = std::move(state->result);
    }, ReadFileEx, deadline));
    BOOST_OUTCOME_FILTER_ERROR(io_state, _io_state);

    // While i/o is not done pump i/o completion
    while(!ret)
    {
      auto t(_service->run_until(deadline));
      // If i/o service pump failed or timed out, cancel outstanding i/o and return
      if (!t)
        return make_errored_result<buffers_type>(t.get_error());
    }
    return ret;
  }
  /*! Gather write buffers to an offset into the open file. Note buffers returned may not be buffers input,
  and the deadline is a best effort deadline, if i/o takes long to cancel it may be significantly late.
  */
  io_result<const_buffers_type> write(io_request<const_buffers_type> reqs, const std::chrono::system_clock::time_point *deadline = nullptr) noexcept
  {
    io_result<const_buffers_type> ret;
    auto _io_state(_begin_io(std::move(reqs), [&ret](auto *state) {
      ret = std::move(state->result);
    }, WriteFileEx, deadline));
    BOOST_OUTCOME_FILTER_ERROR(io_state, _io_state);

    // While i/o is not done pump i/o completion
    while (!ret)
    {
      auto t(_service->run_until(deadline));
      // If i/o service pump failed or timed out, cancel outstanding i/o and return
      if (!t)
        return make_errored_result<const_buffers_type>(t.get_error());
    }
    return ret;
  }
  /*! Resize a file to the given extent
  */
  result<extent_type> truncate(extent_type newsize) noexcept
  {
#ifdef WIN32
    FILE_END_OF_FILE_INFO feofi;
    feofi.EndOfFile.QuadPart = newsize;
    if (!SetFileInformationByHandle(_v, FileEndOfFileInfo, &feofi, sizeof(feofi)))
      return make_errored_result<extent_type>(GetLastError());
    return newsize;
#else
#error todo
#endif
  }
};

int main(int argc, char *argv[])
{
  std::regex torun(".*");
  bool regexvalid = false;
  unsigned torunflags = permute_flags_max-1;
  if (argc > 1)
  {
    try
    {
      torun.assign(argv[1]);
      regexvalid = true;
    }
    catch (...) {}
    if (argc > 2)
      torunflags = atoi(argv[2]);
    if (!regexvalid)
    {
      std::cerr << "Usage: " << argv[0] << " <regex for tests to run> [<flags>]" << std::endl;
      return 1;
    }
  }

  std::ofstream results("fs_probe_results.yaml", std::ios::app);
  {
    std::time_t t = std::time(nullptr);
    results << "---\ntimestamp: " << std::put_time(std::gmtime(&t), "%F %T %z") << std::endl;
  }
  for (unsigned flags = 0; flags <= torunflags; flags++)
  {
    if (!flags || !!(flags & torunflags))
    {
      // Figure out what the minimum atomic write is
      if (std::regex_match(profile[0].min_atomic_write.name, torun))
      {
        using off_t = io_service::extent_type;
        profile[flags].max_atomic_write.value = 1;
        for (off_t size = !!(flags & flag_direct) ? 512 : 64; size <= 1 * 1024 * 1024 && size<profile[flags].min_atomic_write.value; size = size * 2)
        {
          // Create two concurrent writer threads
          std::vector<std::thread> writers;
          std::atomic<size_t> done(2);
          for (char no = '1'; no <= '2'; no++)
            writers.push_back(std::thread([size, flags, no, &done] {
            io_service service;
            auto _h(handle::create(service, "temp", mode::write, creation::if_needed, flags | flag_delete_on_close | flag_no_race_protection));
            if (!_h)
            {
              std::cerr << "FATAL ERROR: Could not open work file due to " << _h.get_error().message() << std::endl;
              abort();
            }
            auto h(std::move(_h.get()));
            std::vector<char> buffer(size, no);
            handle::io_request<handle::const_buffers_type> reqs({ std::make_pair(buffer.data(), size) }, 0);
            // Preallocate space before testing
            h.truncate(size);
            h.write(reqs);
            --done;
            while (done)
              std::this_thread::yield();
            while (!done)
            {
              h.write(reqs);
            }
          }));
          while (done)
            std::this_thread::yield();
          // Repeatedly read from the file and check for torn writes
          io_service service;
          auto _h(handle::create(service, "temp", mode::read, creation::open, flags | flag_delete_on_close | flag_no_race_protection));
          if (!_h)
          {
            std::cerr << "FATAL ERROR: Could not open work file due to " << _h.get_error().message() << std::endl;
            abort();
          }
          auto h(std::move(_h.get()));
          std::vector<char> buffer(size, 0);
          handle::io_request<handle::buffers_type> reqs({ std::make_pair(buffer.data(), size) }, 0);
          bool failed = false;
          std::cout << "direct=" << !!(flags & flag_direct) << " sync=" << !!(flags & flag_sync)<< " testing atomicity of writes of " << size << " bytes ..." << std::endl;
          for (size_t transitions = 0; transitions < 10000; transitions++)
          {
            h.read(reqs);
            const size_t *data = (size_t *)buffer.data(), *end=(size_t *)(buffer.data()+size);
            for (const size_t *d = data; d < end; d++)
            {
              if (*d != *data)
              {
                failed = true;
                off_t failedat = d - data;
                if (failedat < profile[flags].min_atomic_write.value)
                {
                  std::cout << "  Torn write at offset " << failedat << std::endl;
                  profile[flags].min_atomic_write.value = failedat;
                }
                break;
              }
            }
          }
          if (!failed)
          {
            if (size > profile[flags].max_atomic_write.value)
              profile[flags].max_atomic_write.value = size;
          }
          done = true;
          for (auto &writer : writers)
            writer.join();
          if (failed)
            break;
        }
        if (profile[flags].min_atomic_write.value > profile[flags].max_atomic_write.value)
          profile[flags].min_atomic_write.value = profile[flags].max_atomic_write.value;
      }
      // Write out results for this combination of flags
      std::cout << "\ndirect=" << !!(flags & flag_direct) << " sync=" << !!(flags & flag_sync) << ":\n";
      profile[flags].write(0, std::cout);
      std::cout.flush();
      results << "direct=" << !!(flags & flag_direct) << " sync=" << !!(flags & flag_sync) << ":\n";
      profile[flags].write(0, results);
      results.flush();
    }
  }

  return 0;
}